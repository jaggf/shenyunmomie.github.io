<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试工程师入门知识</title>
      <link href="/2023/09/12/%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/09/12/%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之散列表</title>
      <link href="/2023/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2023/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p><strong>散列表</strong>是元素集合，其中的元素以一种便于查找的方式存储。散列表中的每个位置通常被称为槽，其中可以存储一个元素。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309081219108.png" alt="image-20230908121924791" style="zoom:67%;" /><p><strong>散列函数</strong>将散列表中的元素与其所属位置对应起来</p><p>例如：取余函数%11</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309081220593.png" alt="image-20230908122007463" style="zoom: 80%;" /><p>将计算出的散列值插入散列表的对应位置</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309081221028.png" alt="image-20230908122117579" style="zoom:67%;" /><p>**载荷因子(λ)**：散列表的占用率</p><p><strong>散列冲突</strong>：元素77在散列表的0位置，如果再来一个元素44，它的散列值也是0。将两个元素都放入同一个槽，这种情况被称作冲突，也叫“碰撞”</p><p><strong>完美散列函数</strong>：给定一个元素集合，能将每个元素映射到不同的槽，这种散列函数称作完美散列函数。</p><p>​如果元素已知，并且集合不变，那么构建完美散列函数是可能的。</p><p>​不幸的是，给定任意一个元素集合，没有系统化方法来保证散列函数是完美的。</p><p><strong>散列函数要求</strong>：冲突数最少，计算方便，元素均匀分布于散列表中。</p><p><strong>构建完美散列函数方法</strong>：</p><ul><li>增大散列表：使之能容纳每一个元素，这样就能保证每个元素都有属于自己的槽，元素多时候不可取</li></ul><p>散列函数一定要高效，以免它成为存储和搜索过程的负担。如果散列函数过于复杂，计算槽编号的工作量可能比在进行顺序搜索或二分搜索时的更大，这可不是散列的初衷。</p><ul><li><input disabled="" type="checkbox"> 举例：字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串：unicode编码求和，再取余数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">astring,tablesize</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> astring:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + <span class="built_in">ord</span>(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>%tablesize</span><br><span class="line"></span><br><span class="line"><span class="comment"># astr = &#x27;cat&#x27;</span></span><br><span class="line"><span class="comment"># print(hash(astr, 11))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对异序词，这个散列函数总是得到相同的散列值</span></span><br><span class="line"><span class="comment"># 所以用字符位置作为权重因子</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">astring,tablesize</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> astring:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + <span class="built_in">ord</span>(s) * count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>%tablesize</span><br><span class="line"><span class="comment"># astr = &#x27;cta&#x27;</span></span><br><span class="line"><span class="comment"># print(hash(astr, 11))</span></span><br></pre></td></tr></table></figure><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>当两个元素被分到同一个槽中时，必须通过一种系统化方法在散列表中安置第二个元素。这个过程被称为处理冲突。</p><p><strong>再散列</strong>泛指在发生冲突后寻找另一个槽的过程。</p><ul><li><input disabled="" type="checkbox"> 一种方法是在散列表中找到另一个空槽，用于放置引起冲突的元素。</li></ul><p>简单的做法是从起初的散列值开始，顺序遍历散列表，直到找到一个空槽。注意，为了遍历散列表，可能需要往回检查第一个槽。这个过程被称为<strong>开放定址法</strong>，它尝试在散列表中寻找下一个空槽或地址。由于是逐个访问槽，因此这个做法被称作<strong>线性探测</strong>。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309081221028.png" alt="image-20230908122117579" style="zoom:67%;" /><p>在这个散列表中，如果我们添加新元素44，它的散列值是0，但0已有元素77，根据线性探测，我们将把44存储在下一个None位置，也就是1中，如果再添加新元素55，则会放在2中。</p><p>当然，查找会产生额外开销，比如找55时，我们根据散列值0查到了77，值不匹配，说明可能存在散列冲突，随后进行线性搜索，1位置44，不匹配，2位置55，返回True。如果查找不存在的元素66，当我们搜索的3位置是个None时，也就是<strong>遇到空槽</strong>，就说明元素不存在，返回False。</p><p>线性探测有个缺点，那就是会使散列表中的元素出现<strong>聚集现象</strong>。也就是说，如果一个槽发生太多冲突，线性探测会填满其附近的槽，而这会影响到后续插入的元素。</p><p><strong>扩展线性探测</strong>，不再依次顺序查找空槽，而是跳过(skip)一些槽，这样做能使引起冲突的元素分布得更均匀。“跨步”（skip）的大小要能保证表中所有的槽最终都被访问到，否则就会浪费槽资源。<strong>所以建议散列表的大小为素数</strong></p><p><strong>平方探测</strong>是线性探测的一个变体，它不采用固定的跨步大小，而是通过再散列函数递增散列值。如果第一个散列值是h，后续的散列值就是h+1、h+4、h+9、h+16</p><ul><li><input disabled="" type="checkbox"> 另一种处理冲突的方法是让每个槽有一个指向元素集合（或链表）的引用</li></ul><p><strong>链接法</strong>允许散列表中的同一个位置上存在多个元素。发生冲突时，元素仍然被插入其散列值对应的槽中。不过，随着同一个位置上的元素越来越多，搜索变得越来越困难。</p><h2 id="实现映射抽象数据类型"><a href="#实现映射抽象数据类型" class="headerlink" title="实现映射抽象数据类型"></a>实现映射抽象数据类型</h2><p>字典是存储键-值对的数据类型。键用来查找关联的值，这个概念常常被称作<strong>映射</strong>。</p><p>python中的字典的存储结构就是由散列表实现的，这里通过映射类型进行说明。</p><p>映射抽象数据类型定义如下。它是将键和值关联起来的无序集合，其中的键是不重复的，键和值之间是一一对应的关系。映射支持以下操作。</p><ul><li>Map()：创建一个空的映射，它返回一个空的映射集合。</li><li>put(key, val)：往映射中加入一个新的键-值对。如果键已经存在，就用新值替换旧值。</li><li>get(key)：返回key对应的值。如果key不存在，则返回None。</li><li>del：通过del map[key]这样的语句从映射中删除键-值对。</li><li>len()：返回映射中存储的键-值对的数目。</li><li>in：通过key in map这样的语句，在键存在时返回True，否则返回False。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 映射抽象数据类型:键值对字典</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashTalbe</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.size = <span class="number">11</span></span><br><span class="line">        self.slots = [<span class="literal">None</span>] * self.size</span><br><span class="line">        self.data = [<span class="literal">None</span>] * self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hashfunction</span>(<span class="params">self,key</span>):</span><br><span class="line">        <span class="keyword">return</span> key%self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">refresh</span>(<span class="params">self,oldhash</span>):</span><br><span class="line">        <span class="keyword">return</span> (oldhash+<span class="number">1</span>)%self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self,key,data</span>):</span><br><span class="line">        hashValue = self.hashfunction(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.slots[hashValue] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.slots[hashValue] = key</span><br><span class="line">            self.data[hashValue] = data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.slots[hashValue] == key:</span><br><span class="line">                self.data[hashValue] = data</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newhash = self.refresh(hashValue)</span><br><span class="line">                <span class="keyword">while</span> newhash != hashValue:</span><br><span class="line">                    <span class="keyword">if</span> self.slots[newhash] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.slots[newhash] == key:</span><br><span class="line">                        self.slots[newhash] = key</span><br><span class="line">                        self.data[newhash] = data</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        newhash = self.refresh(newhash)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,key</span>):</span><br><span class="line">        hashValue = self.hashfunction(key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.slots[hashValue] == key:</span><br><span class="line">            <span class="keyword">return</span> self.data[hashValue]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newhash = self.refresh(hashValue)</span><br><span class="line">            <span class="keyword">while</span> newhash != hashValue <span class="keyword">and</span> self.slots[newhash] != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> self.slots[newhash] == key:</span><br><span class="line">                    <span class="keyword">return</span> self.data[newhash]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    newhash = self.refresh(newhash)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="keyword">return</span> self.put(key,value)</span><br></pre></td></tr></table></figure><h2 id="散列搜索算法"><a href="#散列搜索算法" class="headerlink" title="散列搜索算法"></a>散列搜索算法</h2><p>在最好情况下，散列搜索算法的时间复杂度是O(1)，即常数阶。然而，因为可能发生冲突，所以比较次数通常不会这么简单</p><p><em>在分析散列表的使用情况时，最重要的信息就是载荷因子λ。从概念上来说，如果λ很小，那么发生冲突的概率就很小，元素也就很有可能各就各位。如果λ很大，则意味着散列表很拥挤，发生冲突的概率也就很大。</em></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法之搜索和排序</title>
      <link href="/2023/09/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/09/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><blockquote><p>搜索是指从元素集合中找到某个特定元素的算法过程。搜索过程通常返回True或False，分别表示元素是否存在。有时，可以修改搜索过程，使其返回目标元素的位置。</p></blockquote><h2 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h2><p>存储于列表等集合中的数据项彼此存在线性或顺序的关系，每个数据项的位置与其他数据项相关。</p><p>在Python列表中，数据项的位置就是它的下标。因为下标是有序的，所以能够顺序访问，由此可以进行顺序搜索。(遍历)</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309071640058.png" alt="image-20230907164034879" style="zoom: 33%;" /><h3 id="无序列表的顺序搜索"><a href="#无序列表的顺序搜索" class="headerlink" title="无序列表的顺序搜索"></a>无序列表的顺序搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sequentialSearch</span>(<span class="params">iters,item</span>):</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> iters:</span><br><span class="line">        <span class="keyword">if</span> i == item:</span><br><span class="line">            <span class="comment"># return found := True</span></span><br><span class="line">            <span class="comment"># 海象表达式，它可以在条件语句、循环语句等场景下使用，但不能直接与返回语句结合。</span></span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> found</span><br><span class="line">    <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h3 id="有序列表的顺序搜索"><a href="#有序列表的顺序搜索" class="headerlink" title="有序列表的顺序搜索"></a>有序列表的顺序搜索</h3><p>假设列表中的元素按升序排列。如果存在目标元素，那么它出现在n个位置中任意一个位置的可能性仍然一样大，因此比较次数与在无序列表中相同。</p><p>如果<strong>不存在目标元素</strong>，那么搜索效率就会提高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">orderSequentialSearch</span>(<span class="params">iters,item</span>):</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> iters:</span><br><span class="line">        <span class="keyword">if</span> i == item:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; item:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><h3 id="有序列表的二分搜索"><a href="#有序列表的二分搜索" class="headerlink" title="有序列表的二分搜索"></a>有序列表的二分搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binarySearch</span>(<span class="params">iters,item</span>):</span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line">    front = <span class="number">0</span></span><br><span class="line">    after = <span class="built_in">len</span>(iters) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> found != <span class="literal">True</span> <span class="keyword">and</span> after&gt;=front:</span><br><span class="line">        middle = (after + front) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> iters[middle] == item:</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> iters[middle] &lt; item:</span><br><span class="line">            front = middle+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            after = middle-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure><h3 id="有序列表的二分搜索：递归"><a href="#有序列表的二分搜索：递归" class="headerlink" title="有序列表的二分搜索：递归"></a>有序列表的二分搜索：递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recurBinarySearch</span>(<span class="params">iters,item</span>):</span><br><span class="line">    middle = <span class="built_in">len</span>(iters)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> iters[middle] == item:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(iters) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iters[<span class="number">0</span>] == item</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> iters[middle] &lt; item:</span><br><span class="line">            <span class="keyword">return</span> recurBinarySearch(iters[middle:],item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> recurBinarySearch(iters[:middle-<span class="number">1</span>],item)</span><br></pre></td></tr></table></figure><p>尽管二分搜索通常优于顺序搜索，但当n较小时，排序引起的额外开销可能并不划算</p><p>如果排序一次后能够搜索多次，那么排序的开销不值一提。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序多次遍历列表。它比较相邻的元素，将不合顺序的交换。每一轮遍历都将下一个最大值放到正确的位置上。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309100138698.png" alt="image-20230910013814329" style="zoom: 67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="keyword">for</span> passnum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(passnum):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># temp = alist[i]</span></span><br><span class="line">                <span class="comment"># alist[i] = alist[i+1]</span></span><br><span class="line">                <span class="comment"># alist[i+1] = temp</span></span><br><span class="line">                alist[i],alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>],alist[i]</span><br></pre></td></tr></table></figure><p>冒泡排序通常被认为是效率最低的排序算法，因为在确定最终的位置前必须交换元素。</p><p><strong>短冒泡</strong>：如果在一轮遍历中没有发生元素交换，就可以确定列表已经有序。可以修改冒泡排序函数，使其在遇到这种情况时提前终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shortBubbleSort</span>(<span class="params">alist</span>):</span><br><span class="line">    exchanges = <span class="literal">False</span></span><br><span class="line">    passnum = <span class="built_in">len</span>(alist)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> passnum &gt; <span class="number">0</span> <span class="keyword">and</span> exchanges:</span><br><span class="line">        exchanges = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(passnum):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                exchanges = <span class="literal">True</span></span><br><span class="line">                alist[i], alist[i + <span class="number">1</span>] = alist[i + <span class="number">1</span>], alist[i]</span><br><span class="line">        passnum -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序在冒泡排序的基础上做了改进，每次遍历列表时只做一次交换。要实现这一点，选择排序在每次遍历时寻找最大值，并在遍历完之后将它放到正确位置上。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309100413916.png" alt="image-20230910041324949" style="zoom: 67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="keyword">for</span> fillslot <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        positionOfMax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> location <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,fillslot+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> alist[location] &gt; alist[positionOfMax]:</span><br><span class="line">                positionOfMax = location</span><br><span class="line"></span><br><span class="line">        alist[fillslot],alist[positionOfMax] = alist[positionOfMax],alist[fillslot]</span><br></pre></td></tr></table></figure><p>选择排序算法和冒泡排序算法的比较次数相同，所以时间复杂度也是O( 2n )。但是，由于减少了交换次数，因此选择排序算法通常更快。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的时间复杂度也是O(n2)，但原理稍有不同。它在列表较低的一端维护一个有序的子列表，并逐个将每个新元素“插入”这个子列表。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309100348388.png" alt="image-20230910034852669" style="zoom: 50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(alist)):</span><br><span class="line">        currentValue = alist[index]</span><br><span class="line">        positon = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> positon &gt; <span class="number">0</span> <span class="keyword">and</span> alist[positon-<span class="number">1</span>] &gt; currentValue:</span><br><span class="line">            alist[positon] = alist[positon-<span class="number">1</span>]</span><br><span class="line">            positon = positon - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        alist[positon] = currentValue</span><br></pre></td></tr></table></figure><p>总体来说，交换操作的处理时间大约是移动操作的3倍，因为后者只需进行一次赋值</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>插入排序对于<em>接近有序的序列</em>和<em>小序列</em>更加高效</strong></p><p>所以希尔排序核心就是降大序列分为若干小序列进行排序</p><p>希尔排序也称“递减增量排序”，它对插入排序做了改进，将列表分成数个子列表，并对每一个子列表应用插入排序。</p><p>如何切分列表是希尔排序的关键——并不是连续切分，而是使用增量i（有时称作步长）选取所有间隔为i的元素组成子列表。</p><ol><li>切分</li></ol><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309100507382.png" alt="image-20230910050742016" style="zoom: 33%;" /><ol start="2"><li>子列表排序，多次</li></ol><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309100508793.png" alt="image-20230910050840423" style="zoom:33%;" /><ol start="3"><li>总体插入排序</li></ol><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309100509732.png" alt="image-20230910050927563" style="zoom: 50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shellSort</span>(<span class="params">alist</span>):</span><br><span class="line">    sublistcount = <span class="built_in">len</span>(alist)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> sublistcount &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> startpoint <span class="keyword">in</span> <span class="built_in">range</span>(sublistcount):</span><br><span class="line">            getInsertionSort(alist,startpoint,sublistcount)</span><br><span class="line"></span><br><span class="line">        sublistcount = sublistcount//<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getInsertionSort</span>(<span class="params">alist,start,gap</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start+gap,<span class="built_in">len</span>(alist),gap):</span><br><span class="line">        currentValue = alist[i]</span><br><span class="line">        position = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-gap,-<span class="number">1</span>,-gap):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &gt; currentValue:</span><br><span class="line">                alist[j+gap] = alist[j]</span><br><span class="line">                position = position-gap</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        alist[position] = currentValue</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序，它是递归算法，使用分治策略改进排序算法</p><p>每次将一个列表一分为二。如果列表为空或只有一个元素，那么从定义上来说它就是有序的（基本情况）</p><p>如果列表不止一个元素，就将列表一分为二，并对两部分都递归调用归并排序。当两部分都有序后，就进行归并这一基本操作</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309101333486.png" alt="image-20230910133308726" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Splitting&quot;</span>, alist)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(alist) // <span class="number">2</span></span><br><span class="line">        lefthalf = alist[:mid]</span><br><span class="line">        righthalf = alist[mid:]</span><br><span class="line"></span><br><span class="line">        mergeSort(lefthalf)</span><br><span class="line">        mergeSort(righthalf)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(lefthalf) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(righthalf):</span><br><span class="line">            <span class="keyword">if</span> lefthalf[i] &lt; righthalf[j]:</span><br><span class="line">                alist[k] = lefthalf[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                alist[k] = righthalf[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(lefthalf):</span><br><span class="line">            alist[k] = lefthalf[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(righthalf):</span><br><span class="line">            alist[k] = righthalf[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Merging&quot;</span>,alist)</span><br></pre></td></tr></table></figure><p>需要进行logn次拆分，每一次需要进行n次操作，所以一共是nlogn次操作。也就是说，归并排序算法的时间复杂度是O(nlogn)。</p><p>mergeSort函数需要额外的空间来存储切片操作得到的两半部分。当列表较大时，使用额外的空间可能会使排序出现问题。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序也采用分治策略，但不使用额外的存储空间，代价是算法的效率会有所下降</p><ol><li><p>首先选出一个基准值：基准值的位置通常被称作分割点，算法在分割点切分列表，以进行对快速排序的子调用。</p></li><li><p>分区：通过分割点，将其他元素放到一边——要么大于基准值，要么小于基准值。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309101945503.png" alt="image-20230910194533426" style="zoom: 80%;" /><ol start="3"><li>针对左右两部分递归调用快速排序函数</li></ol></li></ol><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309102001933.png" alt="image-20230910200059540" style="zoom:67%;" /><p>最坏情况下，分割点不在列表的中部，而是偏向某一端，这会导致切分不均匀。这会导致时间复杂度变为O( 2n )，因为还要加上递归的开销。</p><p>可以通过多种选择基准值的方法。尝试使用<strong>三数取中法</strong>避免切分不均匀，即在选择基准值时考虑列表的头元素、中间元素与尾元素。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>不论列表是否有序，顺序搜索算法的时间复杂度都是O(n)。</li><li>对于有序列表来说，二分搜索算法在最坏情况下的时间复杂度是O(logn)。</li><li>基于散列表的搜索算法可以达到常数阶。</li><li>冒泡排序、选择排序和插入排序都是O(n^2)算法。</li><li>希尔排序通过给子列表排序，改进了插入排序。它的时间复杂度介于O(n)和O(n^2)之间。</li><li>归并排序的时间复杂度是O(nlogn)，但是归并过程需要用到额外的存储空间。</li><li>快速排序的时间复杂度是O(nlogn)，但当分割点不靠近列表中部时会降到O( n^2 )。它不需要使用额外的存储空间。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之动态规划</title>
      <link href="/2023/09/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/09/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="找零"><a href="#找零" class="headerlink" title="找零"></a>找零</h1><blockquote><p>用最少的硬币</p></blockquote><p>1、如果当前剩余找零金额等于已有硬币面额，递归返回</p><p>2、拆分，按照硬币面额，先给一枚硬币，余下金额继续递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态规划：找零</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recMC</span>(<span class="params">coinValueList,change</span>):</span><br><span class="line">    minCoins = change</span><br><span class="line">    <span class="keyword">if</span> change <span class="keyword">in</span> coinValueList:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c&lt;=change]:</span><br><span class="line">            numCoins = <span class="number">1</span>+recMC(coinValueList,change-coin)</span><br><span class="line">            <span class="keyword">if</span> numCoins&lt;minCoins:</span><br><span class="line">                minCoins = numCoins</span><br><span class="line">        <span class="keyword">return</span> minCoins</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recDC</span>(<span class="params">coinValueList,change,knownResults</span>):</span><br><span class="line">    minCoins = change</span><br><span class="line">    <span class="keyword">if</span> knownResults[change]&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> knownResults[change]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> change <span class="keyword">in</span> coinValueList:</span><br><span class="line">        knownResults[change] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c&lt;=change]:</span><br><span class="line">            <span class="keyword">if</span> knownResults[change]&gt;<span class="number">0</span>:</span><br><span class="line">                numCoins = knownResults[change]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                numCoins = <span class="number">1</span>+recMC(coinValueList,change-coin)</span><br><span class="line">            <span class="keyword">if</span> numCoins&lt;minCoins:</span><br><span class="line">                minCoins = numCoins</span><br><span class="line">        knownResults[change] = minCoins</span><br><span class="line">    <span class="keyword">return</span> minCoins</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dpMakeChange</span>(<span class="params">coinValueList,change</span>):</span><br><span class="line">    minCoins = [<span class="number">0</span>]*(change+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> <span class="built_in">range</span>(change+<span class="number">1</span>):</span><br><span class="line">        minCoins[cents] = cents</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c&lt;=cents]:</span><br><span class="line">            numCoins = minCoins[cents-coin]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> numCoins&lt;minCoins[cents]:</span><br><span class="line">                minCoins[cents] = numCoins</span><br><span class="line">    <span class="keyword">return</span> minCoins[change]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dpMakeChange_evol</span>(<span class="params">coinValueList,change</span>):</span><br><span class="line">    minCoins = [<span class="number">0</span>] * (change + <span class="number">1</span>)</span><br><span class="line">    coinUsed = [<span class="number">0</span>] * (change + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,change + <span class="number">1</span>):</span><br><span class="line">        minCoins[cents] = cents+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c &lt;= cents]:</span><br><span class="line">            numCoins = minCoins[cents - coin] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> numCoins &lt; minCoins[cents]:</span><br><span class="line">                minCoins[cents] = numCoins</span><br><span class="line">                coinUsed[cents] = coin</span><br><span class="line">    <span class="keyword">return</span> minCoins[change]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python之内置数据类型</title>
      <link href="/2023/09/05/python%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/09/05/python%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>在Python中，列表（List）是一种<strong>动态数组</strong>。</p><p>列表的存储结构是基于数组实现的，每个元素在内存中都是连续存储的。</p><p>当创建一个列表时，Python会为其分配一块连续的内存空间来存储元素，列表的长度可以根据需要动态增长或缩小，如果该列表没有连续的内存空间剩余，则会在内存其他空闲位置重写开辟一块内存，并深复制到其中。</p><p>还会分配另外一块内存空间来存储索引数组。索引数组中的每个元素对应着相应元素在列表内存空间中的位置。</p><ul><li><p><input disabled="" type="checkbox"> 时间复杂度</p><p>在列表末尾调用pop时，操作是常数阶的，在列表头一个元素或中间某处调用pop时，则是n阶的</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309051216195.png" alt="image-20230905121647246"></p></li></ul><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>列表切片是通过创建一个新的列表对象，然后浅拷贝其中的元素。但列表中的元素仍然是原始列表中元素的引用。修改切片后的列表元素也会影响到原始列表的对应位置元素，因为它们指向的是同一个内存地址。这意味着对于带嵌套的列表，其中的复合对象无法做到数据隔离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片(浅拷贝)</span></span><br><span class="line">original_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">sliced_list = original_list[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(original_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(sliced_list)  <span class="comment"># 输出: [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">sliced_list[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(original_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(sliced_list)  <span class="comment"># 输出: [99, 3, 4]</span></span><br></pre></td></tr></table></figure><p>列表可以通过copy方法实现深拷贝，它能逐层拷贝列表，实现数据隔离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">original_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">copied_list = original_list.copy()  <span class="comment">#或者使用 copied_list = list(original_list)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(original_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(copied_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">copied_list[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(original_list)  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">print</span>(copied_list)  <span class="comment"># 输出: [99, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><p>字典（Dictionary）是一种无序的键值对集合，它的存储结构是基于哈希表（Hash Table）实现的</p><p>哈希表是一种高效的数据结构，它通过将键（Key）映射到一个唯一的索引位置来实现快速的查找和插入操作。在字典中，每个键都必须是唯一的，而值（Value）可以是任意类型的对象。</p><p>当创建一个字典时，Python会为其分配一块内存空间来存储键值对。字典的长度可以根据需要动态增长或缩小，这使得字典非常灵活。</p><ul><li><input disabled="" type="checkbox"> 时间复杂度</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309051704673.png" alt="image-20230905170410714"></p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 内置数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之栈、队列和递归</title>
      <link href="/2023/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%80%92%E5%BD%92/"/>
      <url>/2023/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h1><blockquote><p>栈是一种只能在一端进行操作的线性表，它最大的特点是进行数据操作时必须遵循“后进先出（Last In FirstOut，LIFO）”的原则</p></blockquote><ul><li><p><input disabled="" type="checkbox"> 术语</p><p>栈顶(top)：可以进行增删改查操作的一端</p><p>栈底(bottom)：无法进行上述操作</p></li><li><p><input disabled="" type="checkbox"> 栈的基本操作</p></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309041206375.png" alt="image-20230904120647171"></p><ul><li><input disabled="" type="checkbox"> 栈的抽象数据类型的定义</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309041208658.png" alt="image-20230904120801698"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309051734894.png" alt="image-20230905173401458"></p><h2 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h2><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309041538841.png" alt="image-20230904153810518"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SequenceStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.top = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.stack.append(data)</span><br><span class="line">        self.top += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = self.stack.pop()</span><br><span class="line">            self.top -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.top == -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">len</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.top+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getTop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[self.top]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>()):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;第<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>元素：<span class="subst">&#123;self.stack[i]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h3><p>1、匹配括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sequence_stack <span class="keyword">import</span> SequenceStack</span><br><span class="line"></span><br><span class="line">txt = <span class="string">&quot;(()()()())(((())))(()((())()))&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perCheck</span>(<span class="params">txt</span>):</span><br><span class="line">    stack = SequenceStack()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> txt:</span><br><span class="line">        <span class="keyword">if</span> t == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.push(t)</span><br><span class="line">        <span class="keyword">elif</span> t == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack.is_empty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> stack.is_empty()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(perCheck(txt))</span><br></pre></td></tr></table></figure><p>2、进制转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sequence_stack <span class="keyword">import</span> SequenceStack</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binaryTransform</span>(<span class="params">num</span>):</span><br><span class="line">    stack = SequenceStack()</span><br><span class="line">    <span class="keyword">while</span> num&gt;<span class="number">0</span>:</span><br><span class="line">        d = num % <span class="number">2</span></span><br><span class="line">        stack.push(d)</span><br><span class="line">        num = num//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    binStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> stack.is_empty() == <span class="literal">False</span>:</span><br><span class="line">        d = stack.pop()</span><br><span class="line">        binStr = binStr + <span class="built_in">str</span>(d)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> binStr</span><br><span class="line"></span><br><span class="line">num = <span class="number">233</span></span><br><span class="line"><span class="built_in">print</span>(binaryTransform(num))</span><br></pre></td></tr></table></figure><h2 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h2><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是有序集合，添加操作发生在“尾部”，移除操作则发生在“头部”。最新添加的元素必须在队列的尾部等待，在队列中时间最长的元素则排在最前面。这种排序原则被称作FIFO（first-in first-out）</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309051959466.png" alt="image-20230905195954232"></p><h2 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue == []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.queue.insert(<span class="number">0</span>,data)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># if self.is_empty():</span></span><br><span class="line">        <span class="comment">#     raise IndexError(&quot;queue is empty&quot;)</span></span><br><span class="line">        self.queue.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.queue)</span><br></pre></td></tr></table></figure><h3 id="案例应用-1"><a href="#案例应用-1" class="headerlink" title="案例应用"></a>案例应用</h3><p>1、传炸弹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transmitBomb</span>(<span class="params">namelist,num</span>):</span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> namelist:</span><br><span class="line">        q.enqueue(name)</span><br><span class="line"></span><br><span class="line">    die_list = []</span><br><span class="line">    <span class="keyword">while</span> q.size() != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">            bomb = q.dequeue()</span><br><span class="line">            q.enqueue(bomb)</span><br><span class="line">            q.display()</span><br><span class="line"></span><br><span class="line">        die_list.append(q.dequeue())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q.get_head(),die_list</span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Susan&quot;</span>, <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Kent&quot;</span>, <span class="string">&quot;Brad&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(transmitBomb(name_list, <span class="number">7</span>))</span><br></pre></td></tr></table></figure><p>2、打印机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> squeue <span class="keyword">import</span> sQueue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,cTime</span>):</span><br><span class="line">        self.createTime = cTime</span><br><span class="line">        self.pages = random.randrange(<span class="number">1</span>,<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_cTime</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.createTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_pages</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.pages</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait_time</span>(<span class="params">self,currentSec</span>):</span><br><span class="line">        <span class="keyword">return</span> currentSec - self.createTime</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ppm</span>):</span><br><span class="line">        self._isWork = <span class="literal">False</span></span><br><span class="line">        self.currentTask = <span class="literal">None</span></span><br><span class="line">        self.pagesPerMinute = ppm</span><br><span class="line">        self.timeRemaining = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_working</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._isWork</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.currentTask != <span class="literal">None</span>:</span><br><span class="line">            self.timeRemaining -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.timeRemaining &lt;= <span class="number">0</span>:</span><br><span class="line">                self._isWork = <span class="literal">False</span></span><br><span class="line">                self.currentTask = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_next</span>(<span class="params">self,nextTask</span>):</span><br><span class="line">        self.currentTask = nextTask</span><br><span class="line">        self.timeRemaining = self.currentTask.get_pages()/self.pagesPerMinute*<span class="number">60</span></span><br><span class="line">        self._isWork = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_time = <span class="number">3600</span></span><br><span class="line">    printer_queue = sQueue()</span><br><span class="line">    printer = Printer(ppm=<span class="number">5</span>)</span><br><span class="line">    waitTime = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> currentSec <span class="keyword">in</span> <span class="built_in">range</span>(test_time):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> random.randrange(<span class="number">1</span>,<span class="number">181</span>) == <span class="number">180</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;新任务生成，<span class="subst">&#123;currentSec&#125;</span>&quot;</span>)</span><br><span class="line">            newTask = Task(currentSec)</span><br><span class="line">            printer_queue.enqueue(newTask)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> printer.is_working() == <span class="literal">False</span> <span class="keyword">and</span> printer_queue.is_empty() == <span class="literal">False</span>:</span><br><span class="line">            nextTask = printer_queue.dequeue()</span><br><span class="line">            printer.start_next(nextTask)</span><br><span class="line">            waitTime.append(nextTask.wait_time(currentSec))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;开始打印下一个：<span class="subst">&#123;nextTask.get_cTime()&#125;</span>,<span class="subst">&#123;nextTask.get_pages()&#125;</span>,等待时间：<span class="subst">&#123;nextTask.wait_time(currentSec)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        printer.tick()</span><br><span class="line"></span><br><span class="line">    avgTime = <span class="built_in">sum</span>(waitTime)/<span class="built_in">len</span>(waitTime)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;平均等待时间：<span class="subst">&#123;avgTime&#125;</span>sec，任务剩余数：<span class="subst">&#123;printer_queue.size()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>递归是解决问题的一种方法，它将问题不断地分成更小的子问题，直到子问题可以用普通的方法解决。</p></blockquote><p>举例：递归求和函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recursionSum</span>(<span class="params">numlist</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(numlist) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> numlist[<span class="number">0</span>] + numlist[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> numlist[<span class="number">0</span>] + recursionSum(numlist[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">numlist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(recursionSum(numlist))</span><br></pre></td></tr></table></figure><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309061140911.png" alt="image-20230906114013271" style="zoom:50%;" /><ul><li><p><input disabled="" type="checkbox"> 递归三原则</p><ul><li><p>递归算法必须有基本情况：问题切分到最小时，处理并开始返回，类似循环终止条件</p></li><li><p>递归算法必须<strong>改变其状态</strong>并向基本情况靠近：问题需要一步步切分的</p></li><li><p>递归算法必须递归地调用自己</p></li></ul></li><li><p><input disabled="" type="checkbox"> Python如何实现递归函数调用：栈帧</p></li></ul><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int转换为2-16进制字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intToBinaryStr</span>(<span class="params">num:<span class="built_in">int</span>,base</span>):</span><br><span class="line">    convertStr = <span class="string">&#x27;0123456789ABCDEF&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> num//base&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> convertStr[num%base]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> intToBinaryStr(num//base,base) + convertStr[num%base]</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(intToBinaryStr(num, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>用栈重写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非递归？</span></span><br><span class="line">stack = SequenceStack()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intToBinaryStr_stack</span>(<span class="params">num:<span class="built_in">int</span>,base</span>):</span><br><span class="line">    convertStr = <span class="string">&#x27;0123456789ABCDEF&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> num // base &lt;= <span class="number">0</span>:</span><br><span class="line">        stack.push(convertStr[num])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack.push(convertStr[num%base])</span><br><span class="line">        intToBinaryStr_stack(num//base,base)</span><br></pre></td></tr></table></figure><p>这个例子展示了Python如何实现递归函数调用。当调用函数时，Python分配一个<strong>栈帧</strong>来处理该函数的局部变量。当函数返回时，返回值就在栈的顶端，以供调用者访问。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309061221363.png" alt="image-20230906122155224" style="zoom: 50%;" /><p>栈帧限定了函数所用变量的作用域。尽管反复调用相同的函数，但是每一次调用都会为函数的局部变量创建新的作用域。</p><p><strong>栈帧（Stack Frame）是计算机程序在运行期间用于管理函数调用和返回的数据结构。每当函数被调用时，都会创建一个新的栈帧来保存函数的局部变量、参数、返回地址和其他相关信息。</strong></p><p>栈帧是在程序的执行过程中动态创建和销毁的，它们以堆栈（stack）的方式组织在一起。每个栈帧都有自己的内存空间，用于存储函数调用时所需的数据。栈帧之间按照后进先出（LIFO）的原则进行管理，即最后一个创建的栈帧先被销毁。</p><p>当一个函数被调用时，当前函数的栈帧被推入堆栈中，新的栈帧被创建并成为当前栈帧，在其中执行函数的代码。当函数执行完毕后，当前栈帧被弹出堆栈，上一个栈帧恢复成当前栈帧，并继续执行其余的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之方法重载</title>
      <link href="/2023/09/03/python%E4%B9%8B%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
      <url>/2023/09/03/python%E4%B9%8B%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><blockquote><p>以相同的方法名定义不同的方法，在不同条件下自动选择正确的版本进行调用，这就被称为方法重载。方法重载（Method Overloading）是面向对象的编程语言中经常用到的一个特性</p></blockquote><p>在Python这种动态语言中，没有严格的类型约束，也没有重载的概念。</p><p>方法重载的过程简单来说，就是对不同的输入进行<strong>检查</strong>，然后<strong>派发</strong>给不同代码。</p><h2 id="利用参数类型和数量实现方法重载"><a href="#利用参数类型和数量实现方法重载" class="headerlink" title="利用参数类型和数量实现方法重载"></a>利用参数类型和数量实现方法重载</h2><blockquote><p>在Python中，两个或多个方法不能有相同的名字，所以在方法内进行重载</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b,c=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:<span class="comment">#检查</span></span><br><span class="line">    <span class="built_in">print</span>(a,b,c)<span class="comment">#派发</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(a) == <span class="built_in">int</span>:<span class="comment">#检查</span></span><br><span class="line">        <span class="built_in">print</span>(a+b)<span class="comment">#派发</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(a,b)</span><br><span class="line">            </span><br><span class="line"><span class="comment">#在此例中，参数数量有(a,b)和(a,b,c)的不同，我们用if检查是否有c参数，然后执行if下的代码，实现派发</span></span><br><span class="line"><span class="comment">#参数类型有a:int和a:其他类型，也是用if type(a)检查a的参数类型，然后实现派发</span></span><br></pre></td></tr></table></figure><p>这样做的弊端是，没有像Java重载那样，定义多个同名的方法，所有重载的代码都在一个方法中，如果重载更多更复杂，后续修改和添加也是一个问题，不像java重载那样能快速清晰的定位到。</p><h2 id="利用字典映射实现方法重载"><a href="#利用字典映射实现方法重载" class="headerlink" title="利用字典映射实现方法重载"></a>利用字典映射实现方法重载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a, b, c=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 重载方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_int</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 派发字典</span></span><br><span class="line">    dispatch_dict = &#123;</span><br><span class="line">        (<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">type</span>(<span class="literal">None</span>)): <span class="keyword">lambda</span> x,y,z:add_int(x,y,z),</span><br><span class="line">        (<span class="built_in">float</span>, <span class="built_in">float</span>, <span class="built_in">type</span>(<span class="literal">None</span>)): <span class="keyword">lambda</span> x,y,z: <span class="built_in">float</span>(x + y),</span><br><span class="line">        (<span class="built_in">str</span>, <span class="built_in">str</span>, <span class="built_in">str</span>): <span class="keyword">lambda</span> x,y,z: x + y + z,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 检查</span></span><br><span class="line">    key = (<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c))</span><br><span class="line">    <span class="keyword">return</span> dispatch_dict[key](a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在此例中，我们通过检查全部参数的类型，再与派发字典中的key比对，就能得到应该派发的方法。</span></span><br></pre></td></tr></table></figure><p>这样做就比上面的方法简单明了许多，很多地方与Java重载已经大差不差了，派发字典能清晰查看存在的重载方法，后续添加也更方便，可读性也大大提升。</p><h2 id="利用装饰器实现方法重载"><a href="#利用装饰器实现方法重载" class="headerlink" title="利用装饰器实现方法重载"></a>利用装饰器实现方法重载</h2><h3 id="单派发"><a href="#单派发" class="headerlink" title="单派发"></a>单派发</h3><p>functools包中带有singledispatch单派发装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@add.register(<span class="params"><span class="built_in">str</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@add.register(<span class="params"><span class="built_in">float</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(a + b)</span><br></pre></td></tr></table></figure><p><strong>Singledispatch仅支持单个参数的函数重载</strong></p><h3 id="多派发"><a href="#多派发" class="headerlink" title="多派发"></a>多派发</h3><p>python没有提供多派发的装饰器，需要导入外部的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install multipledispatch</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multipledispatch <span class="keyword">import</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@dispatch(<span class="params"><span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    result = a + b +c</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  </span><br><span class="line"><span class="meta">@dispatch(<span class="params"><span class="built_in">float</span>,<span class="built_in">float</span>,<span class="built_in">float</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    result = <span class="built_in">float</span>(a + b +c)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">multiply(<span class="number">3.6</span>,<span class="number">5.9</span>,<span class="number">9.9</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器实现</span></span><br><span class="line"><span class="comment"># dispatch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overload</span>(<span class="params">func</span>):</span><br><span class="line">    funcs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">        key = <span class="built_in">tuple</span>(arg.__class__ <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> funcs:</span><br><span class="line">            <span class="keyword">return</span> funcs[key](*args)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;No matching function found.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">signiture, func</span>):</span><br><span class="line">        funcs[signiture] = func</span><br><span class="line"></span><br><span class="line">    wrapper.register = register</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment">#从该装饰器可以看出，该方法和字典类似，都设有一个注册表，然后根据数据类型进行分发</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 方法重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之线性表</title>
      <link href="/2023/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="线性表概述"><a href="#线性表概述" class="headerlink" title="线性表概述"></a>线性表概述</h1><p><strong>定义</strong>：线性表是由若干个具有相同特性的数据元素组成的有限序列</p><blockquote><p>栈、队列、双端队列和列表都是有序的数据集合，其元素的顺序取决于添加顺序或移除顺序。一旦某个元素被添加进来，它与前后元素的相对位置将保持不变。这样的数据集合经常被称为线性数据结构。</p></blockquote><p>形式：{a[1],a[2],…,a[i],…,a[n]}</p><p>概念：直接先驱元素、直接后继元素、表头、表尾</p><p>逻辑结构：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308312200886.png" alt="image-20230831220058393"></p><p>类型：有序线性表和无序线性表</p><p><strong>特性</strong>：</p><ul><li>元素个数一定是有限的</li><li>所有元素具有相同的性质</li><li>除表头元素以外，其他所有元素都有唯一的（直接）先驱元素，除表尾元素以外，其他所有元素都有唯一的（直接）后继元素</li></ul><p><strong>抽象数据类型</strong>：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308312205899.png" alt="image-20230831220510668"></p><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="顺序表概念"><a href="#顺序表概念" class="headerlink" title="顺序表概念"></a>顺序表概念</h2><blockquote><p>顺序表是指采用顺序存储的方式来存储数据元素的线性表</p></blockquote><p>将结点依次存放在一组地址<strong>连续的存储空间</strong>中</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308312350806.png" alt="image-20230831235017246"></p><h2 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h2><p>顺序表基本操作的SequenceList类</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308312353466.png" alt="image-20230831235351295"></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>链表是指采用链式结构来存储数据元素的线性表</p></blockquote><ul><li><p><input disabled="" type="checkbox"> 链表的特点：</p></li><li><p>链表实现了存储空间的<strong>动态管理</strong>。</p></li><li><p>链表在执行插入与删除操作时，不必移动其余元素，只需修改指针即可。</p></li></ul><p><strong>存储密度</strong>：衡量存储空间的使用效率</p><p>顺序表的存储密度为1，链表存储密度小于1</p><h2 id="链表的基本知识"><a href="#链表的基本知识" class="headerlink" title="链表的基本知识"></a>链表的基本知识</h2><ul><li><input disabled="" type="checkbox"> 链表的构成</li></ul><p>链表是由一系列结点通过指针链接而形成的，每个结点可分为数据域和指针域两个部分，数据域可用于存储数据元素，指针域可用于存储下一结点的地址</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309011902542.png" alt="image-20230901190218873"></p><ul><li><input disabled="" type="checkbox"> 链表的类型</li></ul><blockquote><p>单向链表、双向链表及循环链表</p></blockquote><ul><li>单向链表：每个结点只包含一个指针域，它用来指向其直接后继结点</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309011903825.png" alt="image-20230901190351310"></p><ul><li>双向链表：每个结点包含两个指针域，其中一个用于指向先驱结点，可称之为先驱指针；另一个用于指向后继结点，可称之为后继指针</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309011904470.png" alt="image-20230901190403247"></p><ul><li>循环链表：循环链表最后一个结点的指针域指向第一个节点，循环链表有循环单链表和循环双链表之分，特点就是从表中任一结点出发，均可找到表中其他结点</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309011906279.png" alt="image-20230901190611280"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309011906761.png" alt="image-20230901190627720"></p><ul><li><p><input disabled="" type="checkbox"> 带头结点和不带头结点的区别</p><p>插入和删除第一个结点，不带头结点需要特殊考虑，带头结点不需要。</p></li><li><p><input disabled="" type="checkbox"> 链表的基本操作</p></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309011907116.png" alt="image-20230901190708691"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309020232237.png" alt="image-20230902023207029"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head = new_node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只删除第一个data</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.head.data == data:</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">if</span> current.<span class="built_in">next</span>.data == data:</span><br><span class="line">                    current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(current.data,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.head.data == data:</span><br><span class="line">            <span class="keyword">return</span> self.head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                <span class="keyword">if</span> current.data == data:</span><br><span class="line">                    <span class="keyword">return</span> current</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularSingleLinkedList</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = new_node</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span> != self.head:</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">            current.<span class="built_in">next</span> = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;链表为空，找不到<span class="subst">&#123;data&#125;</span>插入&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> current.data == data:</span><br><span class="line">                    new_node.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">                    current.<span class="built_in">next</span> = new_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> current.<span class="built_in">next</span> == self.head:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;链表中不存在<span class="subst">&#123;data&#125;</span>,插入错误&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只删除第一个data</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.head.data == data:</span><br><span class="line">            self.head = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">if</span> current.<span class="built_in">next</span>.data == data:</span><br><span class="line">                    current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;链表为空&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="built_in">print</span>(current.data,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> current == self.head:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.head.data == data:</span><br><span class="line">            <span class="keyword">return</span> self.head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> current:</span><br><span class="line">                <span class="keyword">if</span> current.data == data:</span><br><span class="line">                    <span class="keyword">return</span> current</span><br><span class="line">                current = current.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309020229868.png" alt="image-20230902022919407"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = new_node</span><br><span class="line">            self.tail = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.<span class="built_in">next</span> = new_node</span><br><span class="line">            new_node.prev = self.tail</span><br><span class="line">            self.tail = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = new_node</span><br><span class="line">            self.tail = new_node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head.prev = new_node</span><br><span class="line">            self.head = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self,data</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> current.data == data:</span><br><span class="line">                <span class="keyword">if</span> current == self.head:</span><br><span class="line">                    current.<span class="built_in">next</span>.prev = <span class="literal">None</span></span><br><span class="line">                    self.head = current.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">elif</span> current == self.tail:</span><br><span class="line">                    current.prev.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                    self.tail = current.prev</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current.prev.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">                    current.<span class="built_in">next</span>.prev = current.prev</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="built_in">print</span>(current.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,data</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="keyword">if</span> current.data == data:</span><br><span class="line">                <span class="keyword">return</span> current</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309020235254.png" alt="image-20230902023522179"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularDoubleLinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = new_node</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            new_node.prev = self.head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            self.head.prev.<span class="built_in">next</span> = new_node</span><br><span class="line">            new_node.prev = self.head.prev</span><br><span class="line">            self.head.prev = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepend</span>(<span class="params">self,data</span>):</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = new_node</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            new_node.prev = self.head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">            new_node.prev = self.head.prev</span><br><span class="line">            self.head.prev.<span class="built_in">next</span> = new_node</span><br><span class="line">            self.head.prev = new_node</span><br><span class="line">            self.head = new_node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(current.data,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> current == self.head:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self,data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;链表为空，无数据可删除&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current = self.head</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> current.data == data:</span><br><span class="line">                    <span class="keyword">if</span> current == self.head:</span><br><span class="line">                        current.<span class="built_in">next</span>.prev = self.head.prev</span><br><span class="line">                        self.head.prev.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">                        self.head = current.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        current.prev.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">                        current.<span class="built_in">next</span>.prev = current.prev</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                current = current.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> current == self.head:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self,data</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="keyword">if</span> current.data == data:</span><br><span class="line">                <span class="keyword">return</span> current</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="案例应用"><a href="#案例应用" class="headerlink" title="案例应用"></a>案例应用</h2><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202309022228623.png" alt="image-20230902222830320"></p><p>请结合单链表中的有关操作，输出队形变换后，两支小分队中的总人数和每一位同学的姓名。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构概述</title>
      <link href="/2023/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><hr><h1 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h1><blockquote><p>数据结构是指所有数据及这些数据之间的关系的集合</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>对于计算机而言，<strong>数据</strong>是指能被输入到<em>计算机</em>中并能被其<em>处理</em>的符号的集合</p><p><strong>数据</strong>通常用于描述客观事物</p><p><strong>数据元素</strong>是数据的基本单位</p><p><strong>数据项</strong>是构成数据元素的不可分割的最小单位，也被称为<em>字段、域或属性</em></p><p><strong>数据对象</strong>是性质相同的数据元素的<em>集合</em>，是数据的一个子集，例如整数、字母</p><p><strong>数据结构</strong>是相互之间存在一种或多种<em>特定关系</em>的数据元素的集合，通常这些数据元素都不是孤立存在的，而是通过某种关系将所有数据元素联系起来，我们将这种关系称为结构</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>数据元素之间的逻辑结构是多种多样的，根据数据元素之间的不同关系特性，通常可将数据逻辑结构分为4类，即<strong>集合、线性结构、树形结构和图状（或网状）结构</strong></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308311009062.png" alt="image-20230831100911771"></p><p><strong>线性结构</strong>：该结构中的数据元素之间存在一对一的逻辑关系，并且起始元素和终端元素都是唯一的，除了这两个元素外，剩余的每一个元素都有且仅有一个在其之前和在其之后的元素</p><p><strong>树形结构</strong>：该结构中的数据元素之间存在一对多的逻辑关系，并且除了起始元素外，其余每一个元素都有且仅有一个在其之前的元素，除了终端元素外，其余每一个元素都有一个或多个在其之后的元素</p><p><strong>网状结构</strong>：该结构中的数据元素之间存在多对多的逻辑关系，每个元素都可能有一个或多个在其之前或在其之后的元素。在这一结构中可能没有起始元素和终端元素，也可能有多个起始元素和多个终端元素</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><blockquote><p>数据的存储结构是指数据在计算机中的表示（又称为映像）方法</p></blockquote><p>存储时应包含两方面的内容——数据元素本身及数据元素之间的关系</p><p>总共包含四类：</p><ul><li><p>顺序存储结构</p><p>采用一组物理上连续的存储单元来依次存放所有的数据元素</p></li></ul><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308311012870.png" alt="image-20230831101206160" style="zoom:50%;" /><ul><li><p>链式存储结构</p><p>每一数据元素均使用一个结点来存储，并且每个结点的存储空间是单独分配的，因此存储这些结点的空间不一定是连续的。</p><p>结点包含：数据域、指针域</p></li></ul><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308311017016.png" alt="image-20230831101754834" style="zoom:67%;" /><ul><li><p>索引存储结构</p><p>不仅需要存储所有数据元素（称之为<strong>主数据表</strong>），还需要建立附加的<strong>索引表</strong>。在存储时，每个数据元素都由一个唯一的关键字来标识，由该关键字和对应的数据元素的地址构成一个索引项，并将其存入索引表中</p><p><em>在查找数据元素时，首先由关键字的有序性，在索引表中查找出关键字所在的索引项，并取出该索引项中的地址，再依据此地址在主数据表中找到对应的数据元素。</em></p></li><li><p>哈希（或散列）存储结构</p><p>是指依据数据元素的关键字，通过事先设计好的哈希（或散列）函数计算出一个值，再将其作为该数据元素的存储地址</p></li></ul><h1 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a>数据类型概述</h1><blockquote><p>类型是指一组值的集合，而数据类型则是指一组值的集合及定义在这组值上的一组操作的总称</p></blockquote><p>计算机提供原子类型：“位”“字节”和“字”等，高级语言提供的数据类型。</p><p>python中的数据类型有：</p><ul><li>数字：整型、浮点型、复数型</li><li>字符串</li><li>列表</li><li>元组：()一经创建，不可修改</li><li>集合：{}无序且不重复</li><li>字典：键值对</li></ul><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及定义在该模型上的一组操作</p><p>ADT抽象数据类型名{</p><p>​数据对象：&lt;数据对象的定义&gt;</p><p>​数据关系：&lt;数据关系的定义&gt;</p><p>​<strong>基本操作</strong>：&lt;基本操作的定义&gt;</p><p>}</p><p>基本操作名（参数表）</p><p>初始条件：&lt;初始条件描述&gt;</p><p>操作目的：&lt;操作目的描述&gt;</p><p>操作结果：&lt;操作结果描述&gt;</p><p>举例：复数</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308311159905.png" alt="image-20230831115948216"></p><p>简单来说，就是对一个数据类型，比如int或自定义，进行<strong>抽象描述</strong>，不关心具体实现</p><h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><blockquote><p>算法是对待特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作。</p></blockquote><ul><li><p><input disabled="" type="checkbox"> 算法应具备的特性</p></li><li><p>有穷性：一个算法对于任何合法的输入必须在执行有穷步之后结束，且每一步都可在有穷的时间内完成。</p></li><li><p>确定性：算法中每一条指令都必须具有确切的含义，不能有二义性，并且，在任何条件下，算法的任意一条执行路径都是惟一的，即对于相同的输入所得的输出相同。</p></li><li><p>可行性：是指算法中描述的操作都可以通过<strong>基本运算</strong>执行<strong>有限次操作</strong>来实现。</p></li><li><p>输入：有零个或多个输入，这些输入取自于某个特定对象的集合。</p></li><li><p>输出：零个或多个输出，这些输出是同输入有着某些特定关系的量。</p></li><li><p><input disabled="" type="checkbox"> 衡量算法好坏</p></li><li><p>正确性：要求算法能够正确地执行，并满足预先设定的功能和性能要求。</p></li><li><p>可读性：算法主要是为了给人们阅读和交流的，其次才是在计算机上执行。</p></li><li><p>健壮性：当输入的数据不合法或运行环境改变时，算法能恰当地做出反应或进行处理，而不是产生莫名其妙的输出结果。</p></li><li><p>时间复杂度：对一个算法执行效率的度量。</p></li><li><p>空间复杂度：是指一个算法在执行过程中所占用的存储空间的度量。</p></li></ul><h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><blockquote><p>算法的执行时间是通过依据该算法编写的程序在计算机上执行时所需要的时间来计算的</p></blockquote><p>由于我们所使用的编程语言、计算机的硬件和软件等环境因素，难以得出一个绝对的时间，所以我们只考虑算法本身的问题规模</p><p>一个算法通常是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的</p><p>假设问题规模为n，对应的函数关系记为T(n)，则算法的执行时间大致等于执行基本操作所需的时间×T(n)。</p><p>由于上述对算法执行时间的计算并不是该算法执行的绝对时间，因此通常进一步将算法的执行时间用T(n)的数量级来表示，记作T(n)&#x3D;O(f(n))（其中O是数量级Order的缩写）。</p><p>总结来说，执行一次基本操作记为T(n)&#x3D;1，0到n的循环则记为T(n)&#x3D;n，一个算法的时间复杂度取决于T(n)的量级。</p><p>对于无循环的算法，它的量级是个常量，所以时间复杂度为O(1)</p><p>对于单循环的算法，它的量级最高为n，所以时间复杂度为O(n)</p><p>对于多重循环，例如双重循环，则为O(n^2)</p><p>对于有输入的算法，其时间复杂度还与输入数据集（一个或多个输入）有关，因为对于不同的输入数据集，算法的基本操作重复的次数可能不一样，即算法的时间复杂度可能也不一样。所以就有了最好时间复杂度、最坏时间复杂度和平均时间复杂度</p><h2 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h2><blockquote><p>算法的空间复杂度一般也认为是问题规模n的函数，并以数量级的形式给出</p></blockquote><p>依据某算法编写的程序在计算机运行时所占用的存储空间包括以下部分：</p><ul><li><strong>输入数据</strong>所占用的存储空间</li><li><strong>程序本身</strong>所占用的存储空间</li><li><strong>临时变量</strong>所占用的存储空间</li></ul><p>在对算法的空间复杂度进行研究时，只分析临时变量所占用的存储空间</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合，通常包括数据的逻辑结构和存储结构两个层次，逻辑结构是从具体问题抽象出来的数学模型，是从逻辑关系上描述数据，并不涉及数据在计算机中的存储。根据数据元素之间关系特性的不同，通常分为4类基本的逻辑结构——集合、线性结构、树形结构和图状（或网状）结构。存储结构则是逻辑结构在计算机中的存储表示，大致有4类——顺序存储结构、链式存储结构、索引存储结构和哈希（或散列）存储结构。</p><p>数据类型是程序设计语言中固有的，每种数据类型包含一组值及定义在这组值上的一组操作。抽象数据类型则是由用户自己定义的，是实际问题的数学模型及定义在该模型上的一组操作，具体包括3个方面：数据对象，数据对象上关系的集合，以及对数据对象的基本操作的集合。</p><p>算法是为了解决特定问题而设计的方法。算法具有5个特性——有穷性、确定性、可行性、输入和输出。在评价一个算法的优劣时，可以考虑其正确性、可读性、健壮性、时间复杂度和空间复杂度。这里简要介绍了算法的时间复杂度和空间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Appium</title>
      <link href="/2023/08/26/Appium/"/>
      <url>/2023/08/26/Appium/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Appium简介"><a href="#Appium简介" class="headerlink" title="Appium简介"></a>Appium简介</h1>]]></content>
      
      
      <categories>
          
          <category> 测试学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> appium </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架之pytest</title>
      <link href="/2023/08/22/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%B9%8Bpytest/"/>
      <url>/2023/08/22/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%B9%8Bpytest/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><blockquote><p>本文是学习了《Selenium自动化测试完全指南》和其他网络上的教程写出的学习笔记</p></blockquote><h1 id="Pytest简介"><a href="#Pytest简介" class="headerlink" title="Pytest简介"></a>Pytest简介</h1><p>Pytest是目前最成熟、功能最全面的Python测试框架之一。</p><p>简单灵活，容易上手，而且支持参数化与测试编排功能，对其他测试框架（例如Nose、UnitTest等）也能完全兼容。Pytest的第三方插件非常丰富，拥有非常良好的扩展性</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用Pytest编写测试，必需遵守以下基本规则，否则测试无法正常运行</p><ul><li>测试文件的名称以“test_”开头（或以“_test”结尾）</li><li>测试类的名称以Test开头，并且不能带有<code>__init__</code>方法</li><li>测试函数的名称以“test_”开头</li><li>断言使用基本的“assert {表达式}”即可。如果表达式为True，则断言通过；否则，断言失败。</li></ul><p>举例：test_example.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">test_char_in_string</span>(<span class="params">self</span>):</span><br><span class="line">       string = <span class="string">&quot;this&quot;</span></span><br><span class="line">       char = <span class="string">&quot;h&quot;</span></span><br><span class="line">       <span class="keyword">assert</span> char <span class="keyword">in</span> string</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">test_calculation</span>(<span class="params">self</span>):</span><br><span class="line">       result = <span class="number">20</span> + <span class="number">21</span></span><br><span class="line">       <span class="keyword">assert</span> <span class="number">41</span> == result</span><br></pre></td></tr></table></figure><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><ul><li>默认全部执行</li></ul><p>在测试文件目录下打开命令行，输入pytest，即可执行该目录下所有测试文件</p><ul><li>选择指定文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：使用带参数的pytest命令</span></span><br><span class="line">pytest 测试文件名称::测试类名称::测试函数名称</span><br><span class="line"></span><br><span class="line">pytest test_example.py <span class="comment">#运行test_example.py中的所有测试</span></span><br><span class="line">pytest test_epubit_common.py::TestEpubit<span class="comment">#运行test_epubit_common.py里TestEpubit类中的所有测试函数</span></span><br><span class="line">pytest test_example.py::TestClass::test_char_in_string <span class="comment"># 运行test_example.py里TestClass类中test_char_in_string测试函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：在代码中使用pytest.main()执行指定测试</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 相当于pytest test_epubit_common.py命令</span></span><br><span class="line">    pytest.main([<span class="string">&quot;test_epubit_common.py&quot;</span>])</span><br></pre></td></tr></table></figure><ul><li>命令参数</li></ul><table><thead><tr><th>参数</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>-v</td><td>显示每个函数的测试结果</td><td>默认只有模块的结果</td></tr><tr><td>-q</td><td>只显示整体测试结果</td><td></td></tr><tr><td>-s</td><td>显示测试函数的print()输出</td><td>在命令行上</td></tr></tbody></table><h1 id="设定测试函数的先后顺序"><a href="#设定测试函数的先后顺序" class="headerlink" title="设定测试函数的先后顺序"></a>设定测试函数的先后顺序</h1><p>Pytest默认的测试函数执行顺序：</p><p><strong>文件级执行顺序</strong>：在Pytest中，文件级别的执行顺序为先从上到下依次执行同一个文件夹下的.py文件，然后依次执行同一个文件夹下的子文件夹。(正常的文件顺序)</p><p><strong>函数级执行顺序</strong>：从上到下依次执行</p><p><strong>自定义顺序</strong>：pytest-ordering插件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">pip install pytest-ordering</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在各个测试函数前添加以下装饰器，就可以自定义测试的顺序</span></span><br><span class="line"><span class="meta">@pytest.mark.run(<span class="params">order=顺序编号</span>)</span><span class="comment">#从1开始</span></span><br></pre></td></tr></table></figure><p><strong>ps</strong>：如果测试之间存在顺序依赖，通常是规划不合理导致的。这种顺序依赖不仅会导致维护困难，还会导致以后难以修改测试执行方式（例如执行并发测试）。如无特殊需求，请尽量不要设定测试的顺序。</p><h1 id="测试粒度规划"><a href="#测试粒度规划" class="headerlink" title="测试粒度规划"></a>测试粒度规划</h1><p><strong>小粒度的测试</strong>：功能，页面流程中的相续操作都被分散到各个测试函数当中，因此很可能需要考虑测试函数的先后顺序以及前后置操作的影响。</p><p>在小粒度的测试中，一个测试函数只对应一个功能点，看起来非常明确。但并不推荐粒度过小的测试，因为这种粒度的测试结构太过脆弱，比较难维护</p><p><strong>中粒度的测试</strong>：一个类对应一个页面，因此可以考虑类级别的前后置操作</p><p>适用于非常多的场景，尤其适合大型的、专门的、独立的自动化测试项目。这类项目通常会要求较高的页面覆盖比例，对各个页面的功能往往挖掘得比较深入。</p><p><strong>大粒度的测试</strong>：各个测试函数绝对独立，一个测试函数直接对应一个页面，测试函数通常会调用较多的非测试子函数，所以通常无须在类中添加前后置操作。</p><p>适用于应用程序研发流程中的快速回归测试。此时的测试并不要求高比例覆盖每个页面的每个功能点，而是要求快速验证应用程序中的重要业务点是否正确。</p>]]></content>
      
      
      <categories>
          
          <category> 测试学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> pytest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium测试案例讲解</title>
      <link href="/2023/08/22/selenium%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/08/22/selenium%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><blockquote><p>本文是学习了《Selenium自动化测试完全指南》和其他网络上的教程写出的学习笔记</p></blockquote><h1 id="测试的基本要素"><a href="#测试的基本要素" class="headerlink" title="测试的基本要素"></a>测试的基本要素</h1><blockquote><p>测试最基本的两个要素是测试输入和预期输出结果。</p></blockquote><p>案例：<a href="https://www.epubit.com/">异步社区</a>登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">wd = webdriver.Chrome()</span><br><span class="line">wd.get(<span class="string">&quot;https://www.epubit.com/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试输入：登录操作</span></span><br><span class="line">WebDriverWait(wd,<span class="number">5</span>).until(<span class="keyword">lambda</span> p:p.find_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;login&#x27;)]/i[1]&quot;</span>).is_displayed())</span><br><span class="line"></span><br><span class="line">wd.find_element(By.XPATH,<span class="string">&quot;//i[text()=&#x27;登录&#x27;]&quot;</span>).click()</span><br><span class="line">wd.find_element(By.ID,<span class="string">&quot;username&quot;</span>).send_keys(<span class="string">&quot;18732566535&quot;</span>)</span><br><span class="line">wd.find_element(By.ID,<span class="string">&quot;password&quot;</span>).send_keys(<span class="string">&quot;15930571421swSW&quot;</span>)</span><br><span class="line">wd.find_element(By.ID,<span class="string">&quot;passwordLoginBtn&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期输出结果：验证</span></span><br><span class="line">isJumpToHomePage = wd.current_url == <span class="string">&#x27;https://www.epubit.com/&#x27;</span> <span class="comment">#是否跳转回主界面</span></span><br><span class="line">isShowUserImg = wd.find_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;</span>).is_displayed()</span><br><span class="line"><span class="comment"># 主界面是否显示登录用户的头像图片</span></span><br><span class="line">isShowExit = wd.find_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;logout&#x27;)]/div[2]&quot;</span>).is_displayed()</span><br><span class="line"><span class="comment"># 是否有退出按钮</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(isShowExit,isShowUserImg,isJumpToHomePage)</span><br><span class="line">wd.quit()</span><br></pre></td></tr></table></figure><p>我们的预期结果是查看主界面是否有下面这两个元素</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308221233518.png" alt="image-20230822123300619"></p><p>以上代码就算完成了一个基本的登录测试，但并没有使用任何测试框架，为了完善测试的机制，实现更丰富的测试功能，可以引入比较成熟的测试框架。这里将使用pytest框架</p><h1 id="基于Pytest编写Selenium测试"><a href="#基于Pytest编写Selenium测试" class="headerlink" title="基于Pytest编写Selenium测试"></a>基于Pytest编写Selenium测试</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_epubit_common.py文件</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestEpubitCommon</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_epubit_login</span>(<span class="params">self</span>):</span><br><span class="line">        wd = webdriver.Chrome()</span><br><span class="line">        wd.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">        wd.get(<span class="string">&#x27;https://www.epubit.com/&#x27;</span>)</span><br><span class="line">        WebDriverWait(wd, <span class="number">5</span>).until(</span><br><span class="line">            <span class="keyword">lambda</span> p: p.find_element(By.XPATH, <span class="string">&quot;//div[contains(@class,&#x27;login&#x27;)]/i[1]&quot;</span>).is_displayed())</span><br><span class="line"></span><br><span class="line">        wd.find_element(By.XPATH, <span class="string">&quot;//i[text()=&#x27;登录&#x27;]&quot;</span>).click()</span><br><span class="line">        wd.find_element(By.ID, <span class="string">&quot;username&quot;</span>).send_keys(<span class="string">&quot;18732566535&quot;</span>)</span><br><span class="line">        wd.find_element(By.ID, <span class="string">&quot;password&quot;</span>).send_keys(<span class="string">&quot;15930571421swSW&quot;</span>)</span><br><span class="line">        wd.find_element(By.ID, <span class="string">&quot;passwordLoginBtn&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证</span></span><br><span class="line">        isJumpToHomePage = wd.current_url == <span class="string">&#x27;https://www.epubit.com/&#x27;</span></span><br><span class="line">        isShowUserImg = wd.find_element(By.XPATH, <span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;</span>).is_displayed()</span><br><span class="line">        isShowExit = wd.find_element(By.XPATH, <span class="string">&quot;//div[contains(@class,&#x27;logout&#x27;)]/div[2]&quot;</span>).is_displayed()</span><br><span class="line">        <span class="keyword">assert</span> isShowExit <span class="keyword">and</span> isShowUserImg <span class="keyword">and</span> isJumpToHomePage</span><br><span class="line">        wd.quit()</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308221314731.png" alt="image-20230822131402490"></p><p>如果我们需要进行其他测试功能的话，需要在这基础上再添加操作就可以了，但这样会使代码变得冗长，难以维护，并且也没有健壮性，一点小小的改动就要重写，非常不规范。所以有了自动化测试驱动</p><h1 id="自动化测试驱动"><a href="#自动化测试驱动" class="headerlink" title="自动化测试驱动"></a>自动化测试驱动</h1><p>软件自动化测试驱动模式的发展大致经历了4个阶段：线性测试；模块化与库；数据驱动；关键字驱动。</p><h2 id="线性测试阶段"><a href="#线性测试阶段" class="headerlink" title="线性测试阶段"></a>线性测试阶段</h2><blockquote><p>写线性脚本</p></blockquote><p>通过录制回放操作，产生线性脚本。</p><p>在这种模式下，数据和脚本混在一起，几乎一个测试用例对应一个脚本，维护成本很高。即使界面的变化十分简单也需要重新录制，脚本的重复使用率低。</p><h2 id="模块化与库"><a href="#模块化与库" class="headerlink" title="模块化与库"></a>模块化与库</h2><blockquote><p>就是模块化编程思想</p></blockquote><p>将测试分成过程和函数两部分。这种框架要求创建代表测试下的应用程序模块、零件和函数的库文件（SQABasic libraries、API、DLL等），然后让测试用例脚本直接调用这些库文件。通过这样的方式，就产生了可复用的函数或库文件，各个功能可独立维护，并能重复使用。</p><h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><blockquote><p>数据与代码分离</p></blockquote><p>模块化与库很好地解决了用例重用性的问题。但是不难发现，在用例中，测试的操作和测试的数据是放在一起的，一旦需要对大量不同的数据进行测试，就得重新编写大量的用例</p><p>pytest提供了装饰器<code>@pytest.mark.parametrize()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&#x27;参数a,参数b,参数c,...&#x27;</span>,[(<span class="params">第<span class="number">1</span>组参数a的值,参数b的值,参数c的</span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="meta"> 值,...</span>),(<span class="params">第<span class="number">2</span>组参数a的值,参数b的值,参数c的值,...</span>),...]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_测试函数</span>(<span class="params">self, 参数a, 参数b, 参数c,...</span>):</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h2 id="关键字驱动"><a href="#关键字驱动" class="headerlink" title="关键字驱动"></a>关键字驱动</h2><blockquote><p>用关键字理顺代码逻辑</p></blockquote><p>关键字驱动框架是在数据驱动框架的基础上改进的一种框架模型。它将测试逻辑按照关键字进行分解，形成数据文件与关键字对应封装的业务逻辑。关键字主要包括3类，分别是被测试对象（object）、操作（action）和值（value），实现界面元素名与测试内部对象名分离，测试描述与具体实现细节分离。</p><p>举例：登录操作</p><table><thead><tr><th>Page</th><th>Object</th><th>Action</th><th>Value</th></tr></thead><tbody><tr><td>用户登录</td><td>用户名</td><td>输入input</td><td>shenyunmomie</td></tr><tr><td>用户登录</td><td>密码</td><td>输入input</td><td>12345678</td></tr><tr><td>用户登录</td><td>登录</td><td>点击click</td><td></td></tr><tr><td>首页</td><td></td><td>验证Verify</td><td></td></tr></tbody></table><p>Page  Object  Action  Value就是关键字。</p><p>当测试需要在多种不同的环境下运行时，若测试中有一些数据或信息会因为环境的不同而失效，就需要考虑创建配置文件。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul><li>公共信息</li></ul><p>有一些信息属于公共信息，这些信息可能在多个测试中使用，我们可以新建一个名为commonInfo.py的配置文件，将各类公共信息存放到该文件中，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommonInfo</span>:</span><br><span class="line">     biz_home_page_url = <span class="string">&quot;https://www.epubit.com/&quot;</span></span><br><span class="line">     tech_implicitly_wait_seconds = <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>用例数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> commonInfo <span class="keyword">import</span> CommonInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestCaseData</span>:</span><br><span class="line">    test_epubit_login_data = [(CommonInfo.biz_home_page_url, <span class="string">&quot;yibushequUser1&quot;</span>, <span class="string">&quot;yibushequPwd1&quot;</span>)]</span><br><span class="line">    test_book_search_data = [(CommonInfo.biz_home_page_url, <span class="string">&quot;selenium&quot;</span>), (CommonInfo.biz_home_page_url, <span class="string">&quot;python&quot;</span>)]</span><br></pre></td></tr></table></figure><h1 id="测试的前置操作与后置操作"><a href="#测试的前置操作与后置操作" class="headerlink" title="测试的前置操作与后置操作"></a>测试的前置操作与后置操作</h1><p>在Pytest当中，每一个测试开始执行前或结束执行后，都可以设定一些前置或后置性的操作.对于Selenium测试，可以很好地使用Pytest的这项特性，将一些公共性的操作或者设置，放置到这些前置或后置操作中。</p><h2 id="setup与teardown功能详解"><a href="#setup与teardown功能详解" class="headerlink" title="setup与teardown功能详解"></a>setup与teardown功能详解</h2><p>Pytest支持各个级别的前置或后置操作，只要函数命名和位置遵循以下规则，Pytest会自动将其识别为前置函数或后置函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setup_class()/teardown_class()</span><br><span class="line"><span class="comment">#在开始执行测试类中的首个测试函数前执行或在执行完测试类中的全部测试函数后执行</span></span><br><span class="line">setup_method()/teardown_method()</span><br><span class="line"><span class="comment">#在执行测试类中的每个测试函数前/后都会执行</span></span><br><span class="line">setup_module()/teardown_module()</span><br><span class="line"><span class="comment">#在整个.py模块开始运行前/结束运行后执行</span></span><br><span class="line">setup_function()/teardown_function()</span><br><span class="line"><span class="comment">#执行测试类之外的每个测试函数前/后都会执行。</span></span><br></pre></td></tr></table></figure><h2 id="前后置操作实际运用案例"><a href="#前后置操作实际运用案例" class="headerlink" title="前后置操作实际运用案例"></a>前后置操作实际运用案例</h2><p>对于Web应用程序来说，部分页面涉及用户权限。在测试这些页面之前，都需要进行登录等前置操作，同时，在测试结束后，还需要执行一些清理性的后置操作。</p><p>案例：获取登录的个人信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestEpubit</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_class</span>(<span class="params">self,homeurl=<span class="string">&#x27;https://www.epubit.com/&#x27;</span>,username=<span class="string">&#x27;*******6535&#x27;</span>,password=<span class="string">&#x27;***&#x27;</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        测试前置操作：登录</span></span><br><span class="line"><span class="string">        :param homeurl:</span></span><br><span class="line"><span class="string">        :param username:</span></span><br><span class="line"><span class="string">        :param password:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.wd = webdriver.Chrome()</span><br><span class="line">        self.wd.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">        self.wd.get(homeurl)</span><br><span class="line"></span><br><span class="line">        WebDriverWait(self.wd,<span class="number">5</span>).until(<span class="keyword">lambda</span> p: p.find_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;login&#x27;)]/i[1]&quot;</span>).is_displayed())</span><br><span class="line">        self.wd.find_element(By.XPATH, <span class="string">&quot;//i[text()=&#x27;登录&#x27;]&quot;</span>).click()</span><br><span class="line">        self.wd.find_element(By.ID, <span class="string">&quot;username&quot;</span>).send_keys(username)</span><br><span class="line">        self.wd.find_element(By.ID, <span class="string">&quot;password&quot;</span>).send_keys(password)</span><br><span class="line">        self.wd.find_element(By.ID, <span class="string">&quot;passwordLoginBtn&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_class</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        测试后置操作：退出</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.wd.quit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_userinfo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        获取个人信息</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.wd.find_element(By.XPATH, <span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]&quot;</span>).click()    <span class="comment">#点击头像</span></span><br><span class="line">        self.wd.find_element(By.XPATH,<span class="string">&#x27;//a[contains(@href,&quot;/user/myInfo&quot;)]&#x27;</span>).click()    <span class="comment">#点击个人信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 等待页面加载</span></span><br><span class="line">        WebDriverWait(self.wd,<span class="number">5</span>).until(<span class="keyword">lambda</span> p:p.find_element(By.XPATH,<span class="string">&#x27;//span[text()=&quot;用户名：&quot;]/following::span[@class=&quot;content&quot;]&#x27;</span>).is_displayed())</span><br><span class="line">        <span class="comment"># 获取个人信息的三个数据</span></span><br><span class="line">        name = self.wd.find_element(By.XPATH,<span class="string">&#x27;//span[text()=&quot;用户名：&quot;]/following::span[@class=&quot;content&quot;]&#x27;</span>).text</span><br><span class="line">        phoneNum = self.wd.find_element(By.XPATH,<span class="string">&#x27;//span[text()=&quot;手机号：&quot;]/following::span[@class=&quot;content&quot;]&#x27;</span>).text</span><br><span class="line">        mailNum = self.wd.find_element(By.XPATH,<span class="string">&#x27;//span[text()=&quot;电子邮箱：&quot;]/following::span[@class=&quot;content&quot;]&#x27;</span>).text</span><br><span class="line">        <span class="built_in">print</span>(name,phoneNum,mailNum)</span><br><span class="line">        <span class="keyword">assert</span> name==<span class="string">&#x27;cloudCcRaVTQWIxX&#x27;</span> <span class="keyword">and</span> phoneNum[-<span class="number">4</span>:]==<span class="string">&#x27;6535&#x27;</span> <span class="keyword">and</span> mailNum==<span class="string">&#x27;未绑定&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>  <code>@pytest.mark.parametrize(&#39;homeurl,username,password&#39;,[(&#39;https://www.epubit.com/&#39;,&#39;*******6535&#39;,&#39;***&#39;)])</code>不能直接运用再setup_class等方法上。</p><p>因为 <code>setup_class</code> 方法在<strong>测试类加载时</strong>调用，而参数化测试是在测试方法<strong>执行时</strong>进行的。</p><p>在Web应用的测试中，前置和后置函数通常用于执行以下操作。</p><ul><li>实例化&#x2F;注销WebDriver</li><li>设置页面为about:blank，最大化浏览器窗口或关闭浏览器窗口等</li><li>导入&#x2F;清理用户权限</li><li>通过SQL初始化&#x2F;清理对应页面的测试数据。</li></ul><h1 id="优化功能测试的物理组织结构"><a href="#优化功能测试的物理组织结构" class="headerlink" title="优化功能测试的物理组织结构"></a>优化功能测试的物理组织结构</h1><blockquote><p>此处案例取自《Selenium自动化测试完全指南》第14章，建议查阅</p></blockquote><p>仔细研究前面的案例测试，对一个获取个人信息功能写一个测试脚本，这样存在不少的问题：</p><ul><li>元素定位问题：元素定位代码遍布测试代码的各个位置，定位时使用的表达式晦涩难懂，阅读代码时，很难弄清楚它们到底是哪个页面上的哪一个元素，后期维护起来十分困难</li><li>公共元素问题：虽然测试跨多个页面，但其中有一些关键元素可以公用，例如类别筛选下拉列表框。现在并未提取公共元素，如果以后下拉列表框的代码发生改变，就要满世界去寻找相关的代码。最糟糕的是，对于同一个元素，有些地方使用XPath定位，有些地方使用CSS选择器定位，还有些地方使用ID定位，根本看不出来那是同一个元素</li><li>高度耦合问题：测试用例和Selenium WebDriver操作代码、Selenium元素定位代码、Selenium元素操作代码混杂在一起，耦合度极高，代码非常脆弱。</li></ul><p>案例：使用异步社区的图书和文章分类功能，测试用例为“软件开发”“软件工程与方法”“软件测试与质量控制”，验证方式为结果的第一个图书的分类是否对的上。</p><p>按照我们刚学的知识，会通过写两个测试类完成自动化开发，这样就存在以上问题了，所以接下来我们对其结构进行修改。</p><h2 id="解决元素定位问题——页面对象"><a href="#解决元素定位问题——页面对象" class="headerlink" title="解决元素定位问题——页面对象"></a>解决元素定位问题——页面对象</h2><p>在登录测试中，我们验证是否登录成功，采用的是登录的头像图片是否出现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;</span>).is_displayed()</span><br></pre></td></tr></table></figure><p>对于此代码，我们最多能看出这是判断一个图片是否出现，但并没有说明这是登录头像，如果该元素的位置在网页中有改动，就需要在代码翻找此行代码，这在复杂庞大的测试中是很让人头疼的。</p><p>所以就有了一种方法，那就是创建页面对象，将页面的元素都放在一个页面对象中，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># homePage.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,webdriver</span>):</span><br><span class="line">    self.wd = webdriver</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># 用户头像</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">userLogin_img</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.wd.find_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_btn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.wd.find_element(By.XPATH,<span class="string">&quot;//i[text()=&#x27;登录&#x27;]&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#-------------------------</span></span><br><span class="line"><span class="comment"># 在功能测试代码中，我们就能写成</span></span><br><span class="line"><span class="keyword">from</span> homePage <span class="keyword">import</span> HomePage</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestEpubitCommon</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_epubit_login</span>(<span class="params">self</span>):</span><br><span class="line">        wd = webdriver.Chrome()</span><br><span class="line">...</span><br><span class="line">        HomePage(wd).login_btn().click()</span><br><span class="line">        <span class="comment"># wd.find_element(By.XPATH, &quot;//i[text()=&#x27;登录&#x27;]&quot;).click()</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证</span></span><br><span class="line">        ...</span><br><span class="line">isShowUserImg = HomePage(wd).userLogin_img().is_displayed()</span><br><span class="line">        <span class="comment"># isShowUserImg = wd.find_element(By.XPATH, &quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;).is_displayed()</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">assert</span> isShowExit <span class="keyword">and</span> isShowUserImg <span class="keyword">and</span> isJumpToHomePage</span><br><span class="line">        wd.quit()</span><br></pre></td></tr></table></figure><p><code>HomePage(wd).userLogin_img().is_displayed()</code>从这句代码来看，可读性大大提高，HomePage主页中的userLogin_img用户登录图片is_displayed是否显示，一目了然，比刚刚的XPath句法好读多了</p><p>并且如果之后userLogin_img用户登录图片有变动，也无需更改测试逻辑，只要在页面对象homePage中找到该元素的方法，对其进行更改即可，维护也更容易。</p><h2 id="解决公共元素问题——继承"><a href="#解决公共元素问题——继承" class="headerlink" title="解决公共元素问题——继承"></a>解决公共元素问题——继承</h2><blockquote><p>此处用到书中的例子。</p></blockquote><p>首先在异步社区主页中，上边页眉在很多子页面中是复用的，前端代码也是如此，这就算公共元素，所以我们也可以在页面对象中通过继承进行复用。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308240023758.png" alt="image-20230824002346252"></p><p>我们新建一个页眉对象文件，起名为siteHeader.py，那么homePage.py中的HomePage首页对象就可以继承SiteHeader页眉对象，其他的页面，例如图书界面BookPage中也存在公共的页眉，所以BookPage也能继承，这样就实现的代码的复用，维护时只要改变siteHeader.py，更加简洁了。</p><h2 id="解耦测试工具"><a href="#解耦测试工具" class="headerlink" title="解耦测试工具"></a>解耦测试工具</h2><p>上面的优化已经解决了大部分维护问题，代码的健壮性足够。</p><p>但还有一点需要考虑的是，如果测试工具更新，甚至更换测试工具，我们的代码的更改会很困难，例如selenium把click()方法更新为c()，这需要逐行修改使用了click()的代码，如果有100个测试，将会耗费大量精力，所以此节将对测试工具selenium解耦</p><blockquote><p>selenium中有webdriver.Chrome()这种工具级操作，还有find_element()这种元素级操作。</p></blockquote><ul><li><p>工具级操作解耦</p><p>在测试文件中，每个测试函数都存在以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建并设置WebDriver实例</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">driver.get(homeUrl)</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换窗体和创建显式等待的部分代码</span></span><br><span class="line">WebDriverWait(driver, <span class="number">5</span>).until_not(<span class="keyword">lambda</span> d: articleListPage.filter_loadingMask())</span><br><span class="line">driver.switch_to.window(driver.window_handles[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#注销WebDriver实例</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>先创建测试工具操作类，代码文件为BaseLayer&#x2F;executorBase.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorBase</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, executor=<span class="literal">None</span>, url=<span class="literal">None</span></span>):</span><br><span class="line">       <span class="keyword">if</span> executor <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          self.__init_executor()</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          self.driver = executor</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">          self.driver.get(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化测试执行器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_executor</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="comment">#后期可以设置成从config文件读取或从命令行获取</span></span><br><span class="line">       self.driver = webdriver.Chrome()</span><br><span class="line">       self.driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取测试执行器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_executor</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">return</span> self.driver</span><br><span class="line"></span><br><span class="line">    <span class="comment">#注销测试执行器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quit_executor</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">if</span> self.driver <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">          self.driver.quit()</span><br><span class="line">          self.driver = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#生成元素定位</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get_locator</span>(<span class="params">self, key</span>):</span><br><span class="line">       <span class="keyword">if</span> key.lower() == <span class="string">&quot;xpath&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> By.XPATH</span><br><span class="line">       <span class="comment">#...后续可以扩充其他分支定位,例如name/css等</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> By.ID</span><br><span class="line"></span><br><span class="line">    <span class="comment">#查找单个元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_element</span>(<span class="params">self, key, value</span>):</span><br><span class="line">       <span class="keyword">return</span> self.driver.find_element(self.__get_locator(key), value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#查找多个元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_elements</span>(<span class="params">self, key, value</span>):</span><br><span class="line">       <span class="keyword">return</span> self.driver.find_elements(self.__get_locator(key), value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#切换到最新打开的浏览器窗口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">switch_to_last_window</span>(<span class="params">self</span>):</span><br><span class="line">       lastWindowIndex = <span class="built_in">len</span>(self.get_executor().window_handles) - <span class="number">1</span></span><br><span class="line">       self.get_executor().switch_to.window(self.get_executor().window_handles</span><br><span class="line">        [lastWindowIndex])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#等待元素消失</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait_for_element_disappear</span>(<span class="params">self, get_element_func, seconds=<span class="number">5</span></span>):</span><br><span class="line">      WebDriverWait(self.get_executor(), seconds).until_not(<span class="keyword">lambda</span> d: get_element_func())</span><br></pre></td></tr></table></figure><p>所有直接使用测试工具的函数都在ExecutorBase类中进行了封装。接下来只需要页面对象继承此基类，加以修改即可，例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span>(<span class="title class_ inherited__">ExecutorBase</span>):</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 用户头像</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">userLogin_img</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.get_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_btn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_element(By.XPATH,<span class="string">&quot;//i[text()=&#x27;登录&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>页面元素级操作解耦</p><p>上面所说的click()操作就是页面元素级操作，解耦方式比较简单，先在ExecutorBase类中添加几个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutorBase</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="comment">#单击元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_element</span>(<span class="params">self, ele</span>):</span><br><span class="line">       ele.click()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取元素文本</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_element_text</span>(<span class="params">self, ele</span>):</span><br><span class="line">       <span class="keyword">return</span> ele.text</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取元素集合的文本，并返回文本集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_elements_text_list</span>(<span class="params">self, eles</span>):</span><br><span class="line">       text_list = []</span><br><span class="line">       <span class="keyword">for</span> ele <span class="keyword">in</span> eles:</span><br><span class="line">          text_list.append(ele.text)</span><br><span class="line">       <span class="keyword">return</span> text_list</span><br></pre></td></tr></table></figure><p>然后在页面对象中添加对应方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span>(<span class="title class_ inherited__">ExecutorBase</span>):</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 用户头像</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">userLogin_img</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.get_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_userLogin_img</span>(<span class="params">self</span>):</span><br><span class="line">        self.click_element(self.userLogin_img())</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></li></ul><p>这样就完全解耦了，如果不再使用Selenium作为测试工具，或Selenium工具出现大幅的更新，只需修改最底层的BaseLayer&#x2F;executorBase.py文件即可，界面操作代码和测试用例代码完全不受影响。</p><p>如果页面内容或结构发生变化，只需要修改PageObjects文件夹下对应页面的操作代码即可，测试工具代码和测试用例代码完全不受影响。</p><p>如果测试用例发生变化，只需要修改对应测试用例的test_xxx.py代码即可，界面操作的代码和测试用例的代码也完全不受影响。</p><h2 id="流式编程——简化代码"><a href="#流式编程——简化代码" class="headerlink" title="流式编程——简化代码"></a>流式编程——简化代码</h2><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>  testPage.click_headerNavigation_to_bookListPage()\</span><br><span class="line">   .select_filter_category(filter1, filter2, filter3)\</span><br><span class="line">   .click_firstBook_and_switch_bookDetailPage()\</span><br><span class="line">   .get_summary_category_text() == filter3</span><br></pre></td></tr></table></figure><p>具体实现只需要让各个页面对象类和公共区块类的操作代码在操作结束后返回页面对象实例即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomePage</span>(<span class="title class_ inherited__">ExecutorBase</span>):</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 用户头像</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">userLogin_img</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.get_element(By.XPATH,<span class="string">&quot;//div[contains(@class,&#x27;userLogo&#x27;)]/img&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">click_userLogin_img</span>(<span class="params">self</span>):</span><br><span class="line">        self.click_element(self.userLogin_img())</span><br><span class="line">        <span class="comment"># 由于点击之后跳转到其他界面，所以需要导入其他界面对象</span></span><br><span class="line">        <span class="keyword">from</span> PageObjects.***Page <span class="keyword">import</span> ***Page</span><br><span class="line">        <span class="keyword">return</span> ***Page(self.get_executor())</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h1 id="增加运行反馈机制"><a href="#增加运行反馈机制" class="headerlink" title="增加运行反馈机制"></a>增加运行反馈机制</h1><p>通过pytest-html、pytest-xdist、pytest-rerunfailures插件，可以生成测试报告，并行运行测试，以及在运行失败时重新执行测试。</p><h2 id="pytest-html生成测试报告"><a href="#pytest-html生成测试报告" class="headerlink" title="pytest-html生成测试报告"></a>pytest-html生成测试报告</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install pytest-html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令</span></span><br><span class="line">pytest -html=报告文件路径</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并行运行测试"><a href="#并行运行测试" class="headerlink" title="并行运行测试"></a>并行运行测试</h2><p>Pytest默认串行执行测试，对于普通的单元测试，这并无不妥。但对于Selenium测试，由于涉及页面操作，会产生很多网络开销，而且操作会很耗时。当测试较多时，这种串行执行测试的方式就不合时宜了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install pytest-xdist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令</span></span><br><span class="line">Pytest -v -n=<span class="number">4</span></span><br><span class="line"><span class="comment">#-n参数：将测试划分成4个进程</span></span><br><span class="line"><span class="comment">#-v参数：显示每个测试函数的执行结果，方便查看函数是在哪个进程运行</span></span><br></pre></td></tr></table></figure><h2 id="引入重试机制"><a href="#引入重试机制" class="headerlink" title="引入重试机制"></a>引入重试机制</h2><p>出于各种各样原因，测试可能出现小概率运行失败的情况</p><p>例如网络阻塞，导致某个页面无法正常打开，测试就可能失败，但这并不意味着被测试程序真的出现问题了</p><p>为了避免偶发性失败，可以引入重试机制。如果重试多次后依然失败，那就可以断定测试失败可能并非偶然的，而是必然的失败，并开始人工介入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install pytest-rerunfailures</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令</span></span><br><span class="line">pytest --reruns=重试次数</span><br><span class="line"><span class="comment"># 加上--html，可在报告中 查看是否发生了return</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 测试学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> selenium </tag>
            
            <tag> selenium webdriver </tag>
            
            <tag> 案例讲解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试导论</title>
      <link href="/2023/08/21/%E6%B5%8B%E8%AF%95%E5%AF%BC%E8%AE%BA/"/>
      <url>/2023/08/21/%E6%B5%8B%E8%AF%95%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="测试介绍"><a href="#测试介绍" class="headerlink" title="测试介绍"></a>测试介绍</h1><h2 id="什么是测试？"><a href="#什么是测试？" class="headerlink" title="什么是测试？"></a>什么是测试？</h2><p>运行程序，发现bug。</p><p>验证程序的正确性、完整性、安全性和质量的过程</p><h2 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h2><ul><li><p>按开发阶段</p><p>单元、集成、系统、验收</p></li><li><p>按是否接触代码</p><p>黑盒、白盒、灰盒</p></li><li><p>按是否运行</p><p>静态、动态</p></li><li><p>按测试对象</p><p>性能、安全、兼容性、文档、用户体验、业务、界面、安装、内存泄漏</p></li><li><p>按测试实施的组织</p><p>α、β、第三方测试</p></li><li><p>按是否手工</p><p>手工、自动化</p></li><li><p>其他</p><p>冒烟、回归</p></li></ul><h2 id="什么是自动化测试？"><a href="#什么是自动化测试？" class="headerlink" title="什么是自动化测试？"></a>什么是自动化测试？</h2><p>自动化测试是软件测试活动中一个重要分支和组成部分，随着软件行业发展，市场对软件周期及软件质量要求越来越高，催生出来各种开发模式，比如常见开发模式敏捷开发，同时对我们测试人员提更高的要求，此时，产生自动化测试，即通过工具或者脚本来达到测试的目的，没有人工或者很少人工参与的软件测试活动叫自动化测试</p><p>自动化测试就是将测试流程从手工转换为自动化实现形式</p><p>自动化测试技术是目前业内特别流行也是特别主流的一个测试技术，是目前测试人员最为核心的能力之一</p><p>[]<strong>什么是框架？</strong></p><p>框架（framework）是一个框子——指其<strong>约束性</strong>，也是一个架子——指其<strong>支撑性</strong>。是一个基本概念上的结构，用于去解决或者处理复杂的问题。</p><p>在软件工程中，框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；</p><p>另一种定义认为，框架是可被应用开发者定制的应用骨架，前者是从应用方面而后者是从目的方面给出的定义。</p><ul><li><strong>Log：</strong>日志记录和管理功能，针对不同的情况，设置不同的日志级别，方便定位问题；</li><li><strong>Report：</strong>测试报告生成和管理以及即时通知，测试结果快速响应；</li><li><strong>Source：</strong>配置文件、静态资源的管理，遵循高内聚低耦合原则；</li><li><strong>Common：</strong>公共函数、方法以及通用操作的管理，遵循高内聚低耦合原则；</li><li><strong>TestCase：</strong>测试用例管理功能，一个功能点对应一个或者多个case，尽可能的提高覆盖率；</li><li><strong>TestData：</strong>测试数据管理功能，数据与脚本分离，降低维护成本，提高可移植性；</li><li><strong>TestSuite：</strong>测试组件管理功能，针对不同场景不同需求，组装构建不同的测试框架，遵循框架的灵活性和扩展性；</li><li><strong>Statistics：</strong>测试结果统计管理功能，每次执行测试的结果统计、分析、对比以及反馈，数据驱动，为软件优化和流程改进，提供参考；</li><li><strong>Continuous：</strong>持续集成环境，即CI环境，包括测试文件提交、扫描编译、执行测试、生成报告及时通知等功能，<strong>持续集成是自动化测试的核心</strong></li></ul><p>[]<strong>常见的自动化测试框架</strong></p><p><strong>1、接口自动化框架：</strong></p><p>①、java+testNG&#x2F;Junit+Maven&#x2F;Ant&#x2F;Gradle+Jenkins+MySQL+testlink&#x2F;redmine</p><p>②、python+unittest&#x2F;pytest+Git+Jenkins+MySQL+testlink&#x2F;redmine</p><p>③、python+rebot framework+unittest&#x2F;pytest+Git+Jenkins+MySQL+testlink&#x2F;redmine</p><p>④、jmeter+Maven&#x2F;Ant+Jenkins+MySQL+testlink&#x2F;redmine</p><p><strong>2、UI自动化测试框架</strong></p><p>①、java+selenium&#x2F;appium+testNG&#x2F;Junit+Maven&#x2F;Ant&#x2F;Gradle+Jenkins+MySQL+testlink&#x2F;redmine</p><p>②、python+selenium&#x2F;appium+unittest&#x2F;pytest+Git+Jenkins+MySQL+testlink&#x2F;redmine</p><p>③、python+rebot framework+unittest&#x2F;pytest+Git+Jenkins+MySQL+testlink&#x2F;redmine</p><p><strong>编程语言+单元测试框架+扫描编译工具+持续集成工具+数据库+项目管理工具</strong></p><ul><li>编程语言：编写测试脚本、日志记录和输出；</li><li>单元测试框架：提供测试脚本运行、异常校验等一些列的配置；</li><li>扫描编译工具：测试文件扫描编译，一般配合持续集成工具使用效果更佳；</li><li>持续集成工具：Jenkins，经典的持续集成工具；</li><li>数据库：测试数据管理；</li><li>项目管理工具：测试结果统计管理；</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308252218075.png" alt="image-20230825221816771"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308252218493.png" alt="image-20230825221833872"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>selenium_webdriver高级运用</title>
      <link href="/2023/08/20/selenium-webdriver%E9%AB%98%E7%BA%A7%E8%BF%90%E7%94%A8/"/>
      <url>/2023/08/20/selenium-webdriver%E9%AB%98%E7%BA%A7%E8%BF%90%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><blockquote><p>本文是学习了《Selenium自动化测试完全指南》和其他网络上的教程写出的学习笔记</p></blockquote><h1 id="selenium的等待机制"><a href="#selenium的等待机制" class="headerlink" title="selenium的等待机制"></a>selenium的等待机制</h1><blockquote><p>人们在手工测试网站时，总会自然而然地等待网页加载完毕再进行操作。如果某个局部区域是由Ajax加载的内容，人们要等待局部加载完毕才能进行下一步操作，而不是在空白或残缺的界面上操作。另一方面，如果等待超过一定时间，但页面或局部区域依然没有加载完毕，那么人们很可能将其标记为一处程序错误，要求开发人员去排查这个问题。</p></blockquote><p>Selenium拥有丰富的等待机制，将原本人为的等待转换为由机器去等待，并判断什么时候该进行下一步操作</p><h2 id="页面级等待机制"><a href="#页面级等待机制" class="headerlink" title="页面级等待机制"></a>页面级等待机制</h2><blockquote><p>等待页面加载完毕的超时时间，默认为0</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wd.set_page_load_timeout(最长等待秒数)</span><br><span class="line"><span class="comment"># 全局设置，会在整个WebDriver实例的生命周期内生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 未在规定时间内加载完毕，会抛出异常</span></span><br><span class="line">selenium.common.exceptions.TimeoutException: Message: timeout</span><br></pre></td></tr></table></figure><h2 id="元素级等待机制"><a href="#元素级等待机制" class="headerlink" title="元素级等待机制"></a>元素级等待机制</h2><blockquote><p>现代网站大多数是Ajax型网站，很多页面元素都不再是页面加载完毕就能显示出来，而是要触发特定区域的操作，然后等待目标元素出现在页面上才能进行下一步操作。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：强制等待</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 毫无弹性，降低测试效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：隐式等待</span></span><br><span class="line">wd.implicitly_wait(秒)</span><br><span class="line"><span class="comment"># 全局，给find_element...函数增加一个宽限时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：显式等待</span></span><br><span class="line"><span class="comment"># 指定条件判断函数，selenium会每个一定时间检查该条件</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">WebDriverWait(WebDriver实例, 超时秒数, 检测时间间隔[可选], 可忽略异常集合[可选])</span><br><span class="line"><span class="comment"># 检测时间间隔：调用until或until_not传入的条件判断函数的间隔时间，默认为0.5s</span></span><br><span class="line"><span class="comment"># 可忽略异常集合：在调用until或until_not中传入的条件判断函数时，如果抛出的是这个集合中定义的异常，代码就不会执行失败，会继续正常执行。默认在集合中只有NoSuchElementException异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># webdriver执行等待函数</span></span><br><span class="line">wdw.until(条件判断函数, [<span class="string">&quot;超时后的自定义异常消息&quot;</span>])<span class="comment"># 等待直到条件判断函数的返回值不为False（且没有抛出可忽略的异常）。</span></span><br><span class="line">wdw.until_not(条件判断函数, [<span class="string">&quot;超时后的自定义异常消息&quot;</span>]) <span class="comment"># 等待直到条件判断函数的返回值为False（如果抛出可忽略的异常，也会当作False处理），和until恰好相反</span></span><br></pre></td></tr></table></figure><h3 id="Selenium预定义等待条件函数"><a href="#Selenium预定义等待条件函数" class="headerlink" title="Selenium预定义等待条件函数"></a>Selenium预定义等待条件函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"></span><br><span class="line">expected_conditions.visibility_of_element_located(目标元素定位)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">targetLocator = (By.LINK_TEXT,<span class="string">&quot;立即注册&quot;</span>)</span><br><span class="line">wdw.until(expected_conditions.visibility_of_element_located(targetLocator))<span class="comment"># 判断该元素是否已经显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预定义中常见的条件函数</span></span><br><span class="line">visibility_of_element_located(目标元素定位)<span class="comment"># 判断该元素是否已经显示</span></span><br><span class="line">visibility_of(目标元素)<span class="comment"># 判断该元素是否已经显示</span></span><br><span class="line">visibility_of_all_elements_located(目标元素定位)<span class="comment">#判断页面上是否存在一个或多个符合定位的元素，且是否全部显示</span></span><br><span class="line">visibility_of_any_elements_located(目标元素定位)<span class="comment">#至少有一个</span></span><br><span class="line">invisibility_of_element_located(目标元素定位)<span class="comment"># 是否未显示</span></span><br></pre></td></tr></table></figure><h2 id="脚本级等待机制"><a href="#脚本级等待机制" class="headerlink" title="脚本级等待机制"></a>脚本级等待机制</h2><blockquote><p>在Selenium中，可以使用execute_async_script函数来执行异步JavaScript脚本，如果异步JavaScript脚本没有指定回调函数或者超过时间期限仍然没有调用回调函数，那么JavaScript脚本可能超时</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异步超时时间</span></span><br><span class="line">wd.set_script_timeout(秒)</span><br></pre></td></tr></table></figure><h1 id="对键盘和鼠标进行精准模拟"><a href="#对键盘和鼠标进行精准模拟" class="headerlink" title="对键盘和鼠标进行精准模拟"></a>对键盘和鼠标进行精准模拟</h1><h2 id="ActionChains操作链"><a href="#ActionChains操作链" class="headerlink" title="ActionChains操作链"></a>ActionChains操作链</h2><blockquote><p><strong>ActionChains操作链</strong>：一种偏向底层的自动化交互方式，它可以实现鼠标移动、单击、右击、双击、鼠标按下或松开、悬停拖曳、按键按下或松开、按组合键等更复杂的操作。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">ActionChains(webdriver实例)</span><br></pre></td></tr></table></figure><p>操作链中包含两种类型的函数，第一种类型是操作设置函数，第二种类型是操作链执行函数（只有一个perform函数）。在调用perform时，将连续执行之前在操作链中设置的操作，然后结束操作链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(wd).click(webElement).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># .click()并不执行单击操作，而是对操作进行设置，相当于预约，在操作链中预约了一个单击操作</span></span><br><span class="line"><span class="comment"># .perform()：执行操作链中的所有操作（之前预约的click操作此时才会真正执行）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式操作方式，即每个函数都会返回ActionChains实例，以便继续调用ActionChains的操作设置函数，将多个操作组合在一起，形成一个完整的操作链，然后通过perform函数一起执行。</span></span><br><span class="line">ActionChains(wd)\</span><br><span class="line">.click(webElement)\</span><br><span class="line">.click(webElement)\</span><br><span class="line">    .click(webElement)\</span><br><span class="line">    .pause(<span class="number">3</span>)\</span><br><span class="line">    .perform()</span><br><span class="line"></span><br><span class="line">.reset_actions()<span class="comment"># 清空操作链中的所有设置</span></span><br></pre></td></tr></table></figure><p>ps: 操作链中涉及的所有WebElement元素在操作链执行时必须同时存在，且处于可操作状态，否则无法执行操作链</p><h2 id="ActionChains支持的全部鼠标与键盘操作"><a href="#ActionChains支持的全部鼠标与键盘操作" class="headerlink" title="ActionChains支持的全部鼠标与键盘操作"></a>ActionChains支持的全部鼠标与键盘操作</h2><table><thead><tr><th>函数名称</th><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>click</td><td>element(目标元素可选)</td><td>单击，如果没传入目标元素参数，则会单击当前位置</td></tr><tr><td>context_click</td><td>element(目标元素，可选)</td><td>右键单击</td></tr><tr><td>double_click</td><td>element(目标元素，可选)</td><td>双击</td></tr><tr><td>click_and_hold</td><td>element(目标元素，可选)</td><td>单击按住</td></tr><tr><td>release</td><td></td><td>释放</td></tr><tr><td>move_to_element</td><td>element</td><td>移动到目标元素</td></tr></tbody></table><p>键盘操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">baiduSearchInput = driver.find_element(By.ID, <span class="string">&quot;kw&quot;</span>)</span><br><span class="line">baiduSearchInput.send_keys(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">baiduSearchInput.send_keys(Keys.CONTROL, <span class="string">&quot;a&quot;</span>)<span class="comment"># 全选</span></span><br><span class="line">baiduSearchInput.send_keys(Keys.CONTROL, <span class="string">&quot;x&quot;</span>)<span class="comment"># 剪切</span></span><br><span class="line">baiduSearchInput.send_keys(Keys.CONTROL, <span class="string">&quot;v&quot;</span>)<span class="comment"># 粘贴</span></span><br><span class="line">baiduSearchInput.send_keys(Keys.BACKSPACE)<span class="comment"># 退格</span></span><br><span class="line">baiduSearchInput.send_keys(Keys.ENTER)</span><br><span class="line"></span><br><span class="line">ActionChains(wd)\</span><br><span class="line">.key_down(Keys.CONTROL)\</span><br><span class="line">.send_keys(<span class="string">&quot;a&quot;</span>)\</span><br><span class="line">.key_up(Keys.CONTROL)\</span><br><span class="line">    .pause(<span class="number">3</span>)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure><p>ps: send_keys就足以胜任组合键操作，但它只支持按下操作，如果要实现精准控制，例如对某个键需要按下多少秒再松开，则只能使用ActionChains进行模拟，通过key_down、pause、key_up来精准控制某个键需要按下多少秒。</p><h1 id="操作浏览器Cookie"><a href="#操作浏览器Cookie" class="headerlink" title="操作浏览器Cookie"></a>操作浏览器Cookie</h1><blockquote><p>Selenium支持操作浏览器Cookie，包括Cookie的读取、新增和删除。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取</span></span><br><span class="line">wd.get_cookies()  <span class="comment">#获取所有的cookie对象集合</span></span><br><span class="line">wd.get_cookie(cookie名称)   <span class="comment">#根据名称获取单个cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增</span></span><br><span class="line">wd.add_cookie(cookie对象)<span class="comment"># 传入的cookie对象必须包含name和value两个属性</span></span><br><span class="line"><span class="comment"># 还有四个可选属性，分别为path、domain、secure、expiry</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">wd.delete_all_cookies()<span class="comment">#删除全部cookie</span></span><br><span class="line">wd.delete_cookie(cookie名称)<span class="comment">#按名称删除指定cookie</span></span><br></pre></td></tr></table></figure><h1 id="对浏览器窗口或元素截图"><a href="#对浏览器窗口或元素截图" class="headerlink" title="对浏览器窗口或元素截图"></a>对浏览器窗口或元素截图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对浏览器窗口截图</span></span><br><span class="line">wd.save_screenshot(截图文件保存路径)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对元素截图</span></span><br><span class="line">wd.find_element(By.ID,<span class="string">&quot;su&quot;</span>).screenshot(路径)</span><br></pre></td></tr></table></figure><h1 id="为Selenium操作附加自定义事件"><a href="#为Selenium操作附加自定义事件" class="headerlink" title="为Selenium操作附加自定义事件"></a>为Selenium操作附加自定义事件</h1><h2 id="EventFiringWebDriver"><a href="#EventFiringWebDriver" class="headerlink" title="EventFiringWebDriver"></a>EventFiringWebDriver</h2><blockquote><p>EventFiringWebDriver，它可以为各类操作添加事件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.event_firing_webdriver <span class="keyword">import</span> EventFiringWebDriver</span><br><span class="line"></span><br><span class="line">EventFiringWebDriver(WebDriver实例, AbstractEventListener实例)</span><br><span class="line"><span class="comment"># AbstractEventListener是一个抽象类，要使用EventFiringWebDriver，还需要设定自定义事件监听器类，该类必须继承并实现Selenium中的AbstractEventListener类</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 举例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyListener</span>(<span class="title class_ inherited__">AbstractEventListener</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">before_navigate_to</span>(<span class="params">self, url, driver</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;Before navigate to %s&quot;</span> % url)</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">after_navigate_to</span>(<span class="params">self, url, driver</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;After navigate to %s&quot;</span> % url)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="AbstractEventListener"><a href="#AbstractEventListener" class="headerlink" title="AbstractEventListener"></a>AbstractEventListener</h2><table><thead><tr><th>函数</th><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>before_navigate_to(self,url,driver)</td><td>url: 跳转的目标地址</td><td>导航前事件，页面在发生跳转前执行的代码</td></tr><tr><td>after_navigate_to(self,url,driver)</td><td>driver: wd实例</td><td>导航后事件，页面跳转后</td></tr><tr><td>before_navigate_back(self,driver)</td><td>driver: wd实例</td><td>浏览器后退事件，后退操作前执行的代码</td></tr><tr><td>after_navigate_back(self,driver)</td><td>driver: wd实例</td><td>浏览器后退事件，后退操作后执行的代码</td></tr><tr><td>before_navigate_forward(self,driver)</td><td>driver: wd实例</td><td>浏览器前进事件，前进操作前执行的代码</td></tr><tr><td>after_navigate_forward(self,driver)</td><td>driver: wd实例</td><td>浏览器前进事件，前进操作后执行的代码</td></tr><tr><td>before_close(self,driver)</td><td>…</td><td>浏览器关闭事件，关闭前</td></tr><tr><td>after_close(self,driver)</td><td>…</td><td>浏览器关闭事件，关闭后</td></tr><tr><td>before_find(self,by,value,driver)</td><td>by表示查找条件类型</td><td>查找元素前事件</td></tr><tr><td>after_find(self,by,value,driver)</td><td>value表示查找值</td><td>找到元素后事件</td></tr><tr><td>before_click(self,element,driver)</td><td>element表示操作的元素</td><td>单击元素前事件</td></tr><tr><td>after_click(self,element,driver)</td><td>…</td><td>单击元素后事件</td></tr><tr><td>before_change_value_of(self,element,driver)</td><td>…</td><td>元素值变更前事件</td></tr><tr><td>after_change_value_of(self,element,driver)</td><td>…</td><td>元素中变更后事件</td></tr><tr><td>before_excute_script(self,script,driver)</td><td>script表示需要执行的脚本</td><td>脚本执行前事件</td></tr><tr><td>after_excute_script(self,script,driver)</td><td>…</td><td>脚本执行后事件</td></tr></tbody></table><h2 id="EventFiringWebElement"><a href="#EventFiringWebElement" class="headerlink" title="EventFiringWebElement"></a>EventFiringWebElement</h2><p>元素级自定义事件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.event_firing_webdriver <span class="keyword">import</span> EventFiringWebElement</span><br><span class="line"></span><br><span class="line"><span class="comment"># EventFiringWebElement(WebElement实例, EventFiringWebDriver实例)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCustomListener</span>(<span class="title class_ inherited__">AbstractEventListener</span>):</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追踪搜索按钮的操作</span></span><br><span class="line">eventDriver = EventFiringWebDriver(driver, MyCustomListener())</span><br><span class="line">search_btn = EventFiringWebElement(driver.find_element(By.ID, <span class="string">&quot;su&quot;</span>), eventDriver)</span><br><span class="line">search_btn.click()</span><br><span class="line"><span class="comment"># 该元素被操作时触发</span></span><br></pre></td></tr></table></figure><h1 id="浏览器启动参数设置"><a href="#浏览器启动参数设置" class="headerlink" title="浏览器启动参数设置"></a>浏览器启动参数设置</h1><blockquote><p>在创建WebDriver实例时，可以配置它的启动参数以进行一些初始设置。这些设置将会在WebDriver的整个生命周期内生效。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wd = webdriver.Chrome(executable_path=<span class="string">&#x27;chromedriver&#x27;</span>, port=<span class="number">0</span>, options=<span class="literal">None</span>, </span><br><span class="line">service_args=<span class="literal">None</span>, desired_capabilities=<span class="literal">None</span>, service_log_path=<span class="literal">None</span>, chrome_options=</span><br><span class="line"><span class="literal">None</span>, keep_alive=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>options</td><td>启动选项，自定义浏览器选项</td><td>例如启用或禁用浏览器的特定功能，设置浏览器窗口的大小，配置代理服务器等。</td></tr><tr><td>desired_capabilities</td><td>类似于options</td><td>主要在早期版本的Selenium中使用</td></tr><tr><td>chrome_options</td><td>完全等同于options</td><td>该参数是早期版本Selenium使用的参数，现在的版本已不推荐使用</td></tr><tr><td>executable_path</td><td>浏览器驱动程序路径</td><td>chrome.exe，如果没有指定，则默认使用环境变量PATH中设置的路径。</td></tr><tr><td>service_args</td><td>浏览器驱动程序的参数</td><td>可以通过chromedriver –help命令查看驱动程序支持的参数</td></tr><tr><td>port</td><td>驱动程序启用的端口号</td><td>如果不填写，则自动使用任意闲置的端口号。等同–port参数。</td></tr><tr><td>service_log_path</td><td>驱动程序存放日志文件的地址</td><td>完全等同于chromedriver命令中的–log-path参数。</td></tr><tr><td>keep_alive</td><td>是否带上HTTP请求头</td><td>Connection: keep-alive，即是否使用长连接。（该参数为布尔类型，默认值为True）。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器路径</span></span><br><span class="line">customOptions.binary_location=<span class="string">&quot;浏览器.exe路径&quot;</span></span><br><span class="line">customOptions.headless = <span class="literal">True</span><span class="comment">#无界面运行</span></span><br><span class="line">wd = webdriver.Chrome(options=customOptions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向浏览器添加命令行参数</span></span><br><span class="line">customOptions.add_argument(<span class="string">&quot;选项名称=选项值&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">--user-agent=&quot;客户端代理类型&quot;：设置请求头的User-Agent，多用于响应式站点或根据User-Agent判断是否移动设备而返回不同网页的场景。</span></span><br><span class="line"><span class="string">--window-size=宽度值,高度值：设置浏览器的默认窗口大小。</span></span><br><span class="line"><span class="string">--headless：无界面运行（无窗口），通常用于远程运行，在本地也可加上该参数，提升运行效率。</span></span><br><span class="line"><span class="string">--start-maximized：设置浏览器默认以最大化窗口运行。</span></span><br><span class="line"><span class="string">--incognito：设置浏览器以隐身模式（无痕模式）运行。</span></span><br><span class="line"><span class="string">--disable-javascript：禁用JavaScript代码运行。</span></span><br><span class="line"><span class="string">--disable-infobars：禁用浏览器正在被自动化程序控制的提示。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># extension,它可以为浏览器添加扩展插件,Chrome专用设定</span></span><br><span class="line">customOptions.add_extension(<span class="string">&quot;Chrome插件.crx文件路径&quot;</span>)</span><br><span class="line">customOptions.add_encoded_extension(<span class="string">&quot;Chrome插件文件经过Base64编码的字符串&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="通过JavaScript执行器进行深度操作"><a href="#通过JavaScript执行器进行深度操作" class="headerlink" title="通过JavaScript执行器进行深度操作"></a>通过JavaScript执行器进行深度操作</h1><blockquote><p>虽然Selenium支持非常丰富的操作，但还是会遇到极少数无法处理的场景。此时可能需要使用JavaScript执行器来扩展Selenium。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line">webdriver.execute_script(<span class="string">&quot;JavaScript脚本&quot;</span>, 自定义参数集（可选）) <span class="comment">#执行同步脚本</span></span><br><span class="line">webdriver.execute_async_script(<span class="string">&quot;JavaScript脚本&quot;</span>, 自定义参数集（可选）) <span class="comment">#执行异步脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上，将传入的JavaScript脚本以匿名函数的方式在浏览器中执行，以上脚本类似于以下代码。</span></span><br><span class="line">var anonymous = function () &#123;</span><br><span class="line">    Selenium传入的JavaScript脚本...</span><br><span class="line">&#125;;</span><br><span class="line">anonymous();</span><br></pre></td></tr></table></figure><h2 id="执行同步脚本"><a href="#执行同步脚本" class="headerlink" title="执行同步脚本"></a>执行同步脚本</h2><h3 id="返回值与类型转换"><a href="#返回值与类型转换" class="headerlink" title="返回值与类型转换"></a>返回值与类型转换</h3><p>execute_script函数的返回值类型会随JavaScript脚本返回值动态改变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;------返回值为<span class="literal">None</span>的情况------</span><br><span class="line">&gt;脚本没有返回值的情况下，函数返回值为<span class="literal">None</span></span><br><span class="line">&gt;脚本返回值为null的情况下，函数返回值为<span class="literal">None</span></span><br><span class="line">&gt;脚本返回值为undefined的情况下，函数返回值为<span class="literal">None</span></span><br><span class="line">&gt;脚本返回值为NaN的情况下，函数返回值为<span class="literal">None</span></span><br><span class="line">&gt;脚本产生异常的情况下，函数返回值为<span class="literal">None</span></span><br><span class="line">&gt;------返回值为基础类型的情况------</span><br><span class="line">&gt;当脚本返回值为boolean时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;，示例值为<span class="literal">True</span></span><br><span class="line">&gt;当脚本返回值为<span class="built_in">int</span>时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;，示例值为<span class="number">1</span></span><br><span class="line">&gt;当脚本返回值为<span class="built_in">float</span>时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;，示例值为<span class="number">1.1</span></span><br><span class="line">&gt;当脚本返回值为string时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;，示例值为hello world</span><br><span class="line">&gt;------返回值为引用类型的情况------</span><br><span class="line">&gt;当脚本返回值为array时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;，示例值为[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&gt;当脚本返回值为<span class="built_in">object</span>时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;，示例值为&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;cc&#x27;</span>&#125;</span><br><span class="line">&gt;当脚本返回值为function时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;，示例值为&#123;&#125;</span><br><span class="line">&gt;------返回值为HTML元素的情况------</span><br><span class="line">&gt;当脚本返回值为HTML元素时，函数返回值类型为&lt;<span class="keyword">class</span> <span class="string">&#x27;selenium.webdriver.remote.webelement. </span></span><br><span class="line"><span class="string">WebElement&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>ps: 一般来说，不建议通过JavaScript来执行Selenium已经支持的功能。</p><h3 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h3><p>execute_script函数还支持输入参数，然后在JavaScript脚本中通过arguments[0]、arguments[1]等使用这些参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">keyword = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">baiduSearchInput = driver.find_element(By.ID, <span class="string">&quot;kw&quot;</span>)</span><br><span class="line">baiduSearchInput.send_keys(keyword)</span><br><span class="line">driver.find_element(By.ID, <span class="string">&quot;su&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">driver.execute_script(<span class="string">&quot;console.log(&#x27;搜索关键字为&#x27; + arguments[0] + &#x27;，当前百度搜索框的内容</span></span><br><span class="line"><span class="string">为&#x27; + arguments[1].value);&quot;</span>, keyword, baiduSearchInput)</span><br></pre></td></tr></table></figure><h2 id="执行异步脚本"><a href="#执行异步脚本" class="headerlink" title="执行异步脚本"></a>执行异步脚本</h2><p>在使用该函数时，虽然JavaScript是异步处理的，但是Selenium脚本是同步执行的。如果Selenium回调函数没有执行，那么execute_async_script函数会处于阻塞状态，只有Selenium回调函数执行后才会执行下一行代码。</p>]]></content>
      
      
      <categories>
          
          <category> 测试学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> selenium </tag>
            
            <tag> selenium webdriver </tag>
            
            <tag> 高级运用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium_webdriver</title>
      <link href="/2023/08/19/selenium-webdriver/"/>
      <url>/2023/08/19/selenium-webdriver/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="selenium-webdriver简介"><a href="#selenium-webdriver简介" class="headerlink" title="selenium webdriver简介"></a>selenium webdriver简介</h1><blockquote><p>本文是学习了《Selenium自动化测试完全指南》和其他网络上的教程写出的学习笔记</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>WebDriver是一种API和协议，它定义了一种不依赖于编程语言、用于控制Web浏览器行为的接口</p></blockquote><p>Selenium通过WebDriver来支持各种浏览器的自动化。</p><p><em>每种浏览器还需要有一个特定的基于WebDriver的实现来负责控制浏览器，这种实现称为驱动程序。驱动程序通常为可执行文件（.exe），一般由浏览器厂商开发并提供。</em></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看自己的浏览器版本，然后搜索对应浏览器驱动版本进行下载，解压出压缩包内的Chormedriver.exe文件，配置该文件所在目录到环境变量Path(可选).</p><h2 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service</span><br><span class="line"></span><br><span class="line"><span class="comment">#option = webdriver.ChromeOptions()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 WebDriver 对象，指明使用chrome浏览器驱动</span></span><br><span class="line">wd = webdriver.Chrome(service=Service(<span class="string">r&#x27;D:\ChromeDriver\chromedriver.exe&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用WebDriver 对象的get方法 可以让浏览器打开指定网址</span></span><br><span class="line">wd.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>下面都以Chrome浏览器为例</p></blockquote><h1 id="浏览器窗口的基本操作"><a href="#浏览器窗口的基本操作" class="headerlink" title="浏览器窗口的基本操作"></a>浏览器窗口的基本操作</h1><h2 id="浏览器导航操作"><a href="#浏览器导航操作" class="headerlink" title="浏览器导航操作"></a>浏览器导航操作</h2><blockquote><p>打开get、后退back、前进forward、刷新refresh</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wd.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">wd.back()</span><br><span class="line">wd.forward()</span><br><span class="line">wd.refresh()</span><br></pre></td></tr></table></figure><h2 id="浏览器窗口操作"><a href="#浏览器窗口操作" class="headerlink" title="浏览器窗口操作"></a>浏览器窗口操作</h2><blockquote><p>调整浏览器窗口的位置和大小，以及关闭浏览器窗口</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wd.minimize_window()<span class="comment"># 最小化窗口</span></span><br><span class="line">wd.maximize_window()<span class="comment"># 最大化窗口</span></span><br><span class="line">wd.close()<span class="comment"># 关闭窗口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制浏览器窗口的位置与大小</span></span><br><span class="line">wd.set_window_position(坐标X, 坐标Y)<span class="comment"># 将浏览器窗口移动到指定位置</span></span><br><span class="line">wd.set_window_size(宽度像素, 高度像素)<span class="comment"># 将浏览器窗口设置为指定大小</span></span><br><span class="line">wd.set_window_rect(坐标X, 坐标Y, 宽度像素, 高度像素)<span class="comment"># 将浏览器窗口移动到指定位置，同时设置窗口大小</span></span><br></pre></td></tr></table></figure><h2 id="获取浏览器信息"><a href="#获取浏览器信息" class="headerlink" title="获取浏览器信息"></a>获取浏览器信息</h2><blockquote><p>标题和网址、窗口位置和大小</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wd.title<span class="comment">#获取浏览器窗口当前的标题</span></span><br><span class="line">wd.current_url<span class="comment">#获取浏览器窗口当前的网址</span></span><br><span class="line">wd.name<span class="comment">#浏览器名称</span></span><br><span class="line">wd.page_source<span class="comment">#当前页面源码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值是dict类型的对象</span></span><br><span class="line">wd.get_window_position() <span class="comment">#获取位置对象</span></span><br><span class="line">wd.get_window_size() <span class="comment">#获取大小对象</span></span><br><span class="line">wd.get_window_rect() <span class="comment">#获取位置及大小对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查找页面元素"><a href="#查找页面元素" class="headerlink" title="查找页面元素"></a>查找页面元素</h1><h2 id="按id、name、class属性查找"><a href="#按id、name、class属性查找" class="headerlink" title="按id、name、class属性查找"></a>按id、name、class属性查找</h2><blockquote><p>按照HTML元素的id属性查找元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_id(<span class="string">&quot;id属性值&quot;</span>)</span><br><span class="line">find_element(By.ID,<span class="string">&quot;id属性值&quot;</span>)</span><br><span class="line"></span><br><span class="line">wd.find_element_by_name(<span class="string">&quot;name属性值&quot;</span>)</span><br><span class="line">find_element(By.NAME,<span class="string">&quot;name属性值&quot;</span>)</span><br><span class="line"></span><br><span class="line">wd.find_element_by_class(<span class="string">&quot;class属性值&quot;</span>)</span><br><span class="line">find_element(By.CLASS,<span class="string">&quot;class属性值&quot;</span>)</span><br></pre></td></tr></table></figure><p>ps: 一般情况下请尽量使用id或name属性进行查找，因为这两个属性通常用作元素的唯一标识，但class属性可能会被多个元素引用。</p><h2 id="按链接文本查找"><a href="#按链接文本查找" class="headerlink" title="按链接文本查找"></a>按链接文本查找</h2><blockquote><p>按链接的文本查找元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_link_test(<span class="string">&quot;链接的文本&quot;</span>)</span><br><span class="line">find_element(By.LINK_TEST,<span class="string">&quot;链接的文本&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按链接文本进行模糊查找</span></span><br><span class="line">wd.find_element_by_partial_link_text(<span class="string">&quot;链接的一部分文本&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="按标签类型查找"><a href="#按标签类型查找" class="headerlink" title="按标签类型查找"></a>按标签类型查找</h2><blockquote><p>按照HTML标签类型查找元素</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_tag_name(<span class="string">&quot;HTML标签名称&quot;</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_tag_name(<span class="string">&quot;input&quot;</span>) <span class="comment">#查找首个&lt;input/&gt;元素</span></span><br><span class="line">driver.find_element_by_tag_name(<span class="string">&quot;a&quot;</span>)     <span class="comment">#查找首个&lt;a/&gt;元素</span></span><br><span class="line">driver.find_element_by_tag_name(<span class="string">&quot;span&quot;</span>)  <span class="comment">#查找首个&lt;span/&gt;元素</span></span><br></pre></td></tr></table></figure><p>ps: 一个页面中可能会有多个HTML标签相同的元素，除非页面上只有一个该类型的标签，否则可能会查找到其他元素而非目标元素。请尽量使用其他类型的查找方式。</p><h2 id="按XPath查找"><a href="#按XPath查找" class="headerlink" title="按XPath查找"></a>按XPath查找</h2><blockquote><p>XPath是一种综合性的查找方式，不仅支持前几种查找方式，而且还能通过XPath表达式进行更加丰富的高级查找。</p></blockquote><p>XPath的全称为XML路径语言（XML Path Language），使用路径表达式来选取XML文档中的节点或者节点集，类似文件系统</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_xpath(<span class="string">&quot;XPath表达式&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基于绝对路径或相对路径定位"><a href="#基于绝对路径或相对路径定位" class="headerlink" title="基于绝对路径或相对路径定位"></a>基于绝对路径或相对路径定位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路径以斜线（/）开始，那么该路径就表示到一个元素的绝对路径。</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;/html/body/div/div/div/div/div/form/span/input&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相对路径定位以双斜线（//）开头</span></span><br><span class="line"><span class="comment"># 表示选择文档中所有满足双斜线（//）后面的规则的元素（无论层级关系）</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//span/input&quot;</span>)  <span class="comment">#选择所有父元素是span的input元素</span></span><br></pre></td></tr></table></figure><h3 id="基于索引或属性定位"><a href="#基于索引或属性定位" class="headerlink" title="基于索引或属性定位"></a>基于索引或属性定位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引定位非常简单，使用中括号[]并填入索引即可</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//span/input[1]&quot;</span>)  <span class="comment">#选取第1个与表达式//span/input匹配的元素</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//span/input[last()]&quot;</span>)  <span class="comment">#选取最后1个与表达式匹配的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性定位通过前缀@来指定属性名称，然后指定期望的属性值来进行定位</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;kw&#x27;]&quot;</span>)</span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//input[@name=&#x27;wd&#x27;]&quot;</span>)</span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//input[@class=&#x27;s_ipt&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基于轴定位"><a href="#基于轴定位" class="headerlink" title="基于轴定位"></a>基于轴定位</h3><blockquote><p>基于相对关系的定位</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//span[@class=&#x27;soutu-btn&#x27;]/following::input[1]&quot;</span>)  </span><br><span class="line"><span class="comment">#先找到class属性为soutu-btn的span标签，然后通过/following::input[1]找到在它之后的首个input元素</span></span><br><span class="line"></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//a[@id=&#x27;quickdelete&#x27;]/preceding::input[1]&quot;</span>)  </span><br><span class="line"><span class="comment"># 先找到id属性为quickdelete的a标签，然后通过/preceding::input[1]找到在它之前的首个input元素</span></span><br><span class="line"></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//input[@id=&#x27;su&#x27;]/parent::span/parent::form//input[@id</span></span><br><span class="line"><span class="string">=&#x27;kw&#x27;]&quot;</span>)</span><br><span class="line"><span class="comment"># 先找到&quot;百度一下&quot;按钮，然后找到它的父级span元素，再找到它的父级form元素，然后找到form元素内id为wd的input元素</span></span><br></pre></td></tr></table></figure><h3 id="基于函数或表达式定位"><a href="#基于函数或表达式定位" class="headerlink" title="基于函数或表达式定位"></a>基于函数或表达式定位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//a[text()=&#x27;hao123&#x27;]&quot;</span>)  <span class="comment">#查找文本为hao123的a元素</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//a[contains(@href,&#x27;www.hao123.com&#x27;)]&quot;</span>)  <span class="comment">#查找href属性包含www.hao123.com的a元素</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//a[contains(text(),&#x27;ao12&#x27;)]&quot;</span>)<span class="comment">#查找文本包含ao12的a元素</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//a[starts-with(@href,&#x27;https://www.hao&#x27;)]&quot;</span>)  <span class="comment">#查找href属性以https://www.hao开始的a元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过一些逻辑表达式来查找元素，例如and或or</span></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//a[@name=&#x27;errorname&#x27; or text()=&#x27;hao123&#x27;]&quot;</span>)  </span><br><span class="line"><span class="comment"># 查找name属性为errorname或者文本等于hao123的元素，虽然第一个条件无法匹配到元素，但由于两个条件是或的关系，因此第二个条件能顺利定位目标</span></span><br><span class="line"></span><br><span class="line">wd.find_element_by_xpath(<span class="string">&quot;//a[contains(@href,&#x27;hao123&#x27;) and text()=&#x27;hao123&#x27;]&quot;</span>)  </span><br><span class="line"><span class="comment"># 查找href属性包含hao123并且文本等于hao123的元素</span></span><br></pre></td></tr></table></figure><h2 id="按CSS选择器查找"><a href="#按CSS选择器查找" class="headerlink" title="按CSS选择器查找"></a>按CSS选择器查找</h2><blockquote><p>CSS选择器也是一种综合性的查找方式，它不但支持前3种查找方式，而且能通过CSS选择器进行更加丰富的高级查找。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;CSS选择器&quot;</span>)</span><br><span class="line">find_element(By.CSS_SELECTOR,<span class="string">&quot;CSS选择器&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="通过层级关系定位"><a href="#通过层级关系定位" class="headerlink" title="通过层级关系定位"></a>通过层级关系定位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;html &gt; body &gt; div &gt; div &gt; div &gt; div &gt; div &gt; form &gt; span &gt; input&quot;</span>)</span><br><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;span &gt; input&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基于关键属性定位"><a href="#基于关键属性定位" class="headerlink" title="基于关键属性定位"></a>基于关键属性定位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;#kw&quot;</span>)  <span class="comment">#符号&quot;#&quot;代表使用id匹配，即匹配id为kw的元素</span></span><br><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;.s_ipt&quot;</span>)   <span class="comment">#符号&quot;.&quot;代表使用class名称匹配，即匹配class名称为s_ipt的元素</span></span><br><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;[name=wd]&quot;</span>)  <span class="comment">#表达式&quot;[属性名称=属性值]&quot;表示按照属性匹配，这里匹配name属性为wd的元素</span></span><br></pre></td></tr></table></figure><h3 id="基于属性进行模糊定位"><a href="#基于属性进行模糊定位" class="headerlink" title="基于属性进行模糊定位"></a>基于属性进行模糊定位</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;[href^=&#x27;https://www.hao&#x27;]&quot;</span>)  <span class="comment">#查找href属性值以https://www.hao开头的元素</span></span><br><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;[href$=&#x27;123.com&#x27;]&quot;</span>)  <span class="comment">#查找href属性值以123.com结尾的元素</span></span><br><span class="line">wd.find_element_by_css_selector(<span class="string">&quot;[href*=hao123]&quot;</span>)  <span class="comment">#查找href属性值包含hao123的元素</span></span><br></pre></td></tr></table></figure><blockquote><p>相对来说，更推荐使用XPath表达式</p></blockquote><h2 id="通过By对象按动态条件查找"><a href="#通过By对象按动态条件查找" class="headerlink" title="通过By对象按动态条件查找"></a>通过By对象按动态条件查找</h2><p>在之前的查找中，都直接使用对应的查找函数来查找元素，但这样做并不利于代码的维护。在分层较好的测试框架中，查找动作与查找条件互相隔离，查找元素时并不知道是按什么方式查找的，只是依赖于动态传入的条件，因此这种条件并不能完全确定，可能是按id查找，也可能是按其他方式查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">wd.find_element(By.查找条件, <span class="string">&quot;条件值&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="查找元素集合"><a href="#查找元素集合" class="headerlink" title="查找元素集合"></a>查找元素集合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wd.find_elements_...()</span><br><span class="line"><span class="comment"># 把之前的函数以find_element开头，改为以find_elements开头</span></span><br></pre></td></tr></table></figure><h2 id="嵌套查找"><a href="#嵌套查找" class="headerlink" title="嵌套查找"></a>嵌套查找</h2><blockquote><p>已有元素嵌套查找元素，查找在已有元素之下符合条件的子元素</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">baiduSearchForm = wd.find_element(By.ID, <span class="string">&quot;form&quot;</span>)</span><br><span class="line">baiduSearchTextbox = baiduSearchForm.find_element(By.ID, <span class="string">&quot;kw&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="页面元素的基本操作"><a href="#页面元素的基本操作" class="headerlink" title="页面元素的基本操作"></a>页面元素的基本操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单击元素</span></span><br><span class="line">webElement.click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向元素输入内容或上传附件,input</span></span><br><span class="line">webElement.send_keys(<span class="string">&quot;要输入的内容&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空元素的内容</span></span><br><span class="line">webElement.clear()</span><br><span class="line"><span class="comment"># 和send_keys函数类似，clear函数多用于输入框元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交表单元素</span></span><br><span class="line">webElement.submit()</span><br></pre></td></tr></table></figure><h2 id="下拉框元素的选项操作"><a href="#下拉框元素的选项操作" class="headerlink" title="下拉框元素的选项操作"></a>下拉框元素的选项操作</h2><p>之前的操作都用WebElement对象的函数来进行操作，但下拉框使用Select对象的函数，因此需要先将WebElement对象转换成Select对象才能进行下拉框的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">selectWebElement = Select(webElement)</span><br><span class="line"><span class="comment"># 下拉框分为单选下拉框（&lt;Select/&gt;）和多选列表框（&lt;Select multiple= &quot;multiple&quot;/&gt;），但这两种下拉框的操作方式差不多，这里只介绍单选下拉框。</span></span><br><span class="line">selectWebElement.select_by_visible_text(<span class="string">&quot;选项的文本&quot;</span>)  <span class="comment">#按文本选择</span></span><br><span class="line">selectWebElement.select_by_value(<span class="string">&quot;选项的值&quot;</span>)  <span class="comment">#按选项值选择</span></span><br><span class="line">selectWebElement.select_by_index(选项的索引)  <span class="comment">#按选项索引选择，索引从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多选框</span></span><br><span class="line">selectWebElement.deselect_all()  <span class="comment">#取消所有选择</span></span><br><span class="line">selectWebElement.deselect_by_visible_text(<span class="string">&quot;选项的文本&quot;</span>)  <span class="comment">#按文本取消选择</span></span><br><span class="line">selectWebElement.deselect_by_value(<span class="string">&quot;选项的值&quot;</span>)  <span class="comment">#按选项值取消选择</span></span><br><span class="line">selectWebElement.deselect_by_index(选项的索引)  <span class="comment">#按选项索引取消选择，索引从0开始</span></span><br></pre></td></tr></table></figure><h1 id="获取页面元素的内容"><a href="#获取页面元素的内容" class="headerlink" title="获取页面元素的内容"></a>获取页面元素的内容</h1><h2 id="获取元素的基本属性"><a href="#获取元素的基本属性" class="headerlink" title="获取元素的基本属性"></a>获取元素的基本属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">webElement.<span class="built_in">id</span><span class="comment"># 标示</span></span><br><span class="line">webElement.size</span><br><span class="line">webElement.rect<span class="comment">#宽高和坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本值</span></span><br><span class="line">webElement.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签类型</span></span><br><span class="line">webElement.tag_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否选中</span></span><br><span class="line">webElement.is_selected()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否可编辑</span></span><br><span class="line">webElement.is_enabled()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否已显示</span></span><br><span class="line"><span class="comment"># 有时，即使元素已经在页面上看不到了，这个元素也仍然在HTML代码当中，只是没有显示出来。</span></span><br><span class="line">webElement.is_displayed()</span><br></pre></td></tr></table></figure><h2 id="获取元素的HTML属性、DOM属性及CSS属性"><a href="#获取元素的HTML属性、DOM属性及CSS属性" class="headerlink" title="获取元素的HTML属性、DOM属性及CSS属性"></a>获取元素的HTML属性、DOM属性及CSS属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTML属性</span></span><br><span class="line">webElement.get_attribute(<span class="string">&quot;属性名称&quot;</span>)</span><br></pre></td></tr></table></figure><p>当浏览器加载页面时，它会解析HTML并从中生成DOM对象。对于元素节点，大多数标准HTML属性会自动成为DOM对象的属性。DOM对象是一个继承自Object的普通JavaScript对象，这里所说的DOM属性，正是指该JavaScript对象的属性。自定义属性不会映射到DOM属性上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DOM属性</span></span><br><span class="line">webElement.get_property(<span class="string">&quot;属性名称&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CSS属性</span></span><br><span class="line">webElement.value_of_css_property(<span class="string">&quot;CSS属性名称&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="获取元素的位置与大小"><a href="#获取元素的位置与大小" class="headerlink" title="获取元素的位置与大小"></a>获取元素的位置与大小</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webElement.location<span class="comment">#获取位置对象</span></span><br><span class="line">webElement.size <span class="comment">#获取大小对象</span></span><br><span class="line">webElement.rect <span class="comment">#获取位置及大小对象</span></span><br></pre></td></tr></table></figure><h2 id="获取下拉框元素的选项"><a href="#获取下拉框元素的选项" class="headerlink" title="获取下拉框元素的选项"></a>获取下拉框元素的选项</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">SelectWebElement.first_selected_option  <span class="comment">#获取首个已选中项（类型为WebElement）</span></span><br><span class="line">SelectWebElement.all_selected_options  <span class="comment">#获取全部已选中项（类型为WebElement数组）</span></span><br><span class="line">SelectWebElement.options  <span class="comment">#获取下拉框提供的所有选项（无论是否已选中，类型为WebElement数组）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 举例</span></span><br><span class="line">SelectWebElement.first_selected_option.text</span><br></pre></td></tr></table></figure><h1 id="处理浏览器弹出框"><a href="#处理浏览器弹出框" class="headerlink" title="处理浏览器弹出框"></a>处理浏览器弹出框</h1><blockquote><p>在浏览器中，弹出框分为3种——Alert、Confirmation以及Prompt。</p></blockquote><p>Alert：提示框，只有一个“确定”按钮（对应的JavaScript代码为alert(‘这是Alert’);）</p><p>Confirmation：确认框，需要选择（对应的JavaScript代码为confirm(‘这是Confirmation’);）</p><p>Prompt：输入框，需要输入内容（对应的JavaScript代码为prompt(‘这就是prompt’,”);）</p><p><strong>在WebDriver中，以上弹出框统一视为Alert对象，只需调用Alert对象的方法即可。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取Alert对象</span></span><br><span class="line">wd.switch_to.alert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出框的确认与取消</span></span><br><span class="line">Alert.accept()  <span class="comment">#单击&quot;确认&quot;按钮</span></span><br><span class="line">Alert.dismiss()  <span class="comment">#单击&quot;取消&quot;按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本</span></span><br><span class="line">Alert.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向弹出框中输入内容</span></span><br><span class="line">Alert.send_keys(<span class="string">&quot;要输入的内容&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="多网页切换操作"><a href="#多网页切换操作" class="headerlink" title="多网页切换操作"></a>多网页切换操作</h1><p>多浏览器窗口的切换主要依赖于浏览器窗口句柄，只要得到了WebDriver拥有的全部句柄，就可以切换到指定句柄的浏览器窗口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取句柄</span></span><br><span class="line">driver.current_window_handle  <span class="comment">#获得WebDriver当前正在操作的浏览器窗口句柄</span></span><br><span class="line">driver.window_handles  <span class="comment">#获得该WebDriver实例下的全部句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换</span></span><br><span class="line">driver.switch_to.window(窗口句柄)</span><br></pre></td></tr></table></figure><h2 id="IFrame切换"><a href="#IFrame切换" class="headerlink" title="IFrame切换"></a>IFrame切换</h2><p>IFrame在比较早的年代使用较多，但Ajax开始流行后，IFrame的使用场景越来越少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.frame(IFrame元素)  <span class="comment">#切换到当前页面（或IFrame）的下一级指定IFrame中</span></span><br><span class="line">driver.switch_to.parent_frame()  <span class="comment">#切换到当前IFrame的上一级页面（或IFrame）中</span></span><br><span class="line">driver.switch_to.default_content()<span class="comment">#切换会默认的HTML文档</span></span><br></pre></td></tr></table></figure><h1 id="结束WebDriver会话"><a href="#结束WebDriver会话" class="headerlink" title="结束WebDriver会话"></a>结束WebDriver会话</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.close()<span class="comment"># 关闭WebDriver当前所在的窗口</span></span><br><span class="line">driver.quit()<span class="comment"># 关闭所有相关窗口并结束会话</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 测试学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> selenium </tag>
            
            <tag> selenium webdriver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium_IDE</title>
      <link href="/2023/08/18/selenium-IDE/"/>
      <url>/2023/08/18/selenium-IDE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="selenium-IDE简介"><a href="#selenium-IDE简介" class="headerlink" title="selenium IDE简介"></a>selenium IDE简介</h1><blockquote><p>本文是学习了《Selenium自动化测试完全指南》和其他网络上的教程写出的学习笔记</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>selenium IDE实际上是一个浏览器插件，可从浏览器的插件商店下载。</p><p>步骤：打开浏览器–&gt;扩展程序–&gt;获取更多插件–&gt;搜索–&gt;下载</p><p>接下来就能在右上角看到图标了</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308182354557.png" alt="image-20230818235441431"></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>selenium IDE主要功能就是实现浏览器的自动操作，它拥有录制与回放功能，可以理解为鼠标录制的那种。</p><p><em>区别</em>：鼠标录制是跟随时间刻印操作过程，selenium则是记录操作节点，例如对某个元素click，然后type输入，然后将这些记录的操作节点交给浏览器驱动器，由webdriver完成复现。（早期selenium是通过注入js来模拟，自从根据W3C各浏览器厂商都有了webdriver后，此方法selenium RC已在selenium3中被抛弃）</p><p>其他功能硬要说的话，还能拆出验证功能(assert)、导出为python等语言的代码、自己设定操作命令的功能。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>界面操作，使用很简单，可参考《Selenium自动化测试完全指南》或其他网络教程学习</p><h1 id="selenium-IDE命令"><a href="#selenium-IDE命令" class="headerlink" title="selenium IDE命令"></a>selenium IDE命令</h1><blockquote><p>界面操作类、测试验证类、执行等待类、流程控制类、测试辅助类</p></blockquote><p>下文具体命令参考<a href="https://www.selenium.dev/selenium-ide/docs/en/introduction/getting-started">selenium官方文档</a></p><h2 id="界面操作类"><a href="#界面操作类" class="headerlink" title="界面操作类"></a>界面操作类</h2><p>用于对浏览器及各个界面元素进行操作</p><p><em>如果一个命令运行失败或出现错误，则会中断当前测试的执行。</em></p><p>这类命令分为4个子类——浏览器窗口操作、页面元素操作、弹出框操作以及键鼠模拟操作。</p><h2 id="测试验证类"><a href="#测试验证类" class="headerlink" title="测试验证类"></a>测试验证类</h2><p>用于验证应用程序的状态，并检查这些状态是否符合预期结果</p><p>测试验证类命令主要分为assert和verify两个子类。</p><h2 id="执行等待类"><a href="#执行等待类" class="headerlink" title="执行等待类"></a>执行等待类</h2><p>用于等待应用程序的某些元素变为期望状态时再进行下一步操作</p><p>例如“等文本框可编辑时再输入”或“等按钮可见时再单击”。</p><p>执行等待类命令主要分为两个子类——有条件等待和无条件等待。</p><h2 id="流程控制类"><a href="#流程控制类" class="headerlink" title="流程控制类"></a>流程控制类</h2><p>流程控制包含循环控制和分支控制两个子类（也就是经常提到的for、while和if、else），通过这些命令能更好地控制测试流程。</p><h2 id="测试辅助类"><a href="#测试辅助类" class="headerlink" title="测试辅助类"></a>测试辅助类</h2><p>主要分为3个子类——辅助调试、辅助执行和辅助存储，分别用于辅助测试的调试（例如打断点或输出日志），执行自定义JavaScript代码，以及辅助存储测试时需要从界面上保存的临时值或者自定义值。</p><h1 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h1><p>“测试套件”（Test Suite），支持结构化的用例管理。</p><p>可以理解为一个project项目下，新建了两个目录，test1和test2，方便测试执行</p><h1 id="命令行运行"><a href="#命令行运行" class="headerlink" title="命令行运行"></a>命令行运行</h1><p>selenium的.side可以通过命令行运行，但需要安装Selenium命令行运行器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">npm install -g selenium-side-runner</span></span><br></pre></td></tr></table></figure><p>然后就能通过命令方式运行.side文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">selenium-side-runner d:\BaiduSearch.side</span></span><br></pre></td></tr></table></figure><p>当然提供了一些可选参数</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c “browserName&#x3D;浏览器名称’’</td><td>运行在不同的浏览器上</td></tr><tr><td>–base-url 地址</td><td>修改基础URL</td></tr><tr><td>–filter 正则表达式</td><td>选取测试运行</td></tr><tr><td>-w 并行数量</td><td>并行运行测试用例</td></tr><tr><td>–output- directory&#x3D;文件夹路径</td><td>将测试结果导出</td></tr><tr><td>–output-format&#x3D; jest&#x2F;junit</td><td>指定导出格式（如果不指定格式，默认为jest）</td></tr><tr><td>–config-file “YAML文件路径”</td><td>指定配置文件</td></tr></tbody></table><p>配置文件需要创建一个YAML文件，可以通过将配置文件和测试文件放到同一文件夹当中，并将其命名为“.side.yml”来使其生效，也可以通过上面的命令指定。</p>]]></content>
      
      
      <categories>
          
          <category> 测试学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> selenium </tag>
            
            <tag> selenium IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt案例(二)语音测试工具</title>
      <link href="/2023/08/16/Pyqt%E6%A1%88%E4%BE%8B(%E4%BA%8C)%E8%AF%AD%E9%9F%B3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/08/16/Pyqt%E6%A1%88%E4%BE%8B(%E4%BA%8C)%E8%AF%AD%E9%9F%B3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="语音测试工具"><a href="#语音测试工具" class="headerlink" title="语音测试工具"></a>语音测试工具</h1><blockquote><p>代码文件：<a href="https://github.com/shenyunmomie/AudioReceptionTester">我的github</a></p></blockquote><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308122343690.png" alt="photo"></p><ul><li><p>两大测试场景</p><ul><li><p>唤醒测试</p><p>只播放唤醒语音，判断设备是否被唤醒</p></li><li><p>识别测试</p><p>播放唤醒语音和识别语音，判断设备识别内容是否正确</p></li></ul></li><li><p>三个连接方式</p><ul><li><p>adb_wifi</p><p>adb无线连接，通过<code>adb connect IP地址</code>命令实现。</p></li><li><p>adb</p><p>adb有线连接，通过usb接口与设备物理连接</p></li><li><p>serial</p><p>serial串口连接，同样通过usb接口与设备物理连接，与adb区别是设备提供接口协议不同</p></li></ul></li></ul><table><thead><tr><th>输入字段</th><th>唤醒</th><th>识别</th></tr></thead><tbody><tr><td>语料地址(测试语音用例)</td><td>√</td><td>√</td></tr><tr><td>保存地址</td><td>√</td><td>√</td></tr><tr><td>测试数量(非随机)</td><td>√</td><td>√</td></tr><tr><td>设备日志路径</td><td>√</td><td>√</td></tr><tr><td>期望值</td><td>√</td><td></td></tr><tr><td>唤醒正则表达式</td><td>√</td><td>√</td></tr><tr><td>识别正则表达式</td><td></td><td>√</td></tr><tr><td>ip地址&#x2F;串口</td><td>√</td><td>√</td></tr><tr><td>唤醒语料地址</td><td></td><td>√</td></tr></tbody></table><p><strong>保存地址</strong>：测试会生成日志文件、结果表单和统计结果三个文件，保存地址是三个文件的存储路径</p><p><strong>设备日志路径</strong>：测试需要提取设备的日志，所以需要给出设备中的日志路径</p><p><strong>期望值</strong>：无太大作用，仅在唤醒正则表达式判断正确时，做记录使用</p><p><strong>正则表达式</strong>：提取设备日志中的关键词，用以判断唤醒和识别</p><p><strong>唤醒语料地址</strong>：识别测试使用，因为识别前需要先唤醒，最好为一个唤醒语料，控制变量</p><p><strong>输入格式</strong>：加载历史按钮有模板，可以仿照着写</p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 案例 </tag>
            
            <tag> 语音测试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyinstaller打包报错</title>
      <link href="/2023/08/14/pyinstaller%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99/"/>
      <url>/2023/08/14/pyinstaller%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Pyinstaller打包"><a href="#Pyinstaller打包" class="headerlink" title="Pyinstaller打包"></a>Pyinstaller打包</h1><h2 id="打包指令"><a href="#打包指令" class="headerlink" title="打包指令"></a>打包指令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;pyinstaller -D -w xxx.py</span><br></pre></td></tr></table></figure><h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-F</span><br><span class="line">等同于</span><br><span class="line">--onefile</span><br><span class="line"><span class="comment"># 打包为单个文件，如果项目仅为一个.py文件时可用，多个文件不可</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-D</span><br><span class="line">--onedir</span><br><span class="line"><span class="comment"># 打包为一个目录</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--key=keys</span><br><span class="line"><span class="comment"># 使用keys进行加密打包</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-w</span><br><span class="line">--windowed</span><br><span class="line">--noconsole</span><br><span class="line"><span class="comment"># 去掉控制台窗口，执行时不会启动命令行(windows系统)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c</span><br><span class="line">--console</span><br><span class="line"><span class="comment"># 打开控制台窗口，使用控制台子系统执行,当程序启动的时候会打开命令行(默认)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i file.ico</span><br><span class="line">--icon=&lt;file.ico&gt;</span><br><span class="line"><span class="comment"># 程序的图标</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-h</span><br><span class="line">--<span class="built_in">help</span></span><br><span class="line"><span class="comment"># help查看命令</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他(不常用)</span></span><br><span class="line">-v, --version <span class="comment">#版本</span></span><br></pre></td></tr></table></figure><h2 id="打包产生的文件"><a href="#打包产生的文件" class="headerlink" title="打包产生的文件"></a>打包产生的文件</h2><h3 id="打包单文件"><a href="#打包单文件" class="headerlink" title="打包单文件"></a>打包单文件</h3><ul><li><p>exe文件</p><p>生成的可执行文件可以在 dist 文件夹中找到</p><p>包含了你的 Python 代码和所有依赖项，以便你可以在其他计算机上运行它而无需安装 Python 解释器或其他依赖库。</p><p>生成的可执行文件的名称通常与你的 Python 脚本文件的名称相同（默认情况下）</p></li></ul><h3 id="打包多文件"><a href="#打包多文件" class="headerlink" title="打包多文件"></a>打包多文件</h3><ul><li><p>build</p><p>临时文件夹，包含已经编译但尚未打包成最终可执行文件的文件和目录。在打包过程完成后，这个文件夹可以被删除，因为这些临时文件已经不再需要。</p></li><li><p>dist</p><p>最终结果文件夹。其中最重要的文件是exe或应用程序的主文件。此文件夹中的其他文件和目录可能会包含有关打包过程中使用的库、依赖项和资源的信息。</p></li><li><p>.spec</p><p>配置文件，它是一个 Python 脚本文件，用于指定打包过程的参数和选项。</p><p>如果在打包时提供了 .spec 文件，PyInstaller 将使用该文件中指定的配置进行打包，否则将使用默认配置。</p><p><code>pyinstaller yourscript.spec</code></p></li></ul><h1 id="打包环境"><a href="#打包环境" class="headerlink" title="打包环境"></a>打包环境</h1><h2 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h2><p>输入命令后打包报错，百度未能解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\神殒魔灭\AppData\Roaming\Python\Python39\site-packages\PyInstaller\isolated\_parent.py&quot;, line 372, in call</span><br><span class="line">    return isolated.call(function, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\神殒魔灭\AppData\Roaming\Python\Python39\site-packages\PyInstaller\isolated\_parent.py&quot;, line 293, in call</span><br><span class="line">    ok, output = loads(b64decode(self._read_handle.readline()))</span><br><span class="line">EOFError: EOF read where object expected</span><br><span class="line"></span><br><span class="line">OSError: [Errno 22] Invalid argument</span><br></pre></td></tr></table></figure><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><p>打包成功后报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error loading Python DLL</span><br><span class="line">&#x27;D:\AudioReceptionTesterbuild\audioReceptionTester\python39.dl&#x27;.</span><br><span class="line">LoadLibrary:找不到指定的模块。</span><br></pre></td></tr></table></figure><p>这是因为程序是在anaconda环境下写的，系统环境没有下载相应模块，所以有缺失错误。</p><p>除此之外，pyinstaller会将无用的模块也导入进去，所以不推荐此打包方法。</p><h3 id="虚拟环境-anaconda-prompt"><a href="#虚拟环境-anaconda-prompt" class="headerlink" title="虚拟环境(anaconda prompt)"></a>虚拟环境(anaconda prompt)</h3><p>所谓的虚拟环境，就是创建一个没有第三方库和模块的 Python 环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda命令</span></span><br><span class="line">1、导出虚拟环境的列表</span><br><span class="line">conda env list</span><br><span class="line">2、导出当前环境的包</span><br><span class="line">conda list</span><br><span class="line">3、启动/切换至名为name的Python环境</span><br><span class="line">conda activate name</span><br><span class="line">4、退出虚拟环境</span><br><span class="line">conda deactivate</span><br><span class="line">5、创建新的、名为name的、Python版本为3.x的虚拟环境</span><br><span class="line">conda create -n name python==3.x</span><br></pre></td></tr></table></figure><p><strong>步骤：</strong></p><ol><li><p>创建虚拟环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_1 python==<span class="number">3.10</span><span class="number">.8</span></span><br><span class="line"><span class="comment"># 问你新环境是否需要安装这些包，Y确定即可</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果报错</span></span><br><span class="line">Collecting package metadata (current_repodata.json): failed</span><br><span class="line"></span><br><span class="line">UnavailableInvalidChannel: HTTP 404 NOT FOUND for channel simple &lt;https://pypi.mirrors.ustc.edu.cn/simple&gt;</span><br><span class="line"></span><br><span class="line">The channel is not accessible or is invalid.</span><br><span class="line"></span><br><span class="line">You will need to adjust your conda configuration to proceed.</span><br><span class="line">Use `conda config --show channels` to view your configuration&#x27;s current state,</span><br><span class="line">and use `conda config --show-sources` to view config file locations.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索.condarc文件删除即可</span></span><br></pre></td></tr></table></figure></li><li><p>进入虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda activate audiotool</span><br><span class="line"></span><br><span class="line">当(base) D:\AudioReceptionTester&gt;</span><br><span class="line">变成(audiotool) D:\AudioReceptionTester&gt;</span><br><span class="line">表示已经进入</span><br></pre></td></tr></table></figure></li><li><p>安装需要的第三方包</p><p>如果程序还用到了其他的第三方库，那么就需要把这些库给添加进虚拟环境，添加方式就是直接在当前环境下用 pip。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像</span></span><br><span class="line">-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">-i https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">-i https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">-i https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br></pre></td></tr></table></figure></li><li><p>更极致的exe大小</p><p>如果想让其小到不能再小，那么就要尽可能地删去虚拟环境里面的一些用不到的包（用 pip uninstall 来删）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看安装的包</span></span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装第三方包问题"><a href="#安装第三方包问题" class="headerlink" title="安装第三方包问题"></a>安装第三方包问题</h2><ul><li><p>引用与包名不一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：serial包</span></span><br><span class="line"><span class="comment"># 在import时就是serial</span></span><br><span class="line"><span class="comment"># 实际上pip安装的是pyserial包</span></span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line">pip install pyserial</span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:pyinstaller不会因为这个找不到模块(亲历)</span></span><br></pre></td></tr></table></figure></li><li><p>引用奇怪</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：还是serial</span></span><br><span class="line"><span class="comment"># 这次是serial.tools</span></span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line">pip install serial.tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:serial.tools会携带安装pyserial，并且该import也会把pyserial中的内容导入进去，所以只写serial.tools的import也是能够运行的</span></span><br></pre></td></tr></table></figure></li><li><p>安装一个包中附带其他包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：pandas</span></span><br><span class="line"><span class="comment"># pandas安装时候包含了numpy</span></span><br><span class="line"><span class="comment"># 如果卸载numpy，会提醒缺失moudle numpy</span></span><br></pre></td></tr></table></figure></li><li><p>内置模块不用安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：os, time, sys</span></span><br><span class="line"><span class="comment"># 会报错ERROR，找不到这个包</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><p>.spec文件每次打包时最好删掉</p><p>.spec文件是打包的配置文件，打包时会默认按照这个文件内容执行，如果你发现修改报错后，依然报同样的问题，请查看.spec文件是否删除。</p></li></ul><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="ModuleNotFoundError"><a href="#ModuleNotFoundError" class="headerlink" title="ModuleNotFoundError"></a>ModuleNotFoundError</h3><p>解决方法：</p><ul><li>虚拟环境没安装pyinstaller，会调用全局的，所以需要安装</li><li>即使存在pyinstaller，也可以卸载重装，我就是重装就好了，很迷，人都给我整崩溃了。</li></ul><h3 id="RuntimeError-Unable-to-open-x2F-read-ui-device"><a href="#RuntimeError-Unable-to-open-x2F-read-ui-device" class="headerlink" title="RuntimeError: Unable to open&#x2F;read ui device"></a>RuntimeError: Unable to open&#x2F;read ui device</h3><p>ui文件读取错误</p><p>解决方法：</p><ul><li>缺失资源文件，把资源文件根据你的相对路径添加到dist目录下，打包的目录中就可以了</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.taodudu.cc/news/show-5085357.html?action=onClick">用 Pyinstaller 模块将 Python 程序打包成 exe 文件（全网最全面最详细）</a></p><p><a href="https://blog.csdn.net/zhengyuyin/article/details/127800237">【环境问题】Anaconda环境下使用pyinstaller封装exe</a></p><p><a href="https://blog.csdn.net/nainaiwink/article/details/130862534">PyInstaller 中文文档</a></p><p><a href="https://blog.csdn.net/kevinshift/article/details/104880101">使用pyinstaller打包python程序</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记《你是吃出来的》</title>
      <link href="/2023/08/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%BD%A0%E6%98%AF%E5%90%83%E5%87%BA%E6%9D%A5%E7%9A%84%E3%80%8B/"/>
      <url>/2023/08/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%BD%A0%E6%98%AF%E5%90%83%E5%87%BA%E6%9D%A5%E7%9A%84%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="慢病时代——饮食革命带来防治新契机"><a href="#慢病时代——饮食革命带来防治新契机" class="headerlink" title="慢病时代——饮食革命带来防治新契机"></a>慢病时代——饮食革命带来防治新契机</h1><h2 id="我们活在快餐当道的世界，身体却困在了石器时代"><a href="#我们活在快餐当道的世界，身体却困在了石器时代" class="headerlink" title="我们活在快餐当道的世界，身体却困在了石器时代"></a>我们活在快餐当道的世界，身体却困在了石器时代</h2><h3 id="疾病的本质：细胞损伤速度超过修复速度"><a href="#疾病的本质：细胞损伤速度超过修复速度" class="headerlink" title="疾病的本质：细胞损伤速度超过修复速度"></a>疾病的本质：细胞损伤速度超过修复速度</h3><p>不健康的心理或者不合理的饮食、运动、睡眠等生活方式会造成细胞损伤，影响细胞修复。</p><p>很多“慢病”，如冠心病、高血压、糖尿病、肿瘤、抑郁症、气管炎、哮喘、慢性肾病等，都是由不健康的生活方式导致的。</p><p>慢病的治疗方式是对抗治疗，血压高吃降压药，血糖高了用降糖药，肿瘤长出来了切除，哮喘用抗哮喘药。这是无法治愈的，因为慢病的根本原因是长期不健康生活导致的，你更需要改变生活方式，特别是<strong>饮食</strong>，因为在细胞损伤和修复的博弈过程中，能给细胞修复提供原料的只有饮食。</p><blockquote><p>人体细胞的自我修复能力取决于两个主要因素，一个是与生俱来的细胞生命周期，另一个是后天的营养状况，即先天因素和后天因素。先天因素（细胞固有的更新周期）决定了修复速度，后天因素（营养状态）决定了修复质量。</p></blockquote><h3 id="修复细胞损伤的唯一原料：食物中的营养素"><a href="#修复细胞损伤的唯一原料：食物中的营养素" class="headerlink" title="修复细胞损伤的唯一原料：食物中的营养素"></a>修复细胞损伤的唯一原料：食物中的营养素</h3><p>七大营养素:</p><ul><li>碳水化合物（又称为糖类，包括葡萄糖、果糖、麦芽糖、淀粉等）</li><li>蛋白质（分为必需氨基酸和非必需氨基酸）</li><li>脂类（分为脂肪和类脂，脂肪又叫甘油三酯，分为必需脂肪酸和非必需脂肪酸；类脂包括磷脂、胆固醇、胆固醇脂、糖脂）</li><li>维生素（分为脂溶性维生素和水溶性维生素）</li><li>矿物质（分为常量元素和微量元素）</li><li>膳食纤维（分为可溶性膳食纤维和不可溶性膳食纤维）</li><li>水</li></ul><p>人一天营养素消耗：</p><p>一个人如果躺着不动，室温保持在20～25℃，测出来的能量消耗称为基础代谢。一般来讲，男性为1400千卡／天左右，女性在1300千卡／天左右。</p><ul><li>运动方面：运动量大家都不一样，经常运动的人和体力劳动者消耗的碳水化合物要更多一些。</li><li>心理方面：大脑消耗的营养素与肌肉消耗的营养素不一样，用脑越多越需要多补充蛋白质、维生素、矿物质，还有脂类中的胆固醇、磷脂和大家都很关注的DHA和EPA。</li><li><strong>熬夜</strong>：消耗的营养素会更多，如维生素A、维生素B族、磷脂和蛋白质等。</li><li>吸烟：需要更多的抗氧化剂来对抗尼古丁等毒素对人体的伤害。</li><li><strong>喝酒</strong>：伤肝，需要更多的营养素来修复肝脏细胞，如维生素B族和蛋白质。</li></ul><h3 id="藏在饮食中的七大营养素如何修复细胞损伤"><a href="#藏在饮食中的七大营养素如何修复细胞损伤" class="headerlink" title="藏在饮食中的七大营养素如何修复细胞损伤"></a>藏在饮食中的七大营养素如何修复细胞损伤</h3><p>七大营养素为细胞做了什么</p><ul><li>为细胞新陈代谢提供能量——主要靠碳水化合物类，也就是粮食、水果等。</li><li>为新生细胞更新提供结构原料——主要靠蛋白质类和脂类，主要存在于肉、蛋、奶、鱼中。</li><li>为新陈代谢提供媒介——蛋白质类和胆固醇类，还有维生素、矿物质。</li><li>养肠道细菌——食物中的膳食纤维。</li></ul><h2 id="防治慢病吃什么：35-动物类食物-65-植物类食物"><a href="#防治慢病吃什么：35-动物类食物-65-植物类食物" class="headerlink" title="防治慢病吃什么：35%动物类食物+65%植物类食物"></a>防治慢病吃什么：35%动物类食物+65%植物类食物</h2><p>讲述了历史时代中，人们不同的饮食习惯和生活方式比较平衡，但从工业时代开始，人工食物出现，慢病流行。这是因为人们获得食物更容易，人的体力劳动量大大降低，摄入和消耗极大不平衡。更加重要的是，化肥、催熟剂等种植方式，几乎所有食物中的营养素都在贬值。还出现了过去不存在的食物，食品安全成为重要问题。</p><p>从数万年前茹毛饮血的旧石器时代到现在，我们的基因结构和消化系统基本上没有改变，然而我们的饮食结构却有翻天覆地的变化，特别是在最近100年间。正是由于旧基因和新饮食的矛盾，造成了今天慢病的蔓延流行。</p><h3 id="缔造最强大脑和体能的完美饮食"><a href="#缔造最强大脑和体能的完美饮食" class="headerlink" title="缔造最强大脑和体能的完美饮食"></a>缔造最强大脑和体能的完美饮食</h3><p>人类进化得最快的时期，大概在距今2万～1万年前是旧石器时代向新石器时代转化。那时人们食物结构，植物性食物占65%，主要是水果、蔬菜、坚果、豆类和蜂蜜。动物性食物占35%左右，主要是肉类、蛋类、鱼和虾贝类。</p><p>总结：</p><p>第一，我们必须意识到在餐桌食品丰富的背后，我们获得的营养其实十分匮乏，食物种类太少与营养素的含量太低并存。如果我们再挑食，或者总用精米、精面把自己喂饱，就更容易出现营养不平衡。</p><p>第二，尽量摄入天然食物，动物类、植物类食物每天都要吃，注意减少加工食品摄入量。</p><p>第三，动物类食物（肉、蛋、奶、鱼等）最好占一天食物的35%。当然如果能买到散养的畜禽类动物或者禽卵更好。植物类食物包括蔬菜、水果和粮食，占一天食物的65%。蔬菜和水果种类尽量多样化，粮食类食物种类要多，以粗粮为主，如全麦类、糙米、玉米、莜麦、薯类都很好，最不好的是精米、精面，因为精米、精面是工业化的产物。</p><h2 id="防治慢病怎么吃：注重结构型营养素和营养密度"><a href="#防治慢病怎么吃：注重结构型营养素和营养密度" class="headerlink" title="防治慢病怎么吃：注重结构型营养素和营养密度"></a>防治慢病怎么吃：注重结构型营养素和营养密度</h2><blockquote><p>食物种类多不等于营养丰富</p></blockquote><p>结构物质主要指磷脂、蛋白质、胆固醇。如果这些结构性营养缺失了，细胞无法按照DNA的指令完成增生和修复，身体发育就会受到限制。</p><h3 id="结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养"><a href="#结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养" class="headerlink" title="结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养"></a>结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养</h3><p>碳水化合物能转化成脂肪，脂肪也能转化成碳水化合物。蛋白质可以转化成碳水化合物。</p><p>但不是所有的蛋白质都能由碳水化合物和脂肪直接转化而来。蛋白质是由氨基酸构成的，而碳水化合物和脂肪在体内只能转化为非必需氨基酸，必需氨基酸是必须要从外界摄取的。</p><h3 id="能量原料不足，结构原料受损"><a href="#能量原料不足，结构原料受损" class="headerlink" title="能量原料不足，结构原料受损"></a>能量原料不足，结构原料受损</h3><p>营养素在细胞中的吸收和释放都是需要排队的。</p><p>碳水化合物冲在最前面，进入细胞的线粒体，直接变为能量。蛋白质和脂肪变成细胞膜的结构或者成为某些有生物活性的物质，如酶。</p><p>人饿的时候，碳水化合物先被用光，之后才是皮下脂肪和蛋白质。</p><p>人在饥饿时，以脂肪分解为主，占80%左右，蛋白质的分解约占20%</p><h3 id="最适合现代人的食物：低能量密度，高营养密度"><a href="#最适合现代人的食物：低能量密度，高营养密度" class="headerlink" title="最适合现代人的食物：低能量密度，高营养密度"></a>最适合现代人的食物：低能量密度，高营养密度</h3><p>对运动量不大的现代人来说，最好的食物选择是：低能量密度，高营养密度。如果是体力劳动者，那就要高能量密度，高营养密度。</p><p>能量密度，指的是单位体积中所含的提供给细胞的能量营养素有多少。</p><p>营养密度，指的是单位体积中所含的营养素有多少。</p><p>最符合低能量、高营养这一标准的膳食结构，就是<strong>地中海膳食结构</strong>。</p><h1 id="不生病的奥秘——七大营养素平衡"><a href="#不生病的奥秘——七大营养素平衡" class="headerlink" title="不生病的奥秘——七大营养素平衡"></a>不生病的奥秘——七大营养素平衡</h1><h2 id="能量平衡：比例合理更重要"><a href="#能量平衡：比例合理更重要" class="headerlink" title="能量平衡：比例合理更重要"></a>能量平衡：比例合理更重要</h2><p>一个人每天的能量消耗主要有以下三个方面：基础代谢、运动和食物消化。</p><ul><li>基础代谢</li></ul><p>基础代谢率就是尽量排除其他影响因素，在非常安静的环境中，在清醒的状态下，一个人的身体不受精神紧张、肌肉活动和环境温度等影响测定的代谢率。</p><p>日常生活中，基础代谢很容易受到其他因素的影响，常见的包括环境温度、激素、年龄、性别、身高和遗传等。</p><p>环境温度在20～25℃时，人的基础代谢率最低；低温和高温环境中，代谢率都会升高。现在大家长期生活在恒温房间里，能量消耗少，很容易发胖。</p><ul><li>运动</li></ul><p>整天用电脑、不出去运动的人消耗的能量要比下地的农民低很多。即便是每天出去运动，运动项目和持续时间不同，消耗的能量也会有所不同。</p><ul><li>食物消化</li></ul><p>消化食物的过程也要消耗能量，这被称作食物的动力效应。</p><p>不同营养素的动力效应是不同的。蛋白质的动力效应最大，约为30%；而碳水化合物和脂肪的动力效应较低，基本在5%左右。</p><p>例如，如果你吃进去的蛋白质热量是100千卡，消化分解自身用掉30%，实际上吸收到机体中的是70千卡。而100千卡的碳水化合物进入人体后，消化分解自身只用掉5%，吸收到身体中的是95千卡左右，脂肪也是同量。</p><blockquote><p>能量摄入的四个来源: </p></blockquote><p>在七大营养素中，有三大营养素和能量息息相关，它们分别是碳水化合物、蛋白质和脂类，被称为“产能营养素”。</p><p><strong>碳水化合物每克产生4千卡能量，蛋白质每克产生4千卡能量，脂类每克产生9千卡能量。</strong></p><p><strong>酒精，1克酒精产生7千卡能量</strong></p><blockquote><p>容易被忽视的能量失衡表现：体重正常而体脂偏高</p></blockquote><p>缺乏蛋白质，所以肌肉无力，消化能力差，睡眠不好。缺乏必需脂肪酸，所以皮肤干燥，视力很差，记忆力减退。</p><p>注意给大脑补足营养，才能有效地治疗消化不良和预防老年痴呆。</p><h3 id="能量平衡的方法因人而异"><a href="#能量平衡的方法因人而异" class="headerlink" title="能量平衡的方法因人而异"></a>能量平衡的方法因人而异</h3><p>摄入多少是根据消耗量来计算的，主要参数有以下三个：</p><p>第一，身高体重。依据标准体重计算，标准体重&#x3D;身高（厘米）－105，不管男性还是女性基本都是这样计算。</p><p>第二，活动量。一般来讲轻体力劳动是标准体重每千克耗能30千卡，中体力劳动者35千卡，重体力劳动者40千卡，长期卧床的人标准体重每千克耗能25千卡。临床上我们也不是这么绝对，比如一个轻体力劳动者，偏胖，计算能量的时候减少5千卡，为标准体重每千克耗能25千卡。</p><p>第三，三大能量之间的比例。大多数营养书上三大能量比例是蛋白质为10%～15%，脂类为20%～30%，碳水化合物为55%～65%。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 你是吃出来的 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之函数参数</title>
      <link href="/2023/08/03/python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
      <url>/2023/08/03/python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h1><p>形式参数：在定义函数时，函数名后面括号中的参数为“形式参数”。</p><p>实际参数：在调用一个函数时，函数名后面括号中的参数为“实际参数”，也就是将函数的调用者提供给函数的参数称为实际参数。</p><blockquote><p>实际参数的类型不同，传递参数可分为两种情况，值传递和引用传递。</p></blockquote><p>值传递：当实际参数为不可变对象时，改变形参的值，实际参数不变</p><p>引用传递：当实际参数为可变对象时，改变形参的值，实际参数改变</p><h2 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h2><p><img src="D:/blog/source/_posts/assets/Image%20%5B6%5D.png" alt="Image [6]"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原值：&quot;</span>,obj)</span><br><span class="line">    obj+=obj</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------值传递------&quot;</span>)</span><br><span class="line">mot = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用前：&quot;</span>,mot)<span class="comment"># hello world!</span></span><br><span class="line">demo(mot)<span class="comment"># 不可变对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用后：&quot;</span>,mot)<span class="comment"># hello world!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------引用传递------&quot;</span>)</span><br><span class="line">lst = [<span class="string">&#x27;你好&#x27;</span>, <span class="string">&#x27;世界&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用前：&quot;</span>,lst)<span class="comment"># [&#x27;你好&#x27;, &#x27;世界&#x27;]</span></span><br><span class="line">demo(lst)<span class="comment"># 可变对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用后：&quot;</span>,lst) <span class="comment"># [&#x27;你好&#x27;, &#x27;世界&#x27;, &#x27;你好&#x27;, &#x27;世界&#x27;]</span></span><br></pre></td></tr></table></figure><h1 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h1><p>位置参数也称必备参数，是必须按照正确的顺序传到函数中，即调用时的数量和位置必须和定义时是一样的。</p><p>TypeError异常</p><ul><li><p>实际参数的类型与形式参数的类型不一致</p></li><li><ul><li>实参数量不一致</li><li>类型位置与定义不一致</li></ul></li></ul><h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>关键字参数是指使用形式参数的名字来确定输入的参数值，位置不必完全一种</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 函数操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之字符串</title>
      <link href="/2023/08/03/python%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/08/03/python%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>lower()</td><td>全部转换为小写</td><td>仅限于A-Z</td></tr><tr><td>upper()</td><td>全部转换为大写</td><td>仅限于A-Z</td></tr><tr><td>title()</td><td>每个单词的第一个字母大写</td><td></td></tr><tr><td>capitalize()</td><td>字符串的第一个字母大写</td><td></td></tr><tr><td>swapcase()</td><td>大写小写颠倒</td><td></td></tr><tr><td>casefold()</td><td>全部转换为小写</td><td>更广泛的字符转换</td></tr></tbody></table><h2 id="检查字符"><a href="#检查字符" class="headerlink" title="检查字符"></a>检查字符</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>islower()</td><td>检查字母字符是否都是小写</td><td></td></tr><tr><td>isupper()</td><td>检查字母字符是否都是大写</td><td></td></tr><tr><td>istitle()</td><td>检查首字母是否大写</td><td></td></tr><tr><td>isdigit()</td><td>检查字符串中是否全为数字</td><td></td></tr><tr><td>isalpha()</td><td>检查字符串中是否全为字母</td><td></td></tr><tr><td>isspace()</td><td>检查字符串中是否有空格</td><td></td></tr><tr><td>isalnum()</td><td>检查字符串是否由字母和数字组成</td><td>单字母数字都可以，空字符串不行</td></tr><tr><td>isdecimal()</td><td>检查字符串是否只包含十进制字符</td><td></td></tr><tr><td>inumeric()</td><td>检查字符串是否全为数字</td><td>只适用于Unicode对象，可以判断中文数字</td></tr><tr><td>isprintable()</td><td>检查字符串中是否有打印后不可见的内容</td><td>如\n、\t</td></tr></tbody></table><h2 id="判断字符"><a href="#判断字符" class="headerlink" title="判断字符"></a>判断字符</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>startswith()</td><td>判断字符串是否以指定前缀开始</td><td>有start、end参数可在指定范围判断</td></tr><tr><td>endswith()</td><td>判断字符串是否以指定后缀结尾</td><td>有start、end参数可在指定范围判断</td></tr><tr><td>isidentifier()</td><td>判断str是否是有效的标识符</td><td></td></tr></tbody></table><h2 id="查询字符"><a href="#查询字符" class="headerlink" title="查询字符"></a>查询字符</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>count()</td><td>查询子字符串出现次数</td><td></td></tr><tr><td>find()</td><td>查询子字符串第一次出现位置，返回索引</td><td>不存在返回-1</td></tr><tr><td>rfind()</td><td>查询子字符串最后一次出现位置，返回索引</td><td>不存在返回-1</td></tr><tr><td>index()</td><td>查询子字符串第一次出现位置，返回索引</td><td>不存在引发异常</td></tr><tr><td>rindex()</td><td>查询子字符串最后一次出现位置，返回索引</td><td>不存在引发异常</td></tr></tbody></table><h2 id="格式变换"><a href="#格式变换" class="headerlink" title="格式变换"></a>格式变换</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>join()</td><td>以字符串为间隔，将可迭代对象中的元素连接</td><td></td></tr><tr><td>split()</td><td>以指定字符串为分隔符，拆分成列表</td><td></td></tr><tr><td>splitlines()</td><td>将字符串按照行(\n、\r)拆分成列表</td><td></td></tr><tr><td>partition()</td><td>指定分隔符(sep)将字符串进行分割</td><td>从左边开始</td></tr><tr><td>rpartition()</td><td>指定分隔符(sep)将字符串进行分割</td><td>从右边开始</td></tr></tbody></table><h2 id="修改替换"><a href="#修改替换" class="headerlink" title="修改替换"></a>修改替换</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>replace()</td><td>指定字符串，用另一个字符串替代</td><td>默认替换全部，也可用count参数指定次数</td></tr><tr><td>expandtabs()</td><td>将字符串中的 \t 替换为一定数量的空格</td><td></td></tr></tbody></table><h2 id="填充修减"><a href="#填充修减" class="headerlink" title="填充修减"></a>填充修减</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>strip()</td><td>去除字符串开头和结尾处指定的字符</td><td>默认为空格</td></tr><tr><td>lstirp()</td><td>去除字符串左边的空格或指定字符</td><td>默认为空格</td></tr><tr><td>rstirp()</td><td>去除字符串末尾的指定字符</td><td>默认为空格</td></tr><tr><td>center()</td><td>返回一个长度为width,两边用fillchar(单字符)填充的字符串，即字符串str居中，两边用fillchar填充。</td><td>若字符串的长度大于width,则直接返回字符串str。</td></tr><tr><td>ljust()</td><td>返回一个原字符串左对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串</td><td>若，直接返回字符串str。</td></tr><tr><td>rjust()</td><td>返回一个原字符串右对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串</td><td>若，直接返回字符串str。</td></tr><tr><td>zfill()</td><td>返回指定长度的字符串，使原字符串右对齐，前面用0填充到指定字符串长度</td><td>若，直接返回字符串str。指定长度不能为空</td></tr></tbody></table><h2 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>encode()</td><td>指定的编码格式编码字符串，默认编码为 ‘utf-8’</td><td></td></tr><tr><td>decode()</td><td>以 encoding 指定的编码格式解码字符串，默认编码为字符串编码。</td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#str.encode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;)</span></span><br><span class="line"><span class="string">&quot;我爱祖国&quot;</span>.encode(encoding=<span class="string">&quot;utf8&quot;</span>,errors=<span class="string">&quot;strict&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xe6\x88\x91\xe7\x88\xb1\xe7\xa5\x96\xe5\x9b\xbd&#x27;</span></span><br><span class="line"><span class="string">&quot;I love my country&quot;</span>.encode(encoding=<span class="string">&quot;utf8&quot;</span>,errors=<span class="string">&quot;strict&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;I love my country&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#str.decode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;)</span></span><br><span class="line">str1 = <span class="string">&quot;我爱学习&quot;</span>.encode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xe6\x88\x91\xe7\x88\xb1\xe5\xad\xa6\xe4\xb9\xa0&#x27;</span></span><br><span class="line">str1.decode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="string">&#x27;我爱学习&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>format()</td><td>在字符串中使用{}作为占位符，占位符的内容将引用format()中的参数进行替换</td><td></td></tr><tr><td>format_map()</td><td>返回字符串的格式化版本</td><td>仅使用于字符串格式中可变数据参数来源于字典等映射关系数据</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;john&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">33</span>&#125;</span><br><span class="line"><span class="string">&quot;My name is &#123;name&#125;,iam&#123;age&#125; old&quot;</span>.format_map(People)</span><br></pre></td></tr></table></figure><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>maketrans()</td><td>制作翻译表，删除表</td><td></td></tr><tr><td>translate()</td><td>过滤(删除)，翻译字符串</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之魔术方法</title>
      <link href="/2023/07/29/Python%E4%B9%8B%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/29/Python%E4%B9%8B%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="什么是魔术方法"><a href="#什么是魔术方法" class="headerlink" title="什么是魔术方法"></a>什么是魔术方法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>魔术方法，官方名称是special methods，因为带有双下划线，又被称为dunder methods双下划线方法。</p></blockquote><p>当我们创建一个自定义类时，往往需要控制这个类的行为和操作。通过定义和实现这些魔术方法，我们可以在自定义类中实现类似于内置类型的行为和功能，使得我们的类更加灵活和易于使用。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>__init__</code>用于在创建对象时进行初始化操作。它在对象创建之后立即被调用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">person1 = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(person1.name)  <span class="comment"># 输出：Alice</span></span><br><span class="line"><span class="built_in">print</span>(person1.age)  <span class="comment"># 输出：25</span></span><br></pre></td></tr></table></figure><p><code>__init__</code>方法的第一个参数通常被命名为self，它代表正在被创建的对象自身。接下来的参数表示我们在创建对象时传递的参数。通过这些传递的参数，我们可以在初始化方法中对对象的属性进行赋值。</p><h1 id="魔术方法类别"><a href="#魔术方法类别" class="headerlink" title="魔术方法类别"></a>魔术方法类别</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th>符号</th><th>方法</th><th>tips</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td><code>__eq__</code></td><td>equal，无定义时，默认使用is逻辑。</td></tr><tr><td>!&#x3D;</td><td><code>__ne__</code></td><td>not equal，无定义时，把eq函数取反</td></tr><tr><td>&gt;</td><td><code>__gt__</code></td><td>greater than，无定义时，取反、报错</td></tr><tr><td>&lt;</td><td><code>__lt__</code></td><td>less than，无定义时，取反、报错</td></tr><tr><td>&gt;&#x3D;</td><td><code>__ge__</code></td><td>greater equal，无定义时，取反、报错</td></tr><tr><td>&lt;&#x3D;</td><td><code>__le__</code></td><td>less equal，无定义时，取反、报错</td></tr></tbody></table><ol><li><p>取反，当&#x3D;&#x3D;方法被定义，而!&#x3D;方法没有定义时，调用!&#x3D;方法，会使用&#x3D;&#x3D;方法，并将结果取反。其他同理。</p></li><li><p>一般情况下，当符号是&lt;时，调用<code>__lt__</code>方法，但也有例外，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, year, month, date</span>):</span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> self.year &lt; other.year:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.year == other.year:</span><br><span class="line">            <span class="keyword">if</span> self.month &lt; other.month:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> self.month == other.month:</span><br><span class="line">                <span class="keyword">return</span> self.day &lt; other.day</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewDate</span>(<span class="title class_ inherited__">Date</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">date1 = Date(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">date2 = NewDate(<span class="number">2023</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(date1 &lt; date2)</span><br><span class="line"><span class="comment"># 正常情况下，date1.__lt__(date2),调用lt函数，但这里的date2是子类，因为有可能被重写，所以实际上调用的是date2.__gt__(date1)</span></span><br><span class="line"><span class="comment"># 这里的规则是，两边是不同类且是衍生类关系，首先使用衍生类的方法。两边是不同类且无衍生关系的时候，我们首先使用左边类的方法，如果左边没有lt方法，则将date1 &lt; date2，视为date2 &gt; date1，调用date2的gt方法，如果这两者都没有，就会报错，python认为两边没有定义date1 &lt; date2的比较逻辑，不可比较。</span></span><br></pre></td></tr></table></figure></li><li><p>&lt;&#x3D;方法不等于&lt;和&#x3D;&#x3D;方法，即使写了后两者，没写前者也用不了&lt;&#x3D;方法。</p></li><li><p>hash值，当我们自定义一个数据结构时，是有默认的<code>__hash__</code>方法的，如果我们定义了<code>__eq__</code>函数，那么默认的hash方法会被删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解释一下hash函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先hash函数有关于可变对象和不可变对象</span></span><br><span class="line"><span class="comment"># 如果一个对象是不可变的，那么它的__hash__()方法应该返回一个固定的哈希值，并且__eq__()方法应该比较对象的内容来判断相等性。</span></span><br><span class="line"><span class="comment"># 如果一个对象是可变的，那么它的__hash__()方法通常不会被实现（默认返回None），并且对象的相等性比较通常会比较对象的身份（即id()）而不是内容。</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="comment"># int类型是不可变对象，所以a is b结果为true，这里不要认为a、b是两个不同的对象，因为在编程中，a和b都是引用，指向同一块内存。hash值用来标识唯一数据对象，a和b都是同一块内存，输入相同，输出的hash值也一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的数据对象例如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>():</span><br><span class="line">    ...</span><br><span class="line">date1 = Date(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">date2 = Date(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># date1 is date2的时候就会返回False，因为两个变量指向的是两块不同的内存。得出的hash值也不同。</span></span><br><span class="line"><span class="comment"># 当定义了__eq__方法，hash方法就不存在，从常理来讲，我们认为date1和date2相等，是因为两个变量都指向2022/10/1这个日期，所以自定义的Date类型应该和int类型一样，都是不可变对象，但由于是自定义对象，date1和date2实际上是指向两块不同的内存，而hash值是确保对象的唯一标识的手段，也就是说，如果两个对象的哈希值不同，那么它们的对象肯定不相等。但如果两个对象的哈希值相同，系统会继续比较它们的值或调用 __eq__() 方法来确定它们是否相等。</span></span><br><span class="line"><span class="comment"># 这就好比两个双胞胎，明明是两个不同的肉体(内存)，却有着一样的外形(eq)，你分辨不出，所以你通过名字标识了他们(hash)，你就能知道是两个不同的个体。如果是两个名字一样的人(hash相同)，但是外形不同(eq)，那么你也知道是两个人。hash帮助了你在分别见到双胞胎的时候，叫名字不至于认错，这就是唯一标识。唯一标识的作用下面解释。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用处</span></span><br><span class="line"><span class="comment"># 在字典中，key值必须唯一，不能重复，这是为了快速索引。但Date创建的date1和date2对象是个双胞胎，如果在字典中：</span></span><br><span class="line">income = &#123;&#125;<span class="comment"># 收入</span></span><br><span class="line">income[date1] = <span class="number">100</span></span><br><span class="line">income[date2] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(income)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;&#123;2022/10/1: 100, 2022/10/1: 100&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 但我们要的是一个date</span></span><br><span class="line"><span class="comment"># 所以可以在Date类中定义hash和eq方法，系统就会知道他俩相等。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.year == other.year <span class="keyword">and</span> self.month == other.month <span class="keyword">and</span> self.day == other.day</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span><span class="comment">#例子，别学</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;&#123;2022/10/1: 100&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 这样就标识了2022/10/1这个日期是唯一的，日期就是不可变对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line"><span class="comment"># 对于不可变对象（如整数、浮点数、字符串和元组），它们的哈希值是在对象创建时计算并保存的，因为它们的值是不可变的。这使得它们的哈希值唯一性和稳定性得到了保证。</span></span><br><span class="line"><span class="comment"># 对于可变对象（如列表、集合和字典），由于其值可以进行修改，因此在对象创建后即使不同的修改操作会改变其哈希值，因此可变对象默认是不可哈希的，即不能被用作字典的键或集合的元素。</span></span><br><span class="line"><span class="comment"># 尽管可变对象默认是不可哈希的，但可以通过自定义对象的 __hash__() 方法来使可变对象变为可哈希的。但一旦对象是可哈希的，并且作为字典键或集合元素使用时，就不应该再修改该对象的值，因为修改后会破坏数据结构的一致性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hash函数要求</span></span><br><span class="line"><span class="comment"># 必须返回一个整数</span></span><br><span class="line"><span class="comment"># 两个对象相等的时候，hash值必须相等</span></span><br><span class="line"><span class="comment"># 官方推荐写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">hash</span>((self.year,self.month,self.day))</span><br></pre></td></tr></table></figure></li></ol><h2 id="对象表示"><a href="#对象表示" class="headerlink" title="对象表示"></a>对象表示</h2><table><thead><tr><th>方法</th><th>tips</th></tr></thead><tbody><tr><td><code>__str__(self)</code></td><td>返回对象的字符串表示</td></tr><tr><td><code>__repr__(self)</code></td><td>represent，返回对象的可打印字符串表示</td></tr></tbody></table><p>区别：</p><p>str面向用户，要求可读性好。repr面向的是python的解释器，或者说开发人员，用来重新获得该对象，将对象转化为供解释器读取的形式。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制类的字符串形式，使用 str() 返回一个描述性好的字符串</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制类的字符串形式，使用 repr() 返回一个准确可重建对象的字符串</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Point 对象</span></span><br><span class="line">p1 = Point(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(p1))    <span class="comment"># 输出：Point(3, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 repr() 获取对象的字符串形式</span></span><br><span class="line">repr_str = <span class="built_in">repr</span>(p1)</span><br><span class="line"><span class="built_in">print</span>(repr_str)</span><br><span class="line"><span class="comment"># 使用 eval() 重新创建相同的对象</span></span><br><span class="line">p2 = <span class="built_in">eval</span>(repr_str)</span><br><span class="line"><span class="comment"># eval会把字符串当作代码运行</span></span><br><span class="line">p3 = <span class="built_in">eval</span>(<span class="string">&#x27;Point(3,5)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p2)<span class="comment"># 输出：Point(3, 5)</span></span><br><span class="line"><span class="built_in">print</span>(p3)<span class="comment"># 输出：Point(3, 5)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td><code>__getattr__(self,name)</code></td><td>访问对象某个属性不存在时，做的处理</td><td>不存在指getattribute方法返回值没有</td></tr><tr><td><code>__getattribute__(self,name)</code></td><td>访问对象属性存在时，返回属性值</td><td>可以加一写其他操作，注意递归</td></tr><tr><td><code>__setattr__(self,name,val)</code></td><td>设置一个对象属性</td><td>无</td></tr><tr><td><code>__delattr__(self,name)</code></td><td>del o.data对象属性时被调用</td><td>对象删除时并不会调用</td></tr><tr><td><code>__dir__(self)</code></td><td>打印可访问的属性和方法</td><td>必须返回sequence</td></tr></tbody></table><ul><li><code>__getattr__(self,name)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="comment"># 处理不存在的属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The attribute &#x27;<span class="subst">&#123;attr&#125;</span>&#x27; does not exist.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Person 对象</span></span><br><span class="line">person = Person(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问已经存在的属性</span></span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># 输出：John</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问不存在的属性</span></span><br><span class="line"><span class="built_in">print</span>(person.age)  <span class="comment"># 输出：The attribute &#x27;age&#x27; does not exist.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>__getattribute__(self,name)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data = <span class="string">&quot;abc&quot;</span></span><br><span class="line">        self.counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;data&quot;</span>:</span><br><span class="line">            self.counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__getattribute__(name) <span class="comment">#getattr(self,name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># self.counter += 1实际上也是再访问a中的属性，所以会产生递归。</span></span><br><span class="line"><span class="comment"># return super().__getattribute__(name)是为了返回属性值，如果写成self.name又会触发递归，所以调用父类的getattribute方法，虽然A()没有表明继承，但实际上是有父类的，我们的getattribute实际上重写，父类的getattritubr方法就只是单纯返回属性调用，return属性值。</span></span><br><span class="line"><span class="comment"># getattr(self,name)，该方法不是调用的__getattr__，而是先调用__getattritube__方法，如果不存在返回值，再调用__getattr__。它是一个获取属性的方法，它还有第三个参数，用来返回当属性不存在时，需返回的默认值，如果__getattr__已经被重写，则第三个参数不起作用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 A对象ssss</span></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问已经存在的属性</span></span><br><span class="line"><span class="built_in">print</span>(a.data)</span><br><span class="line"><span class="built_in">print</span>(a.counter)</span><br></pre></td></tr></table></figure><h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td><code>__get__(self, instance, owner)</code></td><td>通过实例访问属性时调用，定义属性的获取行为</td><td></td></tr><tr><td><code>__set__(self, instance, owner)</code></td><td>给属性赋值时调用，定义属性的设置行为</td><td></td></tr><tr><td><code>__delete__(self, instance, owner)</code></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 魔术方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt案例(一)计时器</title>
      <link href="/2023/07/29/Pyqt%E6%A1%88%E4%BE%8B(%E4%B8%80)%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
      <url>/2023/07/29/Pyqt%E6%A1%88%E4%BE%8B(%E4%B8%80)%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Pyqt案例-一-计时器"><a href="#Pyqt案例-一-计时器" class="headerlink" title="Pyqt案例(一)计时器"></a>Pyqt案例(一)计时器</h1><blockquote><p>本例包含内容：自定义信号、多线程、QLCDNumber</p><p>简单，适合当范例，忘记时候回来看看</p><p>ChatGPT能帮助解读代码</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PySide6.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sec = <span class="number">0</span> <span class="comment"># 时间：s/秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时线程，发送信号给Counter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeThread</span>(<span class="title class_ inherited__">QThread</span>):</span><br><span class="line">    timer = Signal()    <span class="comment"># timer每过一秒发送信号</span></span><br><span class="line">    end = Signal()      <span class="comment"># end计时结束发送信号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(TimeThread, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计时函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> sec == <span class="number">5</span>:</span><br><span class="line">                self.end.emit()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.timer.emit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时器主界面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Counter, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;计数器&quot;</span>)</span><br><span class="line">        self.resize(<span class="number">300</span>,<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># QLCDNumber一个显示数字的框</span></span><br><span class="line">        layout = QVBoxLayout()</span><br><span class="line">        self.lcd = QLCDNumber()</span><br><span class="line">        layout.addWidget(self.lcd)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计数开始按钮</span></span><br><span class="line">        self.butten = QPushButton(<span class="string">&#x27;开始计数&#x27;</span>)</span><br><span class="line">        layout.addWidget(self.butten)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 垂直布局放到按钮中</span></span><br><span class="line">        self.setLayout(layout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计时线程</span></span><br><span class="line">        self.timeThread = TimeThread()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链接信号与槽</span></span><br><span class="line">        self.timeThread.timer.connect(self.countTime)</span><br><span class="line">        self.timeThread.end.connect(self.end)</span><br><span class="line">        self.butten.clicked.connect(self.workThread)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当开始按钮click时，运行线程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">workThread</span>(<span class="params">self</span>):</span><br><span class="line">        self.timeThread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计时，每过一秒timer发送信号，sec加1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countTime</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> sec</span><br><span class="line">        sec+=<span class="number">1</span></span><br><span class="line">        self.lcd.display(sec)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计时结束，end发送信号，弹出结束对话框</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">self</span>):</span><br><span class="line">        QMessageBox.information(self,<span class="string">&#x27;消息&#x27;</span>,<span class="string">&#x27;计时结束&#x27;</span>,QMessageBox.Ok)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line"></span><br><span class="line">    window = Counter()</span><br><span class="line"></span><br><span class="line">    window.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.<span class="built_in">exec</span>())</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timer = Signal()</span><br><span class="line">self.timeThread.timer.connect(self.countTime)</span><br><span class="line"><span class="comment"># connect方法并不是Signal对象中的方法，而是QObject中的。</span></span><br><span class="line"><span class="comment"># 我之前写在了__init__方法里</span></span><br><span class="line">self.timer = Signal()</span><br><span class="line"><span class="comment">#...timer.connect()就会在Signal()中找connect方法</span></span><br><span class="line"><span class="comment"># 结果报错，Signal里根本没有connect</span></span><br><span class="line">AttributeError: <span class="string">&#x27;PySide6.QtCore.Signal&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;connect&#x27;</span></span><br><span class="line"><span class="comment"># 查了些资料没找到解释，chatGPT给的解释是，信号对象被创建时，会自动创建一个与之关联的信号通道。这个信号通道在内部维护了一个槽函数列表和一些其他信息。当调用 signal_object.connect(slot) 时，它实际上调用了信号通道内部的 connect 方法，将指定的槽函数添加到槽函数列表中。实现这一过程似乎是重写了__getattritube__方法。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 案例 </tag>
            
            <tag> 计时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub上md文件图片加载不出问题</title>
      <link href="/2023/07/25/GitHub%E4%B8%8Amd%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%87%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/25/GitHub%E4%B8%8Amd%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%87%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="问题：GitHub上md文件图片加载不出"><a href="#问题：GitHub上md文件图片加载不出" class="headerlink" title="问题：GitHub上md文件图片加载不出"></a>问题：GitHub上md文件图片加载不出</h1><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307252304150.png" alt="image-20230725230431572"></p><p>其他人项目中的md文件中的图片都无法加载。</p><h1 id="原因：DNS被污染，无法访问存放github图片素材的站点"><a href="#原因：DNS被污染，无法访问存放github图片素材的站点" class="headerlink" title="原因：DNS被污染，无法访问存放github图片素材的站点"></a>原因：DNS被污染，无法访问存放github图片素材的站点</h1><p>存放github图片素材的站点：<code>raw.githubusercontent.com</code></p><h1 id="解决办法：修改host文件"><a href="#解决办法：修改host文件" class="headerlink" title="解决办法：修改host文件"></a>解决办法：修改host文件</h1><ol><li>找到hosts文件，system系统的这个</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307252311283.png" alt="image-20230725231059476"></p><ol start="2"><li><p>查询站点的IP地址</p><p>查询网站：<a href="https://www.ipaddress.com/">What is my IP Address?</a>，复制<code>raw.githubusercontent.com</code>名称，即可找到对应ip地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询结果</span><br><span class="line">raw  IN  A  185.199.108.133</span><br><span class="line">raw  IN  A  185.199.109.133</span><br><span class="line">raw  IN  A  185.199.110.133</span><br><span class="line">raw  IN  A  185.199.111.133</span><br><span class="line"></span><br><span class="line">添加内容</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.109.133 raw.githubusercontent.com</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><blockquote><p>hosts文件有时候无法修改，将文件复制到桌面修改，再粘贴回去。</p></blockquote></li><li><p>刷新DNS</p><p>命令行，输入<code>ipconfig /flushdns</code></p></li></ol><p>​<img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307252316863.png" alt="image-20230725231629182"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python之下划线</title>
      <link href="/2023/07/25/python%E4%B9%8B%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
      <url>/2023/07/25/python%E4%B9%8B%E4%B8%8B%E5%88%92%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="单个下划线"><a href="#单个下划线" class="headerlink" title="单个下划线"></a>单个下划线</h1><ul><li><p>在命令行里输入单个下划线表示上一次的表达式</p></li><li><p>用作数值字面量中的千位分隔符，提高可读性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1_000_000</span></span><br></pre></td></tr></table></figure></li><li><p>用作临时变量名，常用来表示不需要使用的变量，在循环遍历中使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 情况1</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况2</span></span><br><span class="line">x, _, z = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>用作国际化（i18n）函数的翻译标记：在一些国际化库中，下划线常常用于标记需要进行翻译的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gettext <span class="keyword">import</span> gettext <span class="keyword">as</span> _</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(_(<span class="string">&quot;Hello World&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul><h2 id="前缀单下划线-name"><a href="#前缀单下划线-name" class="headerlink" title="前缀单下划线 _name"></a>前缀单下划线 _name</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#仅模块内方法调用</span></span><br><span class="line"><span class="comment">#标记类的私有属性和方法</span></span><br><span class="line"><span class="comment">#当一个方法有前缀_，则该方法在被import时也不能被调用。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line"><span class="comment">#例如设置一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name=<span class="string">&#x27;lbw&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><h2 id="后缀单下划线-name"><a href="#后缀单下划线-name" class="headerlink" title="后缀单下划线 name_"></a>后缀单下划线 name_</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果想使用python内置变量名，例如class、print，可以加一个_来区分，class_、print_</span><br></pre></td></tr></table></figure><h1 id="双下划线"><a href="#双下划线" class="headerlink" title="双下划线"></a>双下划线</h1><h2 id="前缀双下划线-name"><a href="#前缀双下划线-name" class="headerlink" title="前缀双下划线 __name"></a>前缀双下划线 __name</h2><p>重整（name mangling）：以双下划线开头的名称会被重命名为<code>_类名__名称</code>的形式，其中<code>类名</code>是包含该名称的类的名称，而<code>名称</code>是原始名称去掉双下划线开头的部分。</p><p>确保不同类中具有相同双下划线前缀的属性或方法不会发生冲突。使用双下划线开头的名称，可以有效地将其视为类的私有成员，不应该被外部代码直接访问或重写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__private_var = 10</span><br><span class="line"></span><br><span class="line">    def __private_method(self):</span><br><span class="line">        print(&quot;This is a private method.&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.__private_var = 20</span><br><span class="line"></span><br><span class="line">    def __private_method(self):</span><br><span class="line">        print(&quot;This is a private method in B.&quot;)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">print(a.__private_var)  # 无法直接访问原始的私有变量名</span><br><span class="line"># 输出：AttributeError: &#x27;A&#x27; object has no attribute &#x27;__private_var&#x27;</span><br><span class="line"></span><br><span class="line">print(a._A__private_var)</span><br><span class="line"># 输出：10</span><br><span class="line"></span><br><span class="line">print(b._B__private_var)  # 使用名称重整的方式访问私有变量</span><br><span class="line"># 输出：20</span><br><span class="line"></span><br><span class="line">a.__private_method()  # 无法直接访问原始的私有方法名</span><br><span class="line"># 输出：AttributeError: &#x27;A&#x27; object has no attribute &#x27;__private_method&#x27;</span><br><span class="line"></span><br><span class="line">a._A__private_method()</span><br><span class="line"># 输出：This is a private method.</span><br><span class="line"></span><br><span class="line">b._B__private_method()  # 使用名称重整的方式访问私有方法</span><br><span class="line"># 输出：This is a private method in B.</span><br></pre></td></tr></table></figure><h2 id="前后缀双下划线-name"><a href="#前后缀双下划线-name" class="headerlink" title="前后缀双下划线_name_"></a>前后缀双下划线_<em>name</em>_</h2><blockquote><p>魔术方法，这些方法在类定义中具有特殊的含义，并通过特定的调用方式进行调用。</p></blockquote><p>例如，<code>__init__</code>是用于初始化实例的构造函数，<code>__str__</code>用于自定义对象的字符串表示，<code>__add__</code>用于自定义对象的加法操作等等。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 下划线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo教程(三)博客美化</title>
      <link href="/2023/07/24/Hexo%E6%95%99%E7%A8%8B(%E4%B8%89)%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
      <url>/2023/07/24/Hexo%E6%95%99%E7%A8%8B(%E4%B8%89)%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="修改代码块主题"><a href="#修改代码块主题" class="headerlink" title="修改代码块主题"></a>修改代码块主题</h1><blockquote><p>Butterfly 支持6種代碼高亮樣式：darker、pale night、light、ocean、mac、mac light</p></blockquote><p>在<strong>主题配置文件</strong>下，找到highlight_theme字段，修改对应名称即可。</p><ul><li>mac</li></ul><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307241435818.png" alt="image-20230724143514191" style="zoom:80%;" /><p>查看其他效果点击：<a href="https://butterfly.js.org/posts/4aa8abbe/#%E4%BB%A3%E7%A2%BC%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A1%8C">Butterfly官方文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span> <span class="comment">#  darker / pale night / light / ocean / mac / mac light / false</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 代码一键复制按钮</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># 显示代码语言</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: 代码块不展开/ false: 代码块自动展开 | none: 代码块自动展开，且无收缩按钮 | 在font-matter中可对单个文文章进行配置</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="number">200</span> <span class="comment"># 高度限制，单位px像素</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">false</span><span class="comment">#代码自动换行，一般为滚动条形式</span></span><br></pre></td></tr></table></figure><h1 id="自定义代码块"><a href="#自定义代码块" class="headerlink" title="自定义代码块"></a>自定义代码块</h1><p>除了上述6种样式，如果喜欢其他的样式，可以通过标签插件实现。</p><p>官方文档中举了两个例子：<a href="https://butterfly.js.org/posts/b37b5fe3/">自定義代碼配色</a></p><p>效果：</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307241954619.png" alt="image-20230724195407039" style="zoom:80%;" /><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307241954439.png" alt="image-20230724195426216" style="zoom:80%;" /><h1 id="调整字体"><a href="#调整字体" class="headerlink" title="调整字体"></a>调整字体</h1><p>找到主题配置文件中的font字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span> <span class="string">16px</span> <span class="comment"># 默认14px</span></span><br><span class="line">  <span class="attr">code-font-size:</span> <span class="string">15px</span> <span class="comment"># 默认14px</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">HYSongYunLangHeiW,AlibabaPuHuiTi-3-55-Regular,&quot;Microsoft</span> <span class="string">YaHei&quot;,</span> <span class="string">sans-serif</span></span><br><span class="line">  <span class="attr">code-font-family:</span> <span class="string">HYSongYunLangHeiW,AlibabaPuHuiTi-3-55-Regular,&quot;Microsoft</span> <span class="string">YaHei&quot;,</span> <span class="string">sans-serif</span></span><br></pre></td></tr></table></figure><h2 id="修改字体大小"><a href="#修改字体大小" class="headerlink" title="修改字体大小"></a>修改字体大小</h2><p>global-font-size是全局字体大小，code-font-size是代码大小，个人感觉有点小，所以调高了一点，需要注意的是，作者提醒了非必要不要修改，因为改动是全局字体，一些插件中的字体会出范围，如下所示：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250138305.png" alt="image-20230725013845063"></p><h2 id="修改字体样式"><a href="#修改字体样式" class="headerlink" title="修改字体样式"></a>修改字体样式</h2><p>参考文章：</p><p><a href="https://www.eacls.top/posts/286b8081/">Blog by Eacls</a></p><p><a href="https://imbhj.com/posts/25c13146">Ordis Blog</a></p><p><a href="https://www.thyuu.com/word/tips/62610">免费引入商用黑体字体系列整理及 CSS 字体引入亲妈式教程（20230606更新）</a></p><p>其中需要注意的是，修改字体两种方式中，本地引入通常会非常拖慢速度，故多使用外链引入。</p><h2 id="Blog-标题字体修改"><a href="#Blog-标题字体修改" class="headerlink" title="Blog 标题字体修改"></a>Blog 标题字体修改</h2><p>butterfly主题还单独提供了标题字体的修改。(页面加粗白色字段)</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250327379.png" alt="image-20230725032729164" style="zoom: 67%;" /><p>依然还是找到主题文件中相关字段，就在font下面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Font settings for the site title and site subtitle</span></span><br><span class="line"><span class="comment"># 左上角網站名字 主頁居中網站名字</span></span><br><span class="line"><span class="attr">blog_title_font:</span></span><br><span class="line">  <span class="attr">font_link:</span> <span class="string">/css/iconfont.css</span> <span class="comment"># css路径</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">AlibabaPuHuiTi-3-55-Regular</span> <span class="comment"># 同上</span></span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>修改这个样式遇到好几个奇奇怪怪的问题，熬夜弄也没弄明白。</p><ol><li><p>font-family和code-font-family的字段，第一位接带“”双引号的字体名字时，会报错</p><p>解决办法：</p><ul><li>第一个字段随便写一个名字，第一个找不到会顺位到第二位。</li><li>修改css中引入字体的font-family，改为英文，去掉引号</li></ul></li><li><p>css外链引入时，诡异错误。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250309473.jpg" alt="(8R0Y9F)PJZIQ2RAG6XWV@Q" style="zoom: 67%;" /></li></ol><p>上面是正常引入的，但只要把第一个@font-face完全注释掉，字体就不会显示该样式了。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250312798.jpg" alt="QQ图片20230725031205" style="zoom:67%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python之文件操作</title>
      <link href="/2023/07/24/python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/24/python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="python的文件操作"><a href="#python的文件操作" class="headerlink" title="python的文件操作"></a>python的文件操作</h1><blockquote><p>python中内置了文件（File）对象。通过open()方法创建。</p></blockquote><h2 id="file文件的读写操作"><a href="#file文件的读写操作" class="headerlink" title="file文件的读写操作"></a>file文件的读写操作</h2><ul><li>创建和打开文件、关闭文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(filename[,mode[,buffering]])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># filename：要创建的文件名，或路径</span></span><br><span class="line"><span class="comment"># mode：文件的打开方式，取值见下表</span></span><br><span class="line"><span class="comment"># buffering：用于指定读写文件的缓冲模式</span></span><br><span class="line"><span class="comment"># 值为0表示不缓存，值为1表示缓存</span></span><br><span class="line"><span class="comment"># 大于1表示缓冲区的大小</span></span><br><span class="line">file.close()</span><br><span class="line"><span class="comment"># 使用close()方法时，会先刷新缓冲区中还没有写入的信息，然后再关闭文件，这样可以将没有写入文件的内容写入文件中</span></span><br></pre></td></tr></table></figure><p>写入文件后，一定要调用close()方法关闭文件，否则写入的内容不会保存到文件中。这是因为在写入文件内容时，操作系统不会立刻把数据写入磁盘，而是先缓存起来，只有调用close()方法时，操作系统才会保证把没有写入的数据全部写入磁盘。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240502274.png" alt="Image [5]"></p><ul><li>用with语句打开文件、写入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;path&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><ul><li>读取文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---读取指定字符---</span></span><br><span class="line">file.read([size])</span><br><span class="line"><span class="comment"># size: 用于指定要读取的字符个数，省略则全部读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---读取一行---</span></span><br><span class="line">file.readline()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---读取所有行---</span></span><br><span class="line">file.readlines()</span><br><span class="line"><span class="comment"># 返回每行的字符串列表</span></span><br></pre></td></tr></table></figure><ul><li>文件指针</li></ul><blockquote><p>文件指针能指定文件读写的起始位置</p></blockquote><p>python在关闭文件时，不会保存文件指针的位置，也就是说，每次打开时，文件指针都是0。而java、C和C#则会自动保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file.seek(offset[,whence])</span><br><span class="line"><span class="comment"># offset: 用于指定移动的字符个数</span></span><br><span class="line"><span class="comment">#--offset的值是按一个汉字占两个字符、英文和数字占一个字符计算的--</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whence: 指定移动的起始位置</span></span><br><span class="line"><span class="comment">#--whence值为0表示从文件头开始计算，1表示从当前位置开始计算，2表示从文件尾开始计算，默认为0--、</span></span><br><span class="line"></span><br><span class="line">file.seek(<span class="number">0</span>)<span class="comment"># 定位到开头</span></span><br><span class="line">file.seek(<span class="number">0</span>, <span class="number">2</span>)<span class="comment"># 定位到结尾</span></span><br><span class="line">file.read()<span class="comment"># 指向到读取后的位置</span></span><br></pre></td></tr></table></figure><h2 id="file文件的操作"><a href="#file文件的操作" class="headerlink" title="file文件的操作"></a>file文件的操作</h2><hr><ul><li>复制、移动</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要使用shutil模块</span></span><br><span class="line">shutil.copyfile(src, dst)</span><br><span class="line"></span><br><span class="line">shutil.move(src, dst)</span><br></pre></td></tr></table></figure><ul><li>重命名、删除、获取基本信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要用到os模块</span></span><br><span class="line">os.rename(src, dst)</span><br><span class="line"></span><br><span class="line">os.remove(path)</span><br><span class="line"></span><br><span class="line">os.stat(path)</span><br><span class="line"><span class="comment"># 返回属性见下表</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240501920.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(七)多线程</title>
      <link href="/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%83)%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%83)%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h1><hr><p><strong>进程</strong>：系统中资源分配和资源调度的基本单位，叫作进程。</p><p><strong>线程</strong>：个线程则是进程中的执行流程，一个进程中可以同时包括多个线程，每个线程也可以得到一小段程序的执行时间，这样一个进程就可以具有多个并发执行的线程。</p><h2 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h2><ul><li>通过网络与web服务器和数据库进行通信。</li><li>执行占用大量时间的操作</li><li>区分具有不同优先级的任务</li><li>使用户界面可用在将时间分配给后台任务时仍能快速做出响应</li></ul><h2 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h2><p>建议一般不要在程序中使用太多的线程，这样可以最大限度地减少操作系统资源的使用，并提高性能</p><ul><li>系统将为进程和线程所需的上下文信息使用内存。因此，可用创建的进程和线程的数目会收到可用内存的限制。</li><li>跟踪大量的线程将占用大量的处理器时间。如果线程过多，则其中大多数线程都不会产生明显的进度。如果大多数线程处于一个进程中，则其他进程中的线程的调度频率就会很低。</li><li>使用多个线程控制代码执行非常复制，并可能产生许多Bug</li><li>销毁线程需要了解可能发生的问题并进行处理</li></ul><h1 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h1><hr><p>在PyQt5中实现多线程主要有两种方法，一种是使用QTimer计时器模块；另一种是使用QThread线程模块</p><h2 id="QTimer：计时器"><a href="#QTimer：计时器" class="headerlink" title="QTimer：计时器"></a>QTimer：计时器</h2><p>如果需要周期性地执行某项操作，就可以使用QTimer类实现，QTimer类表示计时器，它可以定期发射timeout信号，时间间隔的长度在start()方法中指定，以毫秒为单位，如果要停止计时器，则需要使用stop()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QTimer</span><br><span class="line"></span><br><span class="line">timer = QTimer(MainWindow)</span><br><span class="line">timer.start()<span class="comment">#开始计时器</span></span><br><span class="line">timer.timeout.connect(槽函数)<span class="comment"># 设置计时器要执行的槽函数</span></span><br><span class="line"><span class="comment"># 接下来，timer线程会重复执行槽函数</span></span><br><span class="line">timer.stop()<span class="comment">#停止计时器</span></span><br></pre></td></tr></table></figure><h2 id="QThread：线程类"><a href="#QThread：线程类" class="headerlink" title="QThread：线程类"></a>QThread：线程类</h2><p><strong>常用方法</strong></p><table><thead><tr><th>run()</th><th>线程的起点，在调用start()之后，新创建的线程将调用该方法</th></tr></thead><tbody><tr><td>start()</td><td>启动线程</td></tr><tr><td>wait()</td><td>阻塞线程</td></tr><tr><td>sleep()</td><td>以秒为单位休眠线程</td></tr><tr><td>msleep()</td><td>以毫秒为单位休眠线程</td></tr><tr><td>usleep()</td><td>以微秒为单位休眠线程</td></tr><tr><td>quit()</td><td>退出线程的事件循环并返回代码0(成功)，相当于exit(0)</td></tr><tr><td>exit()</td><td>退出线程的事件循环，并返回代码，如果返回0成功，其他错误</td></tr><tr><td>terminate()</td><td>强制终止线程，在terminate()之后应该使用wait()方法，以确保当线程终止时，等待线程完成的所有线程都将被唤醒，另外，不建议使用这种方法终止线程</td></tr><tr><td>setPriority()</td><td>设置线程的优先级：QThread.IdlePriority：空闲优先级QThread.LowestPriority：最低优先级QThread.LowPriority：低优先级QThread.NormalPriority：系统默认优先级QThread.HighPrioriry：高优先级QThread.HighestPriority：最高优先级QThread.TimeCriticalPriority：尽可能频繁地分配执行QThread.InheritPriority：默认，使用与创建线程相同的优先级</td></tr><tr><td>isFinished()</td><td>是否完成</td></tr><tr><td>isRunning()</td><td>是否正在运行</td></tr></tbody></table><p><strong>信号</strong></p><table><thead><tr><th>started</th><th>在调用run()方法之前，在相关线程开始执行时从该线程发射</th></tr></thead><tbody><tr><td>finished</td><td>在相关线程完成执行之前从该线程发射</td></tr></tbody></table><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><hr><p>线程也有自己的生命周期，其中包含5种状态，分别为出生状态、就绪状态、运行状态、暂停状态（包括休眠、等待和阻塞等）和死亡状态</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240457216.png" alt="Image [4]"></p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(五)信号与槽</title>
      <link href="/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%94)%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
      <url>/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%94)%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><hr><blockquote><p>所有继承Qwidget的控件都支持信号与槽机制</p></blockquote><ul><li>信号：当一个信号发生改变时，向外界发出的信息。</li></ul><p>当一个信号被发射时，与其关联的槽函数被立刻执行。其中该对象只负责发送信号，发射该信号的对象并不知道是哪个对象在接受这个信号，这样保证了对象与对象之间的低耦合。</p><p>如果存在信号和多个槽函数相关联的时候，当信号被发射时，这些槽的执行顺序将会是随机的。</p><ul><li>槽：一个执行某些操作的函数或者方法</li></ul><p>当和槽连接的信号被发射时，槽会被调用。一个槽并不知道是否有任何信号与自己相连接。</p><ul><li><p>信号与槽机制</p></li><li><p>将信号 连接 槽，当信号发出时，连接的槽函数会自动执行</p></li><li><p>信号连接</p></li></ul><p>通过调用QObject对象的connect函数来将某个对象的信号与另一个对象的槽函数相关联。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.信号.connect(槽函数)</span><br></pre></td></tr></table></figure><p>当信号与槽没有必要保持关联时，可以使用disconnect函数来断开连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(槽函数)</span><br></pre></td></tr></table></figure><h1 id="槽函数的特点"><a href="#槽函数的特点" class="headerlink" title="槽函数的特点"></a>槽函数的特点</h1><ol><li>一个信号可以连接多个槽：调用随机</li><li>多个信号可以连接到同一个槽</li><li>信号的参数可以是任何的python类型，如list等</li><li>信号和槽的连接可以被移除</li><li>信号可以和另外一个信号进行关联：第一个信号发出后，第二个信号也同时发送。比如关闭系统的信号发出后，同时会发出保存数据的信号</li></ol><h1 id="自定义信号与槽"><a href="#自定义信号与槽" class="headerlink" title="自定义信号与槽"></a>自定义信号与槽</h1><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> pyqtSignal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义信号：可以带参数</span></span><br><span class="line">signal = pyqtSignal()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义槽函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signalCall</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;signal emit&quot;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line">self.signal.connect(self.signalCall)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发射信号</span></span><br><span class="line">self.signal.emit()</span><br></pre></td></tr></table></figure><h1 id="关于连接中槽函数无法传递参数问题"><a href="#关于连接中槽函数无法传递参数问题" class="headerlink" title="关于连接中槽函数无法传递参数问题"></a>关于连接中槽函数无法传递参数问题</h1><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.btn.clicked.connect(self.onButtonClick)</span><br><span class="line"></span><br><span class="line"><span class="comment"># onButtonClick()函数无法传递参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决办法1：lamdba表达式，传递一个匿名函数</span></span><br><span class="line">self.btn.clicked.connect(lamdba: self.onButtonClick(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#解决办法2：使用functools中的partial函数</span></span><br><span class="line">self.btn.clicked.connect(partial(self.onButtonClick,<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 信号与槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(六)常用控件</title>
      <link href="/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E5%85%AD)%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/"/>
      <url>/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E5%85%AD)%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="文本类控件"><a href="#文本类控件" class="headerlink" title="文本类控件"></a>文本类控件</h1><blockquote><p>文本类控件主要用来显示或者编辑文本信息，主要有Label、LineEdit、TextEdit、SpinBox、DoubleSpinBox、LCDNumber</p></blockquote><h2 id="Label：标签控件"><a href="#Label：标签控件" class="headerlink" title="Label：标签控件"></a>Label：标签控件</h2><blockquote><p>主要用于显示用户不能编辑的文本，标识窗体上的对象，添加描述信息，对应QLabel类</p></blockquote><p><strong>常用方法</strong></p><ul><li>设置text文本属性</li></ul><p><code>lab.setText(text)</code></p><ul><li>设置标签文本的对齐方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#alignment属性：Horizontal和Vertical，水平和垂直 </span></span><br><span class="line"><span class="comment">#Horizontal：AlignLeft左对齐、AlignHCenter居中、AlignRight右对齐、AlignJustify两端对齐</span></span><br><span class="line"><span class="comment">#Vertical：AlignTop顶部对齐、AlignVCenter居中、AlignBottom底部对齐 #方法</span></span><br><span class="line">lab.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)</span><br></pre></td></tr></table></figure><ul><li>设置文本换行显示</li></ul><p>标签宽度不足情况下，系统会默认只显示部分文字。所以需要设置标签中的文本换行显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#wordWrap属性：True和False</span></span><br><span class="line"><span class="comment">#方法</span></span><br><span class="line">lab.setWordWrap(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>为标签设置超链接</li></ul><p>直接在setText()方法中使用HTML中的<a>标签设置超链接文本，然后将Label标签的setOpenExternalLinks()设置为True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lab.setText(<span class="string">&quot;&lt;a href=&#x27;https://www.bilibili.com/&#x27;&gt;bilibili&lt;/a&gt;&quot;</span>) </span><br><span class="line">lab.setOpenExternalLinks(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>为标签设置图片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法,需要有一个QPixmap对象</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPixmap</span><br><span class="line">lab.setPixmap(QPixmap(<span class="string">&#x27;test.png&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>获取标签文本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab.text()</span><br></pre></td></tr></table></figure><h2 id="LineEdit：单行文本框"><a href="#LineEdit：单行文本框" class="headerlink" title="LineEdit：单行文本框"></a>LineEdit：单行文本框</h2><p><strong>常用方法</strong></p><ul><li>设置文本框内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setText(str)</span><br></pre></td></tr></table></figure><ul><li>获取文本框内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.text()</span><br></pre></td></tr></table></figure><ul><li>设置文本框浮显文字</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setPlaceholderText(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><ul><li>设置允许文本框输入字符的最大长度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setMaxLength()</span><br></pre></td></tr></table></figure><ul><li>设置文本对齐方式式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setAlignment(Horzontal,Vartical)</span><br></pre></td></tr></table></figure><ul><li>设置文本框只读</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setReadOnly()</span><br></pre></td></tr></table></figure><ul><li>使文本框得到焦点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setFocus()</span><br></pre></td></tr></table></figure><ul><li>清除文本框内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.clear()</span><br></pre></td></tr></table></figure><ul><li>设置文本框显示字符的模式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QLineEdit.Normal: 正常显示输入的字符</span></span><br><span class="line"><span class="comment"># QLineEdit.NoEcho: 不显示任何输入的字符</span></span><br><span class="line"><span class="comment"># QLineEdit.Password: 显示与平台相关的密码掩码字符</span></span><br><span class="line"><span class="comment"># QLineEdit.PasswordEchoOnEdit: 在编辑时显示字符，失去焦点后显示掩码</span></span><br><span class="line">ledit.setEchoMode()</span><br></pre></td></tr></table></figure><ul><li>设置文本框验证器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QIntValidator: 限制输入整数</span></span><br><span class="line"><span class="comment"># QDoubleValidator: 限制输入小数</span></span><br><span class="line"><span class="comment"># QRegExpValidator: 检查输入是否符合设置的正则表达式</span></span><br><span class="line">ledit.setValidator()</span><br></pre></td></tr></table></figure><ul><li>设置掩码</li></ul><p>掩码通常由掩码字符和分隔符组成，后面可以跟一个分号和空白字符，空白字符在编辑完成后会从文本框中删除</p><p>日期掩码：0000-00-00;</p><p>时间掩码：00:00:00;</p><p>序列号掩码：&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setInputMask()</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li>当更改文本框中内容时发射该信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.textChanged.connect(槽函数)</span><br></pre></td></tr></table></figure><ul><li>当文本框中的内容编辑结束时发射该信号，以按下Enter为编辑结束标志</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.editingFinished.connect(槽函数)</span><br></pre></td></tr></table></figure><h2 id="TextEdit：多行文本框"><a href="#TextEdit：多行文本框" class="headerlink" title="TextEdit：多行文本框"></a>TextEdit：多行文本框</h2><p><strong>常用方法</strong></p><ul><li>设置文本内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.setPlainText(str)</span><br></pre></td></tr></table></figure><ul><li>获取文本内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.toPlainText()</span><br></pre></td></tr></table></figure><ul><li>设置文本颜色</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tedit.setTextColor(QtGui.QColor(255,0,0))</span><br><span class="line">#需要一个QColor对象</span><br></pre></td></tr></table></figure><ul><li>设置文本背景颜色</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tedit.setTextBackgroundColor(QtGui.QColor(255,0,0))</span><br><span class="line">#需要一个QColor对象</span><br></pre></td></tr></table></figure><ul><li>设置HTML文档内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.setHtml()</span><br></pre></td></tr></table></figure><ul><li>获取HTML文档内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.toHtml()</span><br></pre></td></tr></table></figure><ul><li>设置自动换行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.wordWrapMode()</span><br></pre></td></tr></table></figure><ul><li>清除所有内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.clear()</span><br></pre></td></tr></table></figure><h1 id="按钮类控件"><a href="#按钮类控件" class="headerlink" title="按钮类控件"></a>按钮类控件</h1><p>按钮类控件主要用来执行一些命令操作，主要有PushButton、ToolButton、CommandLinkButton、RadioButton和CheckBox</p><h2 id="PushButton：按钮"><a href="#PushButton：按钮" class="headerlink" title="PushButton：按钮"></a>PushButton：按钮</h2><hr><p><strong>定义</strong></p><p><code>button = QPushButton(&#39;&amp;Download&#39;, self)</code></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240443020.png" alt="img"></p><p><strong>常用方法</strong></p><ul><li>设置按钮所显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbtn.setText(str)</span><br></pre></td></tr></table></figure><ul><li>获取按钮所显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbtn.text()</span><br></pre></td></tr></table></figure><ul><li>设置按钮上的图标、设置按钮图标大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide2.QtCore <span class="keyword">import</span> Qt,QSize </span><br><span class="line"><span class="keyword">from</span> PySide2.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"></span><br><span class="line">pbtn.setIcon(QtGui.QIcon(<span class="string">&#x27;icon_path&#x27;</span>))</span><br><span class="line">pbtn.setIconSize(Qt.Core.QSize(<span class="built_in">int</span> width,<span class="built_in">int</span> height))</span><br></pre></td></tr></table></figure><ul><li>设置按钮是否可用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pbtn.setEnabled(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 不可用</span></span><br></pre></td></tr></table></figure><ul><li>设置按钮的快捷键</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pbtn.setShortcut()</span><br><span class="line"># 参数可以设置为键盘中的按键或快捷键，例如&#x27;Alt+0&#x27;</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li><strong>信号: 被点击</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbtn.clicked.connect(槽函数)</span><br></pre></td></tr></table></figure><h2 id="RadioButton：单选按钮"><a href="#RadioButton：单选按钮" class="headerlink" title="RadioButton：单选按钮"></a>RadioButton：单选按钮</h2><hr><p>对应QRadioButton类</p><p><strong>常用方法</strong></p><ul><li>设置单选按钮显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.setText(str)</span><br></pre></td></tr></table></figure><ul><li>获取单选按钮显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.text()</span><br></pre></td></tr></table></figure><ul><li>设置单选按钮是否为选中状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rbtn.setChecked(True)</span><br><span class="line"># 或者</span><br><span class="line">rbtn.setCheckable(False)</span><br></pre></td></tr></table></figure><ul><li>查看单选按钮是否为选中状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.isChecked()</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li>单击单选按钮</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.clicked.connect()</span><br></pre></td></tr></table></figure><ul><li>在单选按钮状态改变时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 常用</span><br><span class="line">rbtn.toggled.connect()</span><br></pre></td></tr></table></figure><h1 id="进度条：ProgressBar"><a href="#进度条：ProgressBar" class="headerlink" title="进度条：ProgressBar"></a>进度条：ProgressBar</h1><p>对应QProgressBar类</p><p><strong>常用方法</strong></p><ul><li>设置进度条的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置进度条的最小值</span></span><br><span class="line">pgbar.setMinimum(<span class="built_in">int</span> num)</span><br><span class="line"><span class="comment"># 设置进度条的最大值</span></span><br><span class="line">pgbar.setMaximum()</span><br><span class="line"><span class="comment"># 设置进度条的取值范围，相当于上两组合</span></span><br><span class="line">pgbar.setRange()</span><br><span class="line"><span class="comment"># 设置进度条的当前值</span></span><br><span class="line">pgbar.setValue()</span><br></pre></td></tr></table></figure><ul><li>设置进度条的文字填充格式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %p%：显示完成的百分比</span></span><br><span class="line"><span class="comment"># %v：显示当前的进度值</span></span><br><span class="line"><span class="comment"># %m：显示总的步长值</span></span><br><span class="line">pgbar.setFormat()</span><br></pre></td></tr></table></figure><ul><li>设置进度条的布局方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt.LeftToRight: 从左到右</span></span><br><span class="line"><span class="comment"># Qt.RightToLeft: 从右到左</span></span><br><span class="line"><span class="comment"># Qt.LayoutDirectionAuto: 跟随布局方向自动调整</span></span><br><span class="line">pgbar.setLayoutDirection()</span><br></pre></td></tr></table></figure><ul><li>设置对齐方式</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240442816.png" alt="img"></p><ul><li>设置进度条的显示方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt.Horizontal: 水平方向</span></span><br><span class="line"><span class="comment"># Qt.Vertical: 垂直方向</span></span><br><span class="line">pgbar.setOrientation()</span><br></pre></td></tr></table></figure><ul><li>设置进度条是否以反方向显示进度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgbar.setInvertedAppearance()</span><br></pre></td></tr></table></figure><ul><li>设置进度条的文本显示方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QProgressBar.TopToBottom: 从上到下</span></span><br><span class="line"><span class="comment"># QProgressBar.BottomToTop: 从下到上</span></span><br><span class="line">pgbar.setTextDirection()</span><br></pre></td></tr></table></figure><ul><li>对进度条的属性进行设置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以是任何属性，如self.progressBar.setProperty(&quot;value&quot;,24)</span></span><br><span class="line">pgbar.setProperty()</span><br></pre></td></tr></table></figure><ul><li>获取进度条的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取最大值</span></span><br><span class="line">pgbar.minimum()</span><br><span class="line"><span class="comment"># 获取最小值</span></span><br><span class="line">pgbar.maximum()</span><br><span class="line"><span class="comment"># 获取当前值</span></span><br><span class="line">pgbar.value()</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li>在进度条的值发生改变时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgbar.valueChanged.connect()</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240442197.png" alt="Image [3]"></p><h1 id="对话框类"><a href="#对话框类" class="headerlink" title="对话框类"></a>对话框类</h1><p>常用对话框有QMessageBox、QFileDialog、QInputDialog、QFontDialog和QColorDialog</p><h2 id="QMessageBox：对话框"><a href="#QMessageBox：对话框" class="headerlink" title="QMessageBox：对话框"></a>QMessageBox：对话框</h2><hr><h3 id="对话框种类"><a href="#对话框种类" class="headerlink" title="对话框种类"></a>对话框种类</h3><table><thead><tr><th>QMessageBox.information()</th><th>消息对话框</th></tr></thead><tbody><tr><td>QMessageBox.question()</td><td>问答对话框</td></tr><tr><td>QMessageBox.warning()</td><td>警告对话框</td></tr><tr><td>QMessageBox.critical()</td><td>错误对话框</td></tr><tr><td>QMessageBox.about()</td><td>关于对话框</td></tr></tbody></table><h3 id="使用方法：以消息对话框为例"><a href="#使用方法：以消息对话框为例" class="headerlink" title="使用方法：以消息对话框为例"></a>使用方法：以消息对话框为例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox.information(QWidget, <span class="string">&#x27;Title&#x27;</span>, <span class="string">&#x27;Content&#x27;</span>, buttons, defaultbutton)</span><br><span class="line"><span class="comment"># QWidget: self或窗口对象，表示该对话框所属窗口</span></span><br><span class="line"><span class="comment"># Title: 字符串，表示对话框的标题</span></span><br><span class="line"><span class="comment"># Content: 字符串，表示对话框中的提示内容</span></span><br><span class="line"><span class="comment"># button: 对话框上要添加的按钮，多个按钮之间用“|”来连接，按钮种类见下表</span></span><br><span class="line"><span class="comment"># defaultbutton: 默认选中的按钮</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240448440.png" alt="img"></p><blockquote><p>QMessageBox.about()关于对话框中不能指定按钮。</p><p>QMessageBox.about(QWidget, ‘Title’, ‘Content’)</p></blockquote><h2 id="QFileDialog-文件对话框"><a href="#QFileDialog-文件对话框" class="headerlink" title="QFileDialog: 文件对话框"></a>QFileDialog: 文件对话框</h2><hr><p>该类继承自QDialog类，它允许用户选择文件或者文件夹，也允许用户遍历文件系统，以便选择一个或多个文件或者文件夹。</p><p><strong>常用方法</strong></p><ul><li>获取一个、多个打开文件的文件名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> = QFileDialog()</span><br><span class="line"><span class="built_in">dir</span>.getOpenFileName()</span><br><span class="line"><span class="built_in">dir</span>.getOpenFileNames()</span><br></pre></td></tr></table></figure><ul><li>获取保存的文件名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.getSaveFileName()</span><br></pre></td></tr></table></figure><ul><li>获取一个打开的文件夹</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.getExistingDirectory()</span><br></pre></td></tr></table></figure><ul><li>设置接收模式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setAcceptMode()</span><br><span class="line"><span class="comment"># QFileDialog.AcceptOpen: 设置文件对话框为打开模式</span></span><br><span class="line"><span class="comment"># QFileDialog.AcceptSave: 设置文件对话框为保存模式</span></span><br></pre></td></tr></table></figure><ul><li>设置文件对话框中的文件名的默认后缀名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setDefaultSuffix()</span><br></pre></td></tr></table></figure><ul><li>设置可以选择的文件类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setFileMode()</span><br><span class="line"><span class="comment"># QFileDialog.AnyFile: 任意文件（无论是否存在）</span></span><br><span class="line"><span class="comment"># QFileDialog.ExistingFile: 已存在的文件</span></span><br><span class="line"><span class="comment"># QFileDialog.ExistingFiles: 已存在的多个文件</span></span><br><span class="line"><span class="comment"># QFileDialog.Directory: 文件夹</span></span><br><span class="line"><span class="comment"># QFileDialog.DirectoryOnly： 文件夹（选择时只能选中文件夹）</span></span><br></pre></td></tr></table></figure><ul><li>设置文件对话框默认打开位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setDirectory()</span><br></pre></td></tr></table></figure><ul><li>设置名称过滤器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setNameFilter()</span><br><span class="line"><span class="comment"># 多个类型的过滤器之间用两个分号分割，(*.*);;(*.py)</span></span><br><span class="line"><span class="comment"># 一个过滤器中如果有多种个数，用空格分割，(*.jpg *.png *.bmp)</span></span><br></pre></td></tr></table></figure><ul><li>设置显示模式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setViewMode()</span><br><span class="line"><span class="comment"># QFileDialog.Detail: 显示文件详细信息，包括文件名、大小、日期</span></span><br><span class="line"><span class="comment"># QFileDialog.List: 以列表形式显示文件名</span></span><br></pre></td></tr></table></figure><ul><li>获取选择的一个、多个文件或文件夹名字</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.selectedFile()</span><br><span class="line"><span class="built_in">dir</span>.selectedFiles()</span><br></pre></td></tr></table></figure><h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><p><code>QtCore</code> 模块是非 GUI 的核心库。这个模块用来处理时间、文件、目录、各种类型的数据、流（stream）、URLs，mime 类型、线程和进程。 <code>QtGui</code> 有窗口系统集成、事件处理、2D图形，基本图像、字体、文本的类。 <code>QtWidgets</code> 有创建经典风格的用户界面的类。</p><p><code>QtDBus</code> 是使用 D-Bus 处理 IPC 通讯的类。<code>QtNetwork</code> 是网络变成类，这些类使网络编程变得更容易，可移植性也更好，方便了 TCP&#x2F;IP 和 UDP 服务端和客户端编程。 <code>QtHelp</code> 包含了创建、查看和搜索文档的类。</p><p><code>QtXml</code> 包含了处理 XML 文件的类，实现了 SAX 和 DOM API。<code>QtSvg</code> 提供了显示 SVG 的类，可缩放矢量图形(SVG)是一种描述二维图像和图像应用的 XML 语言。<code>QtSql</code> 模块提供了数据库的类，<code>QtTest</code> 提供了可以对 PyQt6 应用进行单元测试的工具。</p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 常用控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之sys模块</title>
      <link href="/2023/07/20/Python%E4%B9%8Bsys%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/20/Python%E4%B9%8Bsys%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="sys模块介绍"><a href="#sys模块介绍" class="headerlink" title="sys模块介绍"></a>sys模块介绍</h1><blockquote><p>sys全称system系统，该模块提供了系统相关的参数和函数，这些变量和方法可供<strong>Python解释器</strong>交互，用于操控运行时的环境。</p></blockquote><h2 id="什么是Python解释器"><a href="#什么是Python解释器" class="headerlink" title="什么是Python解释器"></a>什么是Python解释器</h2><p>python是一种语言，而这种语言是对程序员来说的，计算机系统并不能理解，所以有了python解释器。</p><blockquote><p>python解释器是一个软件，用于解析和执行Python程序。</p></blockquote><p>Python解释器有多种实现：</p><ul><li><p>CPython是Python的官方解释器，它是基于C语言开发的，将Python代码解释成C语言的中间代码，然后再通过编译器将C代码转换为机器码执行。</p></li><li><p>IPython 是基于 CPython 之上的一个交互式解释器，旨在提供更快的执行速度。它通过即时编译（JIT）技术将Python代码直接转换为机器码，而不需要中间过程。</p></li><li><p>PyPy ：PyPy 解释器的目标是执行速度，它采用 JIT 技术，对 Python 代码进行动态编译，所以可以显著提高 Python 代码的执行速度。</p></li><li><p>Jython：运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。</p></li></ul><h1 id="具体功能和方法介绍"><a href="#具体功能和方法介绍" class="headerlink" title="具体功能和方法介绍"></a>具体功能和方法介绍</h1><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.python.org/zh-cn/3/library/sys.html">python官中文档</a></p><p><a href="https://blog.csdn.net/qq_53568983/article/details/127252303">python之sys模块详解</a></p><p><a href="https://blog.csdn.net/xw1680/article/details/125594820">Python 常用基础模块（四）：sys模块</a></p><h2 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sys.version<span class="comment">#还有sys.version_info</span></span><br><span class="line"><span class="comment">#一个字符串，包含Python解释器版本号加编译版本号以及所用编译器等额外信息。</span></span><br><span class="line"><span class="comment">#&#x27;3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]&#x27;</span></span><br><span class="line"></span><br><span class="line">sys.platform<span class="comment">#sys.getwindowsversion获取windows版本</span></span><br><span class="line"><span class="comment">#一个字符串，获取当前运行平台</span></span><br><span class="line"><span class="comment">#&#x27;win32&#x27;</span></span><br><span class="line">sys.executable</span><br><span class="line"><span class="comment">#字符串，当前Python解释器的可执行文件路径。在需要时执行与Python解释器相关的操作，例如调用另一个Python脚本、创建子进程等。</span></span><br><span class="line"><span class="comment">#&#x27;D:\\python\\python.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">sys.copyright<span class="comment">#版权相关的东西</span></span><br><span class="line">sys.api_version <span class="comment">#解释器的C的API版本</span></span><br><span class="line">sys.executable <span class="comment">#Python解释程序路径</span></span><br><span class="line">sys.builtin_module_names <span class="comment">#Python解释器导入的模块列表</span></span><br></pre></td></tr></table></figure><h2 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h2><p>一个列表，包含了被传递给python脚本的命令行参数。</p><ul><li>argv[0]：程序本身的路径</li><li>argv[1]：程序的第一个参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;python helloworld.py -b</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sys.argv打印结果：[<span class="string">&#x27;E:/pythoncode/helloworld.py&#x27;</span>, <span class="string">&#x27;-b&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sys.arg[0]打印结果：E:/pythoncode/helloworld.py</span></span><br></pre></td></tr></table></figure><h2 id="sys-exit"><a href="#sys-exit" class="headerlink" title="sys.exit()"></a>sys.exit()</h2><p>此方法用于退出python解释器，即退出运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正常退出程序</span></span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#非正常，参数不为0时，如下。</span></span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#作用：控制程序中途退出</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307210040585.png" alt="image-20230721004033333"></p><h2 id="sys-modules"><a href="#sys-modules" class="headerlink" title="sys.modules"></a>sys.modules</h2><p>一个字典，获取本机所有已安装的模块及所在模块文件</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307210148654.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sys.modules[<span class="string">&#x27;os&#x27;</span>]</span><br><span class="line"><span class="comment">#获取os模块列表</span></span><br><span class="line"></span><br><span class="line">sys.modules.keys()</span><br><span class="line"><span class="comment">#可遍历打印所有模块</span></span><br></pre></td></tr></table></figure><h2 id="sys-path"><a href="#sys-path" class="headerlink" title="sys.path"></a>sys.path</h2><p>一个列表，包含python相关的路径，这些是模块的搜索路径。第一项path[0]为该.py脚本所在目录。下面图片中是在控制台中，所以第一项为空字符串。</p><p><img src="D:/blog/source/_posts/assets/image-20230721204248378.png" alt="image-20230721204248378"></p><p>作用：有时候程序运行的环境不同，模块的路径会出现问题，可以通过sys.path.append(root_path)添加到里面。</p><h2 id="sys-stdin-amp-sys-stdout-amp-sys-stderr"><a href="#sys-stdin-amp-sys-stdout-amp-sys-stderr" class="headerlink" title="sys.stdin&amp;sys.stdout&amp;sys.stderr"></a>sys.stdin&amp;sys.stdout&amp;sys.stderr</h2><p><strong>文件对象</strong>，标准输入，标准输出，错误输出</p><ul><li><code>stdin</code> 用于所有交互式输入（包括对 <a href="https://docs.python.org/zh-cn/3/library/functions.html#input"><code>input()</code></a> 的调用）；</li><li><code>stdout</code> 用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print"><code>print()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-expression">expression</a> 语句的输出，以及用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#input"><code>input()</code></a> 的提示符；</li><li>解释器自身的提示符和它的错误消息都发往 <code>stderr</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys.stdin.readline()<span class="comment">#等价于input()</span></span><br><span class="line"><span class="comment">#在交互式终端正常使用没问题，但在集成开发环境，可能无法正常工作</span></span><br><span class="line"></span><br><span class="line">sys.stdout.write()<span class="comment">#等价于print()</span></span><br><span class="line"><span class="comment">#print()函数实际上是通过sys.stdout实现的，由于print()函数在builtins.py中实现为一个内建函数，其具体实现通常由编译器或解释器负责。因此，我们不能直接查看print()函数的源代码。</span></span><br><span class="line"></span><br><span class="line">sys.stderr.write()<span class="comment">#可以在错误流中输入信息</span></span><br><span class="line"><span class="comment">#用于将错误信息输出到控制台或其他错误日志文件中。默认情况下，sys.stderr连接到控制台。</span></span><br></pre></td></tr></table></figure><h2 id="sys-getdefaultencoding"><a href="#sys-getdefaultencoding" class="headerlink" title="sys.getdefaultencoding()"></a>sys.getdefaultencoding()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sys.getdefaultencoding()</span><br><span class="line"><span class="comment">#字符串，返回当前默认字符串编码的名称</span></span><br><span class="line"><span class="comment">#&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#设置当前默认字符编码</span></span><br><span class="line"></span><br><span class="line">sys.getfilesystemencoding()</span><br><span class="line"><span class="comment">#字符串，返回当前系统中文件系统编码的名称。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>文件系统编码</strong>是指用于在操作系统文件系统中表示和存储文件名和路径的字符编码。不同的操作系统和文件系统可能使用不同的字符编码来处理文件名和路径。</p></blockquote><h2 id="sys-exc-info"><a href="#sys-exc-info" class="headerlink" title="sys.exc_info()"></a>sys.exc_info()</h2><p>元组，包含当前异常类型、异常对象和跟踪栈信息：</p><ul><li>异常类型：表示引发异常的类型。</li><li>异常对象：表示当前异常的实例对象。</li><li>跟踪栈信息：表示导致异常的函数调用栈信息</li></ul><p>举例，10&#x2F;0的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Some code that may raise an exception</span></span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># Get the exception information using sys.exc_info()</span></span><br><span class="line">    exc_type, exc_value, exc_traceback = sys.exc_info()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Print the exception information</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exception type:&quot;</span>, exc_type)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exception value:&quot;</span>, exc_value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Traceback:&quot;</span>, exc_traceback)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">Exception type: &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span></span><br><span class="line"><span class="string">Exception value: division by zero</span></span><br><span class="line"><span class="string">Traceback: &lt;traceback object at 0x7f53a472d388&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220103799.png" alt="image-20230722010328387"></p><h2 id="help-sys"><a href="#help-sys" class="headerlink" title="help(sys)"></a>help(sys)</h2><p>该文章第三节有详细翻译：<a href="https://blog.csdn.net/qq_53568983/article/details/127252303">python之sys模块详解</a></p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> sys模块 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> python解释器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(四)控件初识</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E5%9B%9B)%E6%8E%A7%E4%BB%B6%E5%88%9D%E8%AF%86/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E5%9B%9B)%E6%8E%A7%E4%BB%B6%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="控件初识"><a href="#控件初识" class="headerlink" title="控件初识"></a>控件初识</h1><p><a href="https://doc.qt.io/qtforpython-6/modules.html">Qt for Python官方文档</a></p><p>本章对名字作简单介绍，后续解释其中重要控件的用法。</p><h2 id="所有控件"><a href="#所有控件" class="headerlink" title="所有控件"></a>所有控件</h2><p>根据Qt Designer左侧边栏顺序</p><h3 id="布局管理——Layouts"><a href="#布局管理——Layouts" class="headerlink" title="布局管理——Layouts"></a>布局管理——Layouts</h3><ul><li>VerticalLayout：垂直布局</li><li>HorizontalLayout：水平布局</li><li>GridLayout：网格布局</li><li>FormLayout：表单布局</li></ul><h3 id="弹簧——Spacers"><a href="#弹簧——Spacers" class="headerlink" title="弹簧——Spacers"></a>弹簧——Spacers</h3><ul><li>HorizontalSpacer：水平弹簧</li><li>VerticalSpacer：垂直弹簧</li></ul><h3 id="按钮类——Buttons"><a href="#按钮类——Buttons" class="headerlink" title="按钮类——Buttons"></a>按钮类——Buttons</h3><ul><li>PushButton：按钮</li><li>ToolButton：工具按钮</li><li>RadioButton：单选按钮</li><li>CheckBox：复选框</li><li>CommandLinkButton：命令链接按钮</li><li>DialogButtonBox：对话框按钮盒</li></ul><h3 id="项目视图——Item-Views-Model-Based"><a href="#项目视图——Item-Views-Model-Based" class="headerlink" title="项目视图——Item Views(Model-Based)"></a>项目视图——Item Views(Model-Based)</h3><ul><li>ListView：列表视图</li><li>TreeView：树视图</li><li>TableView：表格视图</li><li>ColumnView：列视图</li><li>UndoView：撤销命令显示视图</li></ul><h3 id="项目控件——Item-Widget-item-Based"><a href="#项目控件——Item-Widget-item-Based" class="headerlink" title="项目控件——Item Widget(item-Based)"></a>项目控件——Item Widget(item-Based)</h3><ul><li><p>ListWidget：列表控件</p></li><li><p>TreeWidget：树控件</p></li><li><p>TableWidget：表格控件</p></li></ul><h3 id="容器——Containers"><a href="#容器——Containers" class="headerlink" title="容器——Containers"></a>容器——Containers</h3><ul><li>GroupBox：分组框</li><li>ScrollArea：滚动区域</li><li>ToolBox：工具箱</li><li>TabWidget：选项卡</li><li>StackedWidget：堆栈窗口</li><li>Frame：帧</li><li>Widget：小部件</li><li>MDIArea：MDI区域</li><li>Dock Widget：停靠窗口</li></ul><h3 id="输入控件——Input-Widgets"><a href="#输入控件——Input-Widgets" class="headerlink" title="输入控件——Input Widgets"></a>输入控件——Input Widgets</h3><ul><li>ComboBox：下拉组合框</li><li>FontComboBox：字体组合框</li><li>LineEdit：单行文本框</li><li>TextEdit：多行文本框</li><li>PlainTextEdit：纯文本编辑框</li><li>SpinBow：数字选择控件</li><li>DoubleSpinBox：小数选择控件</li><li>TimeEdit：时间编辑框</li><li>DateEdit：日期编辑框</li><li>DateTimeEdit：日期时间编辑框</li><li>Dial：旋钮</li><li>HorizontalScrollBar：横向滚动条</li><li>VerticalScrollBar：垂直滚动条</li><li>HorizontalSlider：横向滑块</li><li>VerticalSlider：垂直滑块</li><li>KeySequenceEdit：按键编辑框</li></ul><h3 id="显示控件——Display-Widgets"><a href="#显示控件——Display-Widgets" class="headerlink" title="显示控件——Display Widgets"></a>显示控件——Display Widgets</h3><ul><li>Label：标签控件</li><li>TextBrowser：文本浏览器</li><li>GraphicsView：图形视图</li><li>CalendarWidget：日期控件</li><li>LCDNumber：液晶数字显示</li><li>ProgressBar：进度条</li><li>HorizontalLine：水平线</li><li>VerticalLine：垂直线</li><li>OpenGLWidget：开放式图形库工具</li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><table><thead><tr><th>Label</th><th>lab</th></tr></thead><tbody><tr><td>LineEdit</td><td>ledit</td></tr><tr><td>TextEdit</td><td>tedit</td></tr><tr><td>PlainTextEdit</td><td>pedit</td></tr><tr><td>TextBrowser</td><td>txt</td></tr><tr><td>PushButton</td><td>pbtn</td></tr><tr><td>ToolButton</td><td>tbtn</td></tr><tr><td>CommandLinkButton</td><td>linbtn</td></tr><tr><td>RadioButton</td><td>rbtn</td></tr><tr><td>CheckBox</td><td>ckbox</td></tr><tr><td>ComboBox</td><td>cbox</td></tr><tr><td>ListView</td><td>lv</td></tr><tr><td>ListWidget</td><td>lw</td></tr><tr><td>TreeView</td><td>tv</td></tr><tr><td>TreeWidget</td><td>tw</td></tr><tr><td>TableView</td><td>tbw</td></tr><tr><td>GroupBox</td><td>gbox</td></tr><tr><td>SpinBox</td><td>sbox</td></tr><tr><td>TabWidget</td><td>tab</td></tr><tr><td>TimeEdit</td><td>time</td></tr><tr><td>DateEdit</td><td>date</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 控件初识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(三)Helloworld界面</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%89)Helloworld%E7%95%8C%E9%9D%A2/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%89)Helloworld%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手写界面"><a href="#手写界面" class="headerlink" title="手写界面"></a>手写界面</h1><p><a href="https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QApplication.html#more">官方文档</a></p><ol><li>导入PySide6</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QWidget, QApplication</span><br></pre></td></tr></table></figure><p>PySide6有三个重要的模块，QtWidgets, QtGui和QtCore</p><p>QtWidgets模块就是组件类，我们用到的组件基本都在这里。</p><ol start="2"><li>实例化QApplication类</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = QApplication(sys.argv)</span><br><span class="line"><span class="comment">#sys.argv里面保存了命令行参数，这样做的目的是允许在命令行中传递一些参数给应用程序，以便进行自定义设置或功能。</span></span><br><span class="line"><span class="comment">#也可以用空列表代替</span></span><br></pre></td></tr></table></figure><p>QApplication用于管理应用程序的整个生命周期和事件循环。作用是处理小部件特定的初始化、完成、执行事件处理等。</p><ol start="3"><li>设计hello world界面</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window = QWidget()<span class="comment">#创建窗口</span></span><br><span class="line">label = QLabel(window)<span class="comment">#在窗口创建一个Label标签</span></span><br><span class="line">label.setText(<span class="string">&#x27;Hello World!&#x27;</span>)<span class="comment">#将标签内容设置为&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>显示界面并启动循环</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.show()<span class="comment">#显示window</span></span><br><span class="line">sys.exit(app.<span class="built_in">exec</span>())<span class="comment">#启动事件循环，sys.exit方法确保一个干净的退出。环境将被告知应用程序如何结束。</span></span><br></pre></td></tr></table></figure><h1 id="QtDesigner导入ui文件"><a href="#QtDesigner导入ui文件" class="headerlink" title="QtDesigner导入ui文件"></a>QtDesigner导入ui文件</h1><ol><li>Qt Designer中设计界面</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220224991.png" alt="image-20230722022429855"></p><ol start="2"><li>保存.ui文件</li></ol><p>和其他软件一样，左上角保存，保存路径最好和程序在一个地方。</p><ol start="3"><li>代码</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QWidget, QApplication</span><br><span class="line"><span class="keyword">from</span> PySide6.QtUiTools <span class="keyword">import</span> QUiLoader</span><br><span class="line"></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line"></span><br><span class="line">ui = QUiLoader().load(<span class="string">&#x27;../ui/helloworld.ui&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ui.show()</span><br><span class="line"></span><br><span class="line">sys.exit(app.<span class="built_in">exec</span>())</span><br></pre></td></tr></table></figure><ol start="4"><li><em>导入.ui文件</em></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui = QUiLoader().load(<span class="string">&#x27;../ui/helloworld.ui&#x27;</span>)</span><br><span class="line"><span class="comment">#ui就是之前的window，只不过含义区别，之后的ui.show()说明一样。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> Helloworld界面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(二)初识Qt Designer</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%88%9D%E8%AF%86Qt%20Designer/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%88%9D%E8%AF%86Qt%20Designer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><p>更新日志</p><ul><li>2023&#x2F;7&#x2F;18创建，介绍QtDesigner开发界面的使用</li></ul><h1 id="Pyqt教程-二-初识Qt-Designer"><a href="#Pyqt教程-二-初识Qt-Designer" class="headerlink" title="Pyqt教程(二)初识Qt Designer"></a>Pyqt教程(二)初识Qt Designer</h1><h2 id="新建窗体"><a href="#新建窗体" class="headerlink" title="新建窗体"></a>新建窗体</h2><p>第一次进入Qt Designer，都会要求你新建一个窗体，这和编程中的新建项目一样。界面如下：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182213027.png" alt="image-20230718221311272"></p><ul><li><p>templates\forms：模板\窗体</p><p>窗体模板主要分为三类：Main Window、Widget、Dialog。</p><p>其中Main Window提供了一个有菜单栏的工具窗口，Widget是所有界面的基类，QDialog派生自QWidget，是顶级窗口，功能也最基础。Main Window功能最全。详细进阶内容：<a href="https://blog.csdn.net/fuyuyf/article/details/126050729">widget，dialog和mainwindow</a></p></li></ul><p>Main Window：主窗口，有个菜单栏，可以显示菜单，工具栏，状态栏，托盘等功能</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182225983.png" alt="Main Window" style="zoom:50%;" /><p>Widget：小部件，单独一个窗体</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182226470.png" alt="Widget" style="zoom:75%;" /><p>Dialog：对话框，顾名思义，就是弹窗，提醒你确定&#x2F;取消。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182230237.png" alt="image-20230718223031237" style="zoom:80%;" /><h2 id="Qt-Designer设计界面"><a href="#Qt-Designer设计界面" class="headerlink" title="Qt Designer设计界面"></a>Qt Designer设计界面</h2><p>新建Main window窗体后如图，左侧边栏Widget Box是部件，例如使用button按钮，只需要单击拖拽到MainWindow窗体中。中间就是你设计的窗体模样。右侧边栏是对象查看器，你在里边选用的所有部件，包括窗体，都是对象，点击对应对象，就能在下面的属性查看器中，查看该对象的属性，在这里你可以随意修改，例如调整大小、改变颜色等等，甚至还有该对象的继承内容，例如QMainWindow继承了QWidget，QWidget又继承了QObject。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182217739.png" alt="image-20230718221728649"></p><p>顶部菜单栏就不做多介绍，与其他软件类似，需要注意的是，信号与槽的相关内容在之后的章节。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182246233.png" alt="image-20230718224647031"></p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><ul><li><strong>保存为 .ui文件</strong></li></ul><p>Ctrl+S就能保存为 .ui 文件，保存路径最好为Project—&gt;ui目录下，方便调用。设置为 .ui 文件的好处是前后端分离，不会有很多重复性代码，而且界面方便、直观。</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><ul><li><strong>通过 .ui 文件初始化导入(动态加载ui文件)</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from PySide2.QtWidgets</span><br><span class="line">import * from PySide2.QtUiTools</span><br><span class="line">import QUiLoader</span><br><span class="line"></span><br><span class="line">app = QApplication([])</span><br><span class="line"></span><br><span class="line">ui = QUiLoader().load(&#x27;ui/untitled.ui&#x27;)</span><br><span class="line">ui.show()</span><br><span class="line"></span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h2 id="将-ui转化为-py代码"><a href="#将-ui转化为-py代码" class="headerlink" title="将.ui转化为.py代码"></a>将.ui转化为.py代码</h2><ol><li>设置pyuic</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220304080.png" alt="image-20230722030431636"></p><ul><li>Program：<code>E:\python\python\python.exe （你的python文件路径）</code></li><li>Arguments：<code>-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py</code></li><li>Working directory：<code>$FileDir$</code></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220305740.png" alt="image-20230722030509739"></p><ol start="2"><li>右键External Tools，选择PyUIC</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220307706.png" alt="image-20230722030736816"></p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 初识Qt Designer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt5教程(一)学习路线</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%80)%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%80)%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><blockquote><p>更新日志</p><ul><li>2023&#x2F;7&#x2F;18创建，介绍Pyside2和Pyqt5的相关内容</li><li></li></ul></blockquote><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307181944356.png" alt="image-20230718194443789"></p><h2 id="章节内容"><a href="#章节内容" class="headerlink" title="章节内容"></a>章节内容</h2><ul><li><p><input disabled="" type="checkbox"> 第一章 学习路线</p><p>本节中包括的内容有，Python图形界面几种方案，Pyqt、Pyside2介绍以及安装，Qt Designer的安装和配置</p></li><li><p><input disabled="" type="checkbox"> 第二章 初识Qt Designer</p><p>Qt Designer是通过UI进行界面设计的工具，该节会介绍基本使用方法</p></li></ul><h2 id="Python图形界面开发的几种方案"><a href="#Python图形界面开发的几种方案" class="headerlink" title="Python图形界面开发的几种方案"></a>Python图形界面开发的几种方案</h2><p>如果用python语音开发跨平台的图形界面的程序，主要有三种：</p><p><strong>1、</strong>Tkinter</p><p>基于Tk的python库，优点是作为python标准库、稳定、发布程序较小，缺点是控件相对较少</p><p><strong>2、</strong>wxPython</p><p>基于wxWidgets的python库，优点是控件比较丰富，缺点是稳定性相对差、文档少、用户少</p><p><strong>3、</strong>PySide2、PyQt5</p><p>基于Qt的python库，优点是控件比较丰富、跨平台体验好、文档完善、用户多缺点是库比较大</p><h2 id="Pyside2、PyQt简介"><a href="#Pyside2、PyQt简介" class="headerlink" title="Pyside2、PyQt简介"></a>Pyside2、PyQt简介</h2><blockquote><p>PySide2、PyQt5 都是基于著名的 Qt 库。</p><p>Qt库里面有非常强大的图形界面开发库，但是Qt库是C++语言开发的，PySide2、PyQt5可以让我们通过Python语言使用Qt。</p></blockquote><ul><li><p>PySide2、PyQt5 这两者有什么区别？</p><p>Pyside2是Qt5开发而来，Pyqt5同样也是由Qt5，但Pyqt5曾经由其他公司开发，之后才被收购为义子，不过在协议上，Pyqt使用了商业和GPL许可证。商业许可可以购买，用于闭源应用程序。GPL许可证允许免费使用，但要求在应用程序中开放源代码。PySide由Qt公司开发，使用了LGPL许可证，允许用于商业闭源应用程序。所以Pyside2和Pyqt5的使用上几乎没有区别。</p><p>PyQt拥有全面的文档和丰富的社区支持。由于其商业许可证的存在，提供更深入的技术支持和示例代码。相比之下，PySide的文档相对较少，并且社区支持相对较少。</p></li></ul><p>在代码风格、导入方式、类和模块名称等方面，PyQt与PySide存在一些不同。PyQt采用类似于C++的风格，而PySide更贴近Pythonic风格。这些差异对于一些特定的用法和迁移代码可能会产生一些影响。已经在使用 PyQt5 的朋友不要皱眉， 两个库的使用对程序员来说，差别很小：它们的调用接口几乎一模一样。如果你的程序是PyQt5开发的，通常只要略作修改，比如把导入的名字从 PyQt5 换成 PySide2 就行了。反之亦然。</p><h2 id="Pyside6介绍"><a href="#Pyside6介绍" class="headerlink" title="Pyside6介绍"></a>Pyside6介绍</h2><p>Pyside6是由C++的Qt6开发而来，同样的，也存在Pyqt6。该公司从Pyside2直接跳到了Pyside6，也就是说从PySide6开始，PySide的命名也会与Qt的大版本号保持一致。</p><p>只需要注意一点，使用PySide6开发的程序在默认情况下不兼容Windows7系统，这也是Qt6所决定的（即使是C++的QT6也不支持windows7）。</p><p>内容取自<a href="https://blog.csdn.net/qianbin3200896/article/details/126947934">PySide6精简教程</a></p><h2 id="Pyside安装"><a href="#Pyside安装" class="headerlink" title="Pyside安装"></a>Pyside安装</h2><p>直接执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install pyside2</span><br><span class="line"></span><br><span class="line">可以指定安装源</span><br><span class="line">pip install pyside2 -i https://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line">#PySide6安装</span><br><span class="line">pip install pyside6 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="PyQt5和Qt-Designer安装"><a href="#PyQt5和Qt-Designer安装" class="headerlink" title="PyQt5和Qt Designer安装"></a>PyQt5和Qt Designer安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br><span class="line">#可同时安装 PyQt5 和 一些重要的工具，比如 Qt designer</span><br><span class="line"></span><br><span class="line">可以指定安装源</span><br><span class="line">pip install PyQt5-tools -i https://pypi.douban.com/simple</span><br><span class="line"></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt6</span><br></pre></td></tr></table></figure><h2 id="Qt-Designer配置使用"><a href="#Qt-Designer配置使用" class="headerlink" title="Qt Designer配置使用"></a>Qt Designer配置使用</h2><ul><li><strong>将QtDesinger集成到Pycharm</strong></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182020782.png"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182021219.png"></p><ul><li><strong>通过安装路径手动打开QtDesinger</strong></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182021828.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用qq昵称给消息加后缀</title>
      <link href="/2023/07/15/%E5%88%A9%E7%94%A8qq%E6%98%B5%E7%A7%B0%E7%BB%99%E6%B6%88%E6%81%AF%E5%8A%A0%E5%90%8E%E7%BC%80/"/>
      <url>/2023/07/15/%E5%88%A9%E7%94%A8qq%E6%98%B5%E7%A7%B0%E7%BB%99%E6%B6%88%E6%81%AF%E5%8A%A0%E5%90%8E%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="利用qq昵称给消息加后缀"><a href="#利用qq昵称给消息加后缀" class="headerlink" title="利用qq昵称给消息加后缀"></a>利用qq昵称给消息加后缀</h1><blockquote><p>日志</p><ul><li>初次发布：2020-04-02</li></ul><p>利用RLO和LRO修改qq昵称，达到给消息加后缀的效果。</p><ul><li>方法失效：2023年左右</li></ul><p>qq昵称不在支持上面的方法，无法保存修改后的昵称</p><ul><li>更新方法：2023-07-15</li></ul><p>利用RLI和LRI，但仅支持符号，文字不在支持，可以用颜文字做后缀</p></blockquote><blockquote><p>只有手机端显示有特殊效果，电脑没有</p></blockquote><h2 id="利用RLO和LRO修改qq昵称"><a href="#利用RLO和LRO修改qq昵称" class="headerlink" title="利用RLO和LRO修改qq昵称"></a>利用RLO和LRO修改qq昵称</h2><p>视频链接: <a href="https://www.bilibili.com/video/BV1Qc41187jM">利用qq昵称给你的消息加特效</a></p><p><strong>该方法已经失效</strong></p><h2 id="利用RLE和LRE修改qq昵称"><a href="#利用RLE和LRE修改qq昵称" class="headerlink" title="利用RLE和LRE修改qq昵称"></a>利用RLE和LRE修改qq昵称</h2><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><ol><li>打开记事本，输入昵称</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150141899.png" alt="image-20230715014114413"></p><ol start="2"><li>右键RLE，反向输入颜文字，例如?_?（显示Unicode控制字符可以打开）</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150145756.png" alt="image-20230715014555162"></p><p>效果如图：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150150982.png" alt="image-20230715015011075"></p><ol start="3"><li>确保光标位置正确，右键LRE，粘贴即可</li></ol><p>上一个步骤完成后，我们可以粘贴到我的群昵称看一下，出现下面效果说明成功（手机接收）</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150157127.jpg"></p><blockquote><p>PS：asd是我发的消息</p></blockquote><p>看似成功了，但“：”在发的消息“asd”后，所以要进行第三步，<strong>易错！！！</strong></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150201441.png" alt="image-20230715020133572"></p><p>单击箭头处，确保光标在这个位置，<strong>轻轻按一下右方向键</strong>，光标没有向右一格，证明位置是对的，这时候右键插入LRE或LRO，如果光标移动到末尾，说明成功，粘贴复制即可完成。(可以再按一下方向键，这时候如果右移一格，则再按左方向键退回去，不要问为什么，我也不知道，试出来的)</p><p>结果如下：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150211762.jpg"></p><blockquote><p>“你在干神魔”是我发的消息</p></blockquote><h2 id="复杂非对称后缀"><a href="#复杂非对称后缀" class="headerlink" title="复杂非对称后缀"></a>复杂非对称后缀</h2><blockquote><p>以该表情为例＼(&#96;Δ’)／</p></blockquote><p>按以上步骤结果为：(演示有点小瑕疵，不太影响结果)</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150238503.png" alt="image-20230715023807954"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150223404.jpg"></p><p>可以看到表情反向了，所以在输入的时候要反着来</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150233317.png" alt="image-20230715023346531"></p><p>这样结果就是完美的。</p><h2 id="消息反转"><a href="#消息反转" class="headerlink" title="消息反转"></a>消息反转</h2><p>以前是可以的，现在不行</p><p>反转就是发一句“你好”，就会变成“好你”，这就是消息反转</p><p>原理是通过仅右键插入RLO字符，不做其他操作，但由于qq不再能粘贴带有RLO控制字符的文字，所以已经失效。</p><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol><li>自问：有的颜文字为什么不行？</li></ol><p>目前颜文字中，带有汉字、字母和一些特别的符号都是不适用的，需要注意。但好在常见中文符号和英文符号是没问题的，足以支撑大部分颜文字。</p><p>其他问题评论区可以提问</p>]]></content>
      
      
      <categories>
          
          <category> 有趣的发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qq消息 </tag>
            
            <tag> 后缀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github使用技巧</title>
      <link href="/2023/07/10/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/07/10/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、在项目地址前加上gitpod.io&#x2F;#&#x2F;前缀</p><ul><li>会在一个网页板vs中加载，并且自动识别项目类型、使用技术，自动安装依赖包，直接可以在上面操作。</li></ul><p>2、高级搜索</p><p>3、查找文件</p><ul><li><ul><li>在主页按“t”：查找文件</li></ul></li><li><ul><li>点进源代码后，按“l”：跳转到某一行</li></ul></li><li><ul><li>点击行号：</li></ul></li><li><ul><li><ul><li>复制这行代码</li></ul></li><li><ul><li>生成永久链接</li></ul></li></ul></li></ul><p>源代码中按“b”：查看文件的改动记录</p><p>键盘快捷键：<a href="https://blog.csdn.net/ONLYSRY/article/details/124753220">https://blog.csdn.net/ONLYSRY/article/details/124753220</a></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 使用技巧 </tag>
            
            <tag> 使用教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识</title>
      <link href="/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络基础知识"><a href="#计算机网络基础知识" class="headerlink" title="计算机网络基础知识"></a>计算机网络基础知识</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><p><input checked="" disabled="" type="checkbox"> 什么是因特网？</p><ul><li>从因特网构成角度：它是一个互联了全世界数十亿计算机设备的网络。这些设备被称为<strong>主机</strong>或<strong>端系统</strong>。<ul><li>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起</li><li>分组交换机中最著名的两种类型是<strong>路由器</strong>和<strong>链路交换机</strong></li><li>端系统通过<strong>因特网服务提供商</strong>接入因特网</li><li><strong>协议</strong>控制因特网信息的接收和发送</li></ul></li><li>从为应用程序提供基础设施服务角度：<ul><li>套接字接口(socket interface)是一种端系统之间交付数据的方式，类似邮件要写清地址。</li></ul></li></ul></li><li><p><input checked="" disabled="" type="checkbox"> 什么是协议？</p><p>协议定义了两个通信实体之间交换的报文的格式和顺序，以及报文发送或接收一条报文或其他事件所采取的动作。</p></li></ul><h2 id="计算机网络的部件"><a href="#计算机网络的部件" class="headerlink" title="计算机网络的部件"></a>计算机网络的部件</h2><ul><li><p>端系统包括桌面计算机、服务器和移动计算机等。</p></li><li><p>主机被划分为客户(client)和服务器(server)</p></li><li><p><input checked="" disabled="" type="checkbox"> 什么是接入网？</p><p>将端系统物理连接到<strong>边缘路由器</strong>的网络称为接入网。边缘路由器是通信路径上的第一台路由器。</p></li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="TCP五层模型"><a href="#TCP五层模型" class="headerlink" title="TCP五层模型"></a>TCP五层模型</h3><ol><li><p>应用层</p><ul><li>HTTP：Web文档请求和传送</li><li>SMTP：电子邮件报文的传输</li><li>FTP：两个端系统间的文件传送</li><li>DNS：用于域名解析，将域名转换为IP地址</li></ul></li><li><p>运输层</p><blockquote><p>提供端到端的数据传输服务。</p><p>它为应用程序提供了可靠、流畅的数据传输服务，并在网络传输过程中保证数据的正确性和可靠性。</p></blockquote><ul><li>TCP：传输控制协议，可靠的、面向连接的数据传输服务。它将数据分割成报文段，并提供流量控制、拥塞控制、序号管理和重传机制等功能。</li><li>UDP：用户数据报协议，无连接的数据传输服务，它不保证数据传输的正确性和可靠性，但具有快速、轻量的优点，常用于实现音频、视频和网络游戏等实时应用。</li></ul></li><li><p>网络层</p><blockquote><p>负责将称为<strong>数据报</strong>的网络层分组从一台主机移动到另一台主机。</p></blockquote><ul><li>IP：互联网协议，定义数据报中各字段的作用</li><li>ARP：地址解析协议</li><li>RARP：逆地址解析协议</li></ul></li><li><p>链路层</p><blockquote><p>负责在相邻节点间传送数据帧，并提供一些错误监测和矫正功能。</p></blockquote><ul><li>Ethernet：以太网协议</li><li>Wi-Fi：无线协议</li></ul></li><li><p>物理层</p><blockquote><p>负责在物理媒介上传输比特流。</p></blockquote></li></ol><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><blockquote><p>应用层、表示层、会话层、运输层、网络层、数据链路层、物理层</p></blockquote><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307091857461.png" alt="image-20230622212604893"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307091857774.png" alt="image-20230622212652909"></p>]]></content>
      
      
      <categories>
          
          <category> web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问网站背后过程</title>
      <link href="/2023/07/09/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E8%83%8C%E5%90%8E%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/07/09/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E8%83%8C%E5%90%8E%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="访问网站背后过程"><a href="#访问网站背后过程" class="headerlink" title="访问网站背后过程"></a>访问网站背后过程</h1><blockquote><p>解释访问过程之前，首先要了解<strong>计算机网络的基础知识</strong>和<strong>网站部署过程</strong></p></blockquote><h2 id="计算机网络基础知识"><a href="#计算机网络基础知识" class="headerlink" title="计算机网络基础知识"></a>计算机网络基础知识</h2><p>主要了解TCP五层模型：<a href="/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="计算机网络基础知识">相关文章链接，点击这里</a></p><h2 id="网站是如何部署的？"><a href="#网站是如何部署的？" class="headerlink" title="网站是如何部署的？"></a>网站是如何部署的？</h2><ol><li>准备服务器：首先，需要选择一个安全可靠的服务器，购买服务器的空间，包括服务器类型、带宽、存储空间和机房等。</li><li>配置环境：安装服务器所需的操作系统、Web 服务器（如Apache、Nginx等）和数据库（如MySQL、PostgreSQL、MongoDB等）等必要组件，配置相关的服务。</li><li>部署代码：将编写好的网站代码上传至服务器，通过Web服务器将代码部署到服务器上。此时，通常需要将网站的<strong>域名</strong>和<strong>IP地址</strong>绑定，使访问该域名的用户能够正确访问该网站。</li><li>域名购买和解析：在国内购买域名，并在 DNS 解析商处将域名解析到服务器的 IP 地址上。</li><li>网站备案：在国内部署网站，需要进行备案手续，主要包括备案材料的准备以及在当地官方网站进行系统备案。</li><li>数据库配置：如果网站使用了数据库，将需要创建网站对应的数据库、配置数据库连接和数据表等基础操作。</li><li>调试：部署完成后，需要进行测试和调试，包括测试网站在不同浏览器下的兼容性、测试代码的漏洞和安全性、测试服务器的稳定性和性能等等。</li></ol><h2 id="网站的访问过程经历哪些步骤"><a href="#网站的访问过程经历哪些步骤" class="headerlink" title="网站的访问过程经历哪些步骤"></a>网站的访问过程经历哪些步骤</h2><h3 id="DNS域名解析协议"><a href="#DNS域名解析协议" class="headerlink" title="DNS域名解析协议"></a>DNS域名解析协议</h3><blockquote><p>将域名解析为ip地址。</p></blockquote><ul><li><input disabled="" type="checkbox"> 什么是DNS？<ul><li>一个由分层的DNS服务器实现的分布式数据库</li><li>一个使得主机能够查询分布式数据库的应用层协议</li></ul></li></ul><p>DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP和FTP，</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="C:\Users\神殒魔灭\AppData\Roaming\Typora\typora-user-images\image-20230624000722342.png" alt="image-20230624000722342"></p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><blockquote><p>这个请求中包含了请求的方式（GET或POST）、请求头（告诉服务器浏览器的类型、支持的压缩格式等信息）和请求体（如果是POST请求，将提交数据）。</p></blockquote><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><blockquote><p>一旦服务器收到请求，它会进行处理并返回响应。响应也包含了HTTP状态码（如200表示成功，404表示未找到页面等）和响应头（如服务器类型、响应时间和数据类型等信息）。</p></blockquote><h3 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h3><blockquote><p> 一旦浏览器收到响应，它会对响应进行处理和解析，并将结果渲染在用户界面中。</p></blockquote><h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><blockquote><p>一旦所有数据都传输完毕，浏览器会关闭TCP连接，释放资源，此时用户与服务器的通信就结束了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云OSS+PicGO图床教程</title>
      <link href="/2023/07/07/%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/07/07/%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><h2 id="什么是图床？"><a href="#什么是图床？" class="headerlink" title="什么是图床？"></a>什么是图床？</h2><blockquote><p>图床简单来说就是在云端用来储存图片的空间。实际上图床是个服务器，它能把你的图片存储进去，提供url供人访问。</p></blockquote><p>国内图床也分为单线空间、多线空间和cdn加速三种。</p><h2 id="为什么需要图床？"><a href="#为什么需要图床？" class="headerlink" title="为什么需要图床？"></a>为什么需要图床？</h2><p>从写博客的角度：markdown文章中的图片一般存放在本地的文件夹中，在本地访问可以根据绝对路径和相对路径找到图片，但如果上传到网络上，本地路径就无法被直接识别，需要将其打包放到服务器中，但是图片太多不仅会占用空间，还会增加图片访问的压力。而图床等采用<strong>分布式存储</strong>和<strong>CDN加速</strong>，能提供稳定和快速的图片访问体验。</p><p>从其他角度：存储在云端比本地安全性更高(只要服务提供商不倒闭)，能随时随地供任何人访问，节省本地空间。</p><h2 id="如何使用图床？"><a href="#如何使用图床？" class="headerlink" title="如何使用图床？"></a>如何使用图床？</h2><ul><li>阿里云OSS(对象存储服务)</li></ul><blockquote><p>阿里云对象存储服务相当于数据库，用来存放图片的服务器，也就是图床</p></blockquote><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071210488.png" alt="image-20230707121030448"></p><ul><li>PicGO</li></ul><p>picgo是个图形化界面程度，方便上传和查看图片</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071208899.png" alt="image-20230707120802360"></p><ul><li>Typora</li></ul><p>markdown编辑器，可以调整配置，使其自动上传到图床</p><p>具体教程：<a href="https://zhuanlan.zhihu.com/p/573215104">知乎图床教程</a></p><h2 id="主要出现的Bug"><a href="#主要出现的Bug" class="headerlink" title="主要出现的Bug"></a>主要出现的Bug</h2><h3 id="PicGo报错"><a href="#PicGo报错" class="headerlink" title="PicGo报错"></a>PicGo报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2023-07-02 01:10:14 [PicGo ERROR] &#123;</span><br><span class="line">  &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https://sm.ms/api/v2/upload&quot;,</span><br><span class="line">  &quot;statusCode&quot;: 0,</span><br><span class="line">  &quot;message&quot;: &quot;connect ETIMEDOUT 46.82.174.69:443&quot;,</span><br><span class="line">  &quot;stack&quot;: &quot;Error: connect ETIMEDOUT 46.82.174.69:443\n    at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1146:16)&quot;,</span><br><span class="line">  &quot;response&quot;: &#123;</span><br><span class="line">    &quot;status&quot;: 0,</span><br><span class="line">    &quot;statusCode&quot;: 0,</span><br><span class="line">    &quot;body&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>不知道什么问题，在PicGo设置默认图床就好了</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307020140230.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云OSS </tag>
            
            <tag> 图床 </tag>
            
            <tag> PicGO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子坟墓 赛博墓碑</title>
      <link href="/2023/07/06/%E8%B5%9B%E5%8D%9A%E5%9D%9F%E5%A2%93%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/07/06/%E8%B5%9B%E5%8D%9A%E5%9D%9F%E5%A2%93%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="电子坟墓-赛博墓碑"><a href="#电子坟墓-赛博墓碑" class="headerlink" title="电子坟墓-赛博墓碑"></a>电子坟墓-赛博墓碑</h1><h2 id="想法起源"><a href="#想法起源" class="headerlink" title="想法起源"></a>想法起源</h2><p>此想法起源于b站弹幕，经常有人在精彩视频里面发送弹幕，“做成二维码刻在墓碑上”，就像有趣的墓志铭一样。当然这是一句玩笑话，并不现实，因为墓碑主要用来总结一生，或者这一生的高光经历。</p><p>人的一生很长，墓碑能记录的东西很少，在人生的不同阶段会发生很多有纪念意义的事情。事实上，对于我个人来说，我非常渴望能把我这一生的大小事情都记录下来，而且目前使用网络来记录也比较方便，例如vlog、文章和照片，这也是我写博客的原因。</p><p>墓文和博客却又不一样，博客记录大大小小的事情，而墓文总结人生的一个阶段。在我的认为中，人们都希望有或者说需要有总结一段人生的需求，就像大多数人喜欢做年末总结一样。此外，人们也渴望在死后能有更丰富更清晰的人生结语，而不是墓碑上简简单单的几句话。</p><p>现实中的墓碑显然不能满足这个需求，甚至土葬也在渐渐消失。但网络能满足这种需求，甚至还能网上扫墓（XD），唯一缺失的，可能是在祖祠祭拜先人的仪式感，这确实少了很多文化韵味。但仔细想想，两者也不冲突，祠堂是给后辈祭拜的，电子坟墓是给他人观看并丰富生平，两者可以认为是互补的关系。而且电子坟墓活人也在用，祠堂可不能祭拜活人(dog)。</p><h3 id="对比印证"><a href="#对比印证" class="headerlink" title="对比印证"></a>对比印证</h3><h4 id="数字墓碑"><a href="#数字墓碑" class="headerlink" title="数字墓碑"></a>数字墓碑</h4><blockquote><p>虽然国内外都存在数字墓碑，但完全是两个不同的东西。</p></blockquote><p>国外存在类似的数字墓碑，就是将墓碑上放一个电子大屏，并且提供链接，通过网站得到更详细的内容，目的是为了展示更多生平经历。</p><p><a href="https://www.kankanews.com/detail/7my5RMjz0Q9">新闻：斯洛文尼亚出现世界首座数字化墓碑 未来殡葬业的趋势？</a></p><p>缺点：</p><ul><li>贵：电费、维护费都不是一般人能承受</li><li>电子屏无太大意义：和博物馆一样的模式，但博物馆展览面向游客，游客群体本就是带有观看目的，个人墓碑对于他人来说，看不看都无所谓，不如改成二维码，直接让想观看的人通过网站浏览</li><li>没有社群：如果观看的人只有路过的行人，实在没必要做这些。所以为了让更多人看，最好有社群，哪怕是弄个公墓将所有墓碑数字化，都能吸引人观看。当然最好还是建立网上社群，这样会有更多人观看。（这点说的不清楚，看完全文或许你会懂）</li></ul><p>国内的数字墓碑出现比较靠后，因为土葬、海葬之类的，要么有政府的政策，要么太贵，所以有些公司提供了数字墓碑服务(也挺贵)，具体如下链接，吐槽太多了。</p><p><a href="https://baijiahao.baidu.com/s?id=1762310709894768361&wfr=spider&for=pc">北京首推数字科技殡葬：占地小，祭扫不用到现场，有人提前为自己做电子墓碑</a></p><p>缺点(太多槽点了)：</p><ul><li>给你做个电子屏，然后整个生平视频放上，里面存骨灰，没什么太大意义</li><li>一块小电子屏展示东西也没多少，视频天天播放也不智能，还费电，如果做个巨长的视频，说不定自己的后人都懒得看完，这点还要看国外，弄个网站用文字记录会更好，还能被其他人观看。</li><li>看完介绍我只想说冤大头 XD</li></ul><h2 id="后续设想"><a href="#后续设想" class="headerlink" title="后续设想"></a>后续设想</h2><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>首先要用到地图，坟墓通常和家乡位置关系密切，电子坟墓必须也和现实一样，有一个“下葬点”。点击就能跳转到个人坟墓中。</p><p>坟墓包含的因素：</p><ul><li>周边环境：图片、3D、背景图</li><li>坟包：坟头草、冒青烟之类的，XD</li><li>墓碑：允许个人创作<ul><li>个人信息：姓名、出生及死亡年月（隐藏：照片、性别、身份证号）</li><li>墓志铭&amp;生平简介：墓志铭是个有趣的东西，保留。活人可以把生平改成自我介绍，死后变为生平简介。</li><li>二维码&amp;链接：存放视频、图片、网站，用于更详细的人生经历。</li><li>其他阶段：墓碑可以有多个阶段，按时间例如0-12岁、12-18岁等，埋葬过去，也可以描述不同的自己，例如工作、家庭、情感。</li></ul></li><li>评论区：浏览交互是构建这个墓群社区的重点</li></ul><h2 id="盈利"><a href="#盈利" class="headerlink" title="盈利"></a>盈利</h2><p>做服务还得盈利，不然网站倒闭啥都没</p><ul><li><p>坟墓可以买出价格，必须便宜，如果不能有足够的用户，根本活不了，而且不能做位置限制，出现炒地皮那种，因为哪块地理位置好，被人全包然后倒卖，与身份证绑定最好</p></li><li><p>其他在其他服务我们可以提供一些进阶内容，比如坟墓样式的定制，买断等等</p></li><li><p>提供交易，收取手续费</p></li></ul><p>盈利方式选择很多，我就少说点我的智障想法吧，评论区可以留言说说想法。</p><h2 id="难点痛点"><a href="#难点痛点" class="headerlink" title="难点痛点"></a>难点痛点</h2><p>本质上，该想法有一部分原因，是用来解决现实中坟墓太贵和土地紧张的问题，重点在于人们愿不愿意接受这种形式。让人们彻底抛弃实体坟墓，拥抱虚拟坟墓，这非常困难，原因很简单，谁也不想来这世间一趟，什么痕迹都没留下，而人死后，最能留下、而且最能代表自身的东西就是坟墓了，所以不让大家下葬立坟，这点根本是无法接受。</p><p>所以本质上，人只是想留下自己存在过的证明，留下被后人或他人铭记的东西，电子坟墓当然不能完全满足这一点，但它满足了墓碑，满足了墓碑记录自己生平的需求。对比火葬和土葬，如果不是有限制，多数人更希望土葬，谁不想死后有片大点的地方供后人祭拜，有块墓碑记录自己的生平，相比在小小的骨灰盒，那多气派。</p><p>而赛博墓碑，首先生平记录能更多，其次在社群中，他人也能看到自己的坟墓，留下留言，坟墓上即使是虚拟的，我们也可以弄得很华丽，留言得到很多人的关注，同样是一种气派。代替了这么多内容，最后也就剩一个后人祭拜的意义了，这点对于人来说，棺材还是骨灰盒都一样了。</p>]]></content>
      
      
      <categories>
          
          <category> 想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> 想法 </tag>
            
            <tag> 电子坟墓 </tag>
            
            <tag> 赛博墓碑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo教程(一)搭建初始博客</title>
      <link href="/2023/07/01/Hexo%E6%95%99%E7%A8%8B(%E4%B8%80)%E6%90%AD%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/07/01/Hexo%E6%95%99%E7%A8%8B(%E4%B8%80)%E6%90%AD%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo教程–搭建初始博客"><a href="#Hexo教程–搭建初始博客" class="headerlink" title="Hexo教程–搭建初始博客"></a>Hexo教程–搭建初始博客</h1><h2 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><h2 id="搭建blog步骤"><a href="#搭建blog步骤" class="headerlink" title="搭建blog步骤"></a>搭建blog步骤</h2><h3 id="安装node-js-npm-hexo"><a href="#安装node-js-npm-hexo" class="headerlink" title="安装node.js\npm\hexo"></a>安装node.js\npm\hexo</h3><h3 id="用hexo创建初始页面"><a href="#用hexo创建初始页面" class="headerlink" title="用hexo创建初始页面"></a>用hexo创建初始页面</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一个博客文件夹</span><br><span class="line">mkdir D:/blog</span><br><span class="line">键入初始化命令</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>输入命令后blog文件夹中会生成以下内容</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071239600.png" alt="image-20230626083925791"></p><p>键入命令<code>hexo generate</code> ，生成静态页面文件</p><p>本地启动Hexo服务器，进行预览调试，键入命令：<code>hexo server</code></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071239480.png" alt="image-20230626103840220"></p><h3 id="在GitHub上部署"><a href="#在GitHub上部署" class="headerlink" title="在GitHub上部署"></a>在GitHub上部署</h3><ul><li><p>在github上创建一个新项目，命名必须规范shenyunmomie.github.io</p></li><li><p>在博客文件夹安装hexo-deployer-git自动部署发布工具</p><p><code>npm install hexo-deployer-git  --save</code></p></li><li><p>修改_config.yml文件</p></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071239351.png" alt="image-20230626185859658"></p><ul><li><p>部署到远端GitHub</p><p><code>hexo d</code></p><blockquote><p>部署到远端时候，有时候会被墙，显示超时连接，就连科学上网也不总是管用，可以等一会多试几次</p></blockquote></li><li><p>访问博客网站</p><p><code>https://shenyunmomie.github.io/</code></p></li></ul><h2 id="theme更换主题"><a href="#theme更换主题" class="headerlink" title="theme更换主题"></a>theme更换主题</h2><p><strong>以butterfly主题为例</strong></p><ul><li><p>首先去官网查看教程</p><p><code>https://butterfly.js.org/</code></p></li><li><p>clone主题butterfly到theme目录</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240662.png" alt="image-20230628092154279"></p><p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p></li><li><p>修改配置文件，更换应用主题</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240846.png" alt="image-20230628092302611"></p></li><li><p>安装渲染插件，如果没有界面只有文字显示</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240620.png" alt="image-20230628092350862"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也可以单独安装</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure></li><li><p>PS：建议</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240560.png" alt="image-20230628092518530"></p></li><li><p>将博客重新部署到远端，访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240839.png" alt="image-20230628092652068"></p></li></ul><h2 id="Hexo使用命令"><a href="#Hexo使用命令" class="headerlink" title="Hexo使用命令"></a>Hexo使用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新建文章</span><br><span class="line">hexo n &quot;第一篇文章&quot;</span><br><span class="line"></span><br><span class="line">新建后需要hexo g重新生成</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>部署的时候如果报错</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071241682.png" alt="image-20230707124141060"></p><p>先登录GitHub(二选一)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global      user.email &quot;18731548870@163.com&quot;</span><br><span class="line"></span><br><span class="line">git config --global      user.name &quot;shenyunmomie&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>RLI我也没找到，待验证</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150322376.png" alt="image-20230715032217193"></p>]]></content>
      
      
      <categories>
          
          <category> 学习教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo教程(二)博客写作</title>
      <link href="/2023/06/28/Hexo%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"/>
      <url>/2023/06/28/Hexo%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Hexo-Butterfly主题界面"><a href="#Hexo-Butterfly主题界面" class="headerlink" title="Hexo|Butterfly主题界面"></a>Hexo|Butterfly主题界面</h1><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><blockquote><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个別文档的变量。</p></blockquote><h3 id="Page-Front-matter-用于页面配置"><a href="#Page-Front-matter-用于页面配置" class="headerlink" title="Page Front-matter 用于页面配置"></a>Page Front-matter 用于页面配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">*title:</span> <span class="string">页面标题</span></span><br><span class="line"><span class="string">*date:</span> <span class="string">页面创建日期</span></span><br><span class="line"><span class="attr">updated:</span> <span class="string">页面更新日期</span></span><br><span class="line"><span class="string">*type:</span> <span class="string">标签、分类和友情连接三个页面需要配置</span></span><br><span class="line"><span class="attr">comments:</span> <span class="string">显示页面评论模块</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">页面描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">页面关键字</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">页面顶部图片</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="string">显示mathjax</span></span><br><span class="line"><span class="attr">katex:</span> <span class="string">显示katex</span></span><br><span class="line"><span class="attr">aside:</span> <span class="string">显示侧边栏</span></span><br><span class="line"><span class="attr">aplayer:</span> <span class="string">在需要的页面加载aplayer的js和css</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="string">配置代码框是否展开</span></span><br><span class="line"><span class="attr">random:</span> <span class="string">配置友情连接是否随机排序</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="Post-Front-matter用于文章页配置"><a href="#Post-Front-matter用于文章页配置" class="headerlink" title="Post Front-matter用于文章页配置"></a>Post Front-matter用于文章页配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">abcjs:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="写作技巧"><a href="#写作技巧" class="headerlink" title="写作技巧"></a>写作技巧</h2><h3 id="标签插件的原理"><a href="#标签插件的原理" class="headerlink" title="标签插件的原理"></a>标签插件的原理</h3><blockquote><p>本文写作技巧是指，在编写文章时，我们有时候需要引用其他文章，或是使用md文件中未提供的语法。</p></blockquote><p>你所记录的markdown文章，在网页端是以html格式呈现的，这点可以在网站中右键–&gt;检查，进入开发者窗口验证。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307092023198.png" alt="image-20230709202301577"></p><p>所以在md文件–&gt;html网页过程中，我们可以通过添加代码，来实现markdown语法中不提供的功能，例如hexo提供了**标签插件(Tag Plugins)**，举例说明此服务的原理：</p><p>我们知道，markdown语法是不支持插入视频的，最多通过网页链接实现，而通过标签插件，我们可以在md文件中添加</p><p><code>&#123;% youtube video_id [type] [cookie] %&#125;</code></p><ul><li>youtube：表示从YouTube网站拿取视频</li><li>video_id：youtube网站的视频号</li><li>type：‘playlist’，播放列表，video_id有多个视频号时(猜的)</li><li>cookie：boolean值，表禁用YouTube的cookie(不知道干嘛的)</li></ul><p>hexo看到md文件中的<code>&#123;%%&#125;</code>，就知道要做什么，会自动插入相关前端代码，在浏览器中展示到用户面前，效果类似下图：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307092046315.png" alt="image-20230709204630898"></p><blockquote><p>markdown语法是允许直接添加html代码的，不过hexo为避免其他因素的影响，也提供了raw语法。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="code">&lt;html代码&gt;</span></span><br><span class="line"><span class="code">&#123;% endraw %&#125;</span></span><br></pre></td></tr></table></figure><p>所以标签插件本质上可以理解为，就是添加了些前端代码，用来实现某些功能。</p><h3 id="官方文档内容一览"><a href="#官方文档内容一览" class="headerlink" title="官方文档内容一览"></a>官方文档内容一览</h3><p><a href="https://hexo.io/zh-cn/docs/writing">hexo官方文档</a></p><p>主要内容大纲：</p><ul><li><p>写作</p><ul><li>布局(Layout)：标明是哪种页面，例如post(文章页)、draft(草稿页)、page(导航标签页)和tag(标签页)等等，hexo g时候会渲染成对应页面。theme主题会提供更多Layout。详细文章：<a href="https://www.jianshu.com/p/5a1e6d8c83af">初步了解Hexo站点的布局</a></li><li>模板(Scaffold)：文章需要预设置Front-matter，模板就是提前设置好，新建时直接拿用。</li></ul></li><li><p>Front-matter</p><ul><li><p>官方文档和主题文档都有介绍</p></li><li><p>分类和标签</p><p><strong>分类方法的误区</strong>：分类具有顺序性和层次性，Hexo 不支持指定多个同级分类。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Life</span></span><br><span class="line"><span class="comment"># 分类Life是Diary的子分类，而不是并列分类。</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">PlayStation</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">Games</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Life</span>]</span><br><span class="line"><span class="comment"># PlayStation和Games分别都是父分类Diary的子分类，同时Life是一个没有子分类的分类。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>标签插件</p><ul><li>大概浏览一遍，记下有需要的即可</li><li>插入图片，能调整大小<code>&#123;% asset_img [class类名] 路径 [width] [height] %&#125;</code></li></ul></li><li><p>资源文件夹</p><ul><li>用处不大，说的是创建文章时，可以自动创建一个新文件夹用来储存&amp;调用。我图片一般用图床，很少存储到本地，这会出现一些不方便的问题。</li></ul></li><li><p>数据文件夹</p><ul><li><p>在写md文章时，假设我有一份人员名单文件(数据文件,YAML 或 JSON 格式)，我想在md文章中打印出来，除了复制粘贴，我们可以用脚本片段代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> (<span class="keyword">var</span> link <span class="keyword">in</span> site.<span class="property">data</span>.文件名) &#123; %&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= site.data.文件名[link] %&gt;&quot;</span>&gt;</span> &lt;%= link %&gt; <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"># data为数据文件夹</span><br></pre></td></tr></table></figure></li></ul></li><li><p>服务器</p><ul><li>hexo server相关内容，过一遍即可</li></ul></li><li><p>生成器</p><ul><li>hexo generate相关命令，看看即可</li></ul></li><li><p>辅助函数</p><ul><li>和前端知识相关性较大，属于进阶知识</li></ul></li><li><p>插件</p><ul><li>需要自己写一些插件时，可以仔细看看。详细教程：<a href="https://www.ngui.cc/el/558918.html?action=onClick">Hexo高级教程之插件开发</a></li></ul></li><li><p>主题、模板、变量都需要了解</p><ul><li>更多相关教程：<a href="https://www.bilibili.com/read/cv5778979/">hexo主题开发</a></li></ul></li></ul><p><a href="https://butterfly.js.org/posts/21cfbf15/">butterfly主题官方文档</a>，内容较多，需一步步按照自己喜欢的样式修改，这里提几个关键内容：</p><ul><li>Butterfly 安裝文檔(二) 主題頁面<ul><li>标签页</li><li>分类页</li><li>友情链接</li></ul></li><li>Butterfly 安裝文檔(三) 主題配置-1<ul><li>标签外挂的用法</li></ul></li><li>Butterfly 安裝文檔(四) 主題配置-2<ul><li>搜索</li><li>评论</li><li>inject</li></ul></li><li>Butterfly 安裝文檔(六) 進階教程<ul><li>Icon</li></ul></li></ul><h3 id="在文章中引用另一篇文章"><a href="#在文章中引用另一篇文章" class="headerlink" title="在文章中引用另一篇文章"></a>在文章中引用另一篇文章</h3><h4 id="markdown语法引用链接"><a href="#markdown语法引用链接" class="headerlink" title="markdown语法引用链接"></a>markdown语法引用链接</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">文字标题</span>](<span class="link">url链接</span>)</span><br></pre></td></tr></table></figure><p>该方法优点是方便，缺点是url链接容易改变，因为博客中文章的链接通常是http:&#x2F;&#x2F;***&#x2F;2023&#x2F;06&#x2F;28&#x2F;Hexo教程(二)博客写作，如果更改date和title，该链接就失效了，所以用下面的方法会更好。</p><h4 id="标签插件方法"><a href="#标签插件方法" class="headerlink" title="标签插件方法"></a>标签插件方法</h4><blockquote><p>虽然可以直接写入文章最终<strong>链接</strong>的方法引用，但是如果原本的文章链接变化了，就不能使用了，所以最好的方法就是在生成系统之内直接引用。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_path filename %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% post_</span>link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Front-matter </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
