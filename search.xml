<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pyqt案例(二)语音测试工具</title>
      <link href="/2023/08/16/Pyqt%E6%A1%88%E4%BE%8B(%E4%BA%8C)%E8%AF%AD%E9%9F%B3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/08/16/Pyqt%E6%A1%88%E4%BE%8B(%E4%BA%8C)%E8%AF%AD%E9%9F%B3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="语音测试工具"><a href="#语音测试工具" class="headerlink" title="语音测试工具"></a>语音测试工具</h1><blockquote><p>代码文件：<a href="https://github.com/shenyunmomie/AudioReceptionTester">我的github</a></p></blockquote><h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202308122343690.png" alt="photo"></p><ul><li><p>两大测试场景</p><ul><li><p>唤醒测试</p><p>只播放唤醒语音，判断设备是否被唤醒</p></li><li><p>识别测试</p><p>播放唤醒语音和识别语音，判断设备识别内容是否正确</p></li></ul></li><li><p>三个连接方式</p><ul><li><p>adb_wifi</p><p>adb无线连接，通过<code>adb connect IP地址</code>命令实现。</p></li><li><p>adb</p><p>adb有线连接，通过usb接口与设备物理连接</p></li><li><p>serial</p><p>serial串口连接，同样通过usb接口与设备物理连接，与adb区别是设备提供接口协议不同</p></li></ul></li></ul><table><thead><tr><th>输入字段</th><th>唤醒</th><th>识别</th></tr></thead><tbody><tr><td>语料地址(测试语音用例)</td><td>√</td><td>√</td></tr><tr><td>保存地址</td><td>√</td><td>√</td></tr><tr><td>测试数量(非随机)</td><td>√</td><td>√</td></tr><tr><td>设备日志路径</td><td>√</td><td>√</td></tr><tr><td>期望值</td><td>√</td><td></td></tr><tr><td>唤醒正则表达式</td><td>√</td><td>√</td></tr><tr><td>识别正则表达式</td><td></td><td>√</td></tr><tr><td>ip地址&#x2F;串口</td><td>√</td><td>√</td></tr><tr><td>唤醒语料地址</td><td></td><td>√</td></tr></tbody></table><p><strong>保存地址</strong>：测试会生成日志文件、结果表单和统计结果三个文件，保存地址是三个文件的存储路径</p><p><strong>设备日志路径</strong>：测试需要提取设备的日志，所以需要给出设备中的日志路径</p><p><strong>期望值</strong>：无太大作用，仅在唤醒正则表达式判断正确时，做记录使用</p><p><strong>正则表达式</strong>：提取设备日志中的关键词，用以判断唤醒和识别</p><p><strong>唤醒语料地址</strong>：识别测试使用，因为识别前需要先唤醒，最好为一个唤醒语料，控制变量</p><p><strong>输入格式</strong>：加载历史按钮有模板，可以仿照着写</p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 案例 </tag>
            
            <tag> 语音测试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyinstaller打包报错</title>
      <link href="/2023/08/14/pyinstaller%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99/"/>
      <url>/2023/08/14/pyinstaller%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Pyinstaller打包"><a href="#Pyinstaller打包" class="headerlink" title="Pyinstaller打包"></a>Pyinstaller打包</h1><h2 id="打包指令"><a href="#打包指令" class="headerlink" title="打包指令"></a>打包指令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;pyinstaller -D -w xxx.py</span><br></pre></td></tr></table></figure><h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-F</span><br><span class="line">等同于</span><br><span class="line">--onefile</span><br><span class="line"><span class="comment"># 打包为单个文件，如果项目仅为一个.py文件时可用，多个文件不可</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-D</span><br><span class="line">--onedir</span><br><span class="line"><span class="comment"># 打包为一个目录</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--key=keys</span><br><span class="line"><span class="comment"># 使用keys进行加密打包</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-w</span><br><span class="line">--windowed</span><br><span class="line">--noconsole</span><br><span class="line"><span class="comment"># 去掉控制台窗口，执行时不会启动命令行(windows系统)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c</span><br><span class="line">--console</span><br><span class="line"><span class="comment"># 打开控制台窗口，使用控制台子系统执行,当程序启动的时候会打开命令行(默认)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-i file.ico</span><br><span class="line">--icon=&lt;file.ico&gt;</span><br><span class="line"><span class="comment"># 程序的图标</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-h</span><br><span class="line">--<span class="built_in">help</span></span><br><span class="line"><span class="comment"># help查看命令</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他(不常用)</span></span><br><span class="line">-v, --version <span class="comment">#版本</span></span><br></pre></td></tr></table></figure><h2 id="打包产生的文件"><a href="#打包产生的文件" class="headerlink" title="打包产生的文件"></a>打包产生的文件</h2><h3 id="打包单文件"><a href="#打包单文件" class="headerlink" title="打包单文件"></a>打包单文件</h3><ul><li><p>exe文件</p><p>生成的可执行文件可以在 dist 文件夹中找到</p><p>包含了你的 Python 代码和所有依赖项，以便你可以在其他计算机上运行它而无需安装 Python 解释器或其他依赖库。</p><p>生成的可执行文件的名称通常与你的 Python 脚本文件的名称相同（默认情况下）</p></li></ul><h3 id="打包多文件"><a href="#打包多文件" class="headerlink" title="打包多文件"></a>打包多文件</h3><ul><li><p>build</p><p>临时文件夹，包含已经编译但尚未打包成最终可执行文件的文件和目录。在打包过程完成后，这个文件夹可以被删除，因为这些临时文件已经不再需要。</p></li><li><p>dist</p><p>最终结果文件夹。其中最重要的文件是exe或应用程序的主文件。此文件夹中的其他文件和目录可能会包含有关打包过程中使用的库、依赖项和资源的信息。</p></li><li><p>.spec</p><p>配置文件，它是一个 Python 脚本文件，用于指定打包过程的参数和选项。</p><p>如果在打包时提供了 .spec 文件，PyInstaller 将使用该文件中指定的配置进行打包，否则将使用默认配置。</p><p><code>pyinstaller yourscript.spec</code></p></li></ul><h1 id="打包环境"><a href="#打包环境" class="headerlink" title="打包环境"></a>打包环境</h1><h2 id="anaconda环境"><a href="#anaconda环境" class="headerlink" title="anaconda环境"></a>anaconda环境</h2><p>输入命令后打包报错，百度未能解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\神殒魔灭\AppData\Roaming\Python\Python39\site-packages\PyInstaller\isolated\_parent.py&quot;, line 372, in call</span><br><span class="line">    return isolated.call(function, *args, **kwargs)</span><br><span class="line">  File &quot;C:\Users\神殒魔灭\AppData\Roaming\Python\Python39\site-packages\PyInstaller\isolated\_parent.py&quot;, line 293, in call</span><br><span class="line">    ok, output = loads(b64decode(self._read_handle.readline()))</span><br><span class="line">EOFError: EOF read where object expected</span><br><span class="line"></span><br><span class="line">OSError: [Errno 22] Invalid argument</span><br></pre></td></tr></table></figure><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><p>打包成功后报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error loading Python DLL</span><br><span class="line">&#x27;D:\AudioReceptionTesterbuild\audioReceptionTester\python39.dl&#x27;.</span><br><span class="line">LoadLibrary:找不到指定的模块。</span><br></pre></td></tr></table></figure><p>这是因为程序是在anaconda环境下写的，系统环境没有下载相应模块，所以有缺失错误。</p><p>除此之外，pyinstaller会将无用的模块也导入进去，所以不推荐此打包方法。</p><h3 id="虚拟环境-anaconda-prompt"><a href="#虚拟环境-anaconda-prompt" class="headerlink" title="虚拟环境(anaconda prompt)"></a>虚拟环境(anaconda prompt)</h3><p>所谓的虚拟环境，就是创建一个没有第三方库和模块的 Python 环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda命令</span></span><br><span class="line">1、导出虚拟环境的列表</span><br><span class="line">conda env list</span><br><span class="line">2、导出当前环境的包</span><br><span class="line">conda list</span><br><span class="line">3、启动/切换至名为name的Python环境</span><br><span class="line">conda activate name</span><br><span class="line">4、退出虚拟环境</span><br><span class="line">conda deactivate</span><br><span class="line">5、创建新的、名为name的、Python版本为3.x的虚拟环境</span><br><span class="line">conda create -n name python==3.x</span><br></pre></td></tr></table></figure><p><strong>步骤：</strong></p><ol><li><p>创建虚拟环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_1 python==<span class="number">3.10</span><span class="number">.8</span></span><br><span class="line"><span class="comment"># 问你新环境是否需要安装这些包，Y确定即可</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果报错</span></span><br><span class="line">Collecting package metadata (current_repodata.json): failed</span><br><span class="line"></span><br><span class="line">UnavailableInvalidChannel: HTTP 404 NOT FOUND for channel simple &lt;https://pypi.mirrors.ustc.edu.cn/simple&gt;</span><br><span class="line"></span><br><span class="line">The channel is not accessible or is invalid.</span><br><span class="line"></span><br><span class="line">You will need to adjust your conda configuration to proceed.</span><br><span class="line">Use `conda config --show channels` to view your configuration&#x27;s current state,</span><br><span class="line">and use `conda config --show-sources` to view config file locations.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索.condarc文件删除即可</span></span><br></pre></td></tr></table></figure></li><li><p>进入虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda activate audiotool</span><br><span class="line"></span><br><span class="line">当(base) D:\AudioReceptionTester&gt;</span><br><span class="line">变成(audiotool) D:\AudioReceptionTester&gt;</span><br><span class="line">表示已经进入</span><br></pre></td></tr></table></figure></li><li><p>安装需要的第三方包</p><p>如果程序还用到了其他的第三方库，那么就需要把这些库给添加进虚拟环境，添加方式就是直接在当前环境下用 pip。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像</span></span><br><span class="line">-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">-i https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">-i https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">-i https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br></pre></td></tr></table></figure></li><li><p>更极致的exe大小</p><p>如果想让其小到不能再小，那么就要尽可能地删去虚拟环境里面的一些用不到的包（用 pip uninstall 来删）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看安装的包</span></span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装第三方包问题"><a href="#安装第三方包问题" class="headerlink" title="安装第三方包问题"></a>安装第三方包问题</h2><ul><li><p>引用与包名不一致</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：serial包</span></span><br><span class="line"><span class="comment"># 在import时就是serial</span></span><br><span class="line"><span class="comment"># 实际上pip安装的是pyserial包</span></span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line">pip install pyserial</span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:pyinstaller不会因为这个找不到模块(亲历)</span></span><br></pre></td></tr></table></figure></li><li><p>引用奇怪</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：还是serial</span></span><br><span class="line"><span class="comment"># 这次是serial.tools</span></span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line">pip install serial.tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:serial.tools会携带安装pyserial，并且该import也会把pyserial中的内容导入进去，所以只写serial.tools的import也是能够运行的</span></span><br></pre></td></tr></table></figure></li><li><p>安装一个包中附带其他包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：pandas</span></span><br><span class="line"><span class="comment"># pandas安装时候包含了numpy</span></span><br><span class="line"><span class="comment"># 如果卸载numpy，会提醒缺失moudle numpy</span></span><br></pre></td></tr></table></figure></li><li><p>内置模块不用安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举例：os, time, sys</span></span><br><span class="line"><span class="comment"># 会报错ERROR，找不到这个包</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><p>.spec文件每次打包时最好删掉</p><p>.spec文件是打包的配置文件，打包时会默认按照这个文件内容执行，如果你发现修改报错后，依然报同样的问题，请查看.spec文件是否删除。</p></li></ul><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="ModuleNotFoundError"><a href="#ModuleNotFoundError" class="headerlink" title="ModuleNotFoundError"></a>ModuleNotFoundError</h3><p>解决方法：</p><ul><li>虚拟环境没安装pyinstaller，会调用全局的，所以需要安装</li><li>即使存在pyinstaller，也可以卸载重装，我就是重装就好了，很迷，人都给我整崩溃了。</li></ul><h3 id="RuntimeError-Unable-to-open-x2F-read-ui-device"><a href="#RuntimeError-Unable-to-open-x2F-read-ui-device" class="headerlink" title="RuntimeError: Unable to open&#x2F;read ui device"></a>RuntimeError: Unable to open&#x2F;read ui device</h3><p>ui文件读取错误</p><p>解决方法：</p><ul><li>缺失资源文件，把资源文件根据你的相对路径添加到dist目录下，打包的目录中就可以了</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.taodudu.cc/news/show-5085357.html?action=onClick">用 Pyinstaller 模块将 Python 程序打包成 exe 文件（全网最全面最详细）</a></p><p><a href="https://blog.csdn.net/zhengyuyin/article/details/127800237">【环境问题】Anaconda环境下使用pyinstaller封装exe</a></p><p><a href="https://blog.csdn.net/nainaiwink/article/details/130862534">PyInstaller 中文文档</a></p><p><a href="https://blog.csdn.net/kevinshift/article/details/104880101">使用pyinstaller打包python程序</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记《你是吃出来的》</title>
      <link href="/2023/08/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%BD%A0%E6%98%AF%E5%90%83%E5%87%BA%E6%9D%A5%E7%9A%84%E3%80%8B/"/>
      <url>/2023/08/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%8A%E4%BD%A0%E6%98%AF%E5%90%83%E5%87%BA%E6%9D%A5%E7%9A%84%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="慢病时代——饮食革命带来防治新契机"><a href="#慢病时代——饮食革命带来防治新契机" class="headerlink" title="慢病时代——饮食革命带来防治新契机"></a>慢病时代——饮食革命带来防治新契机</h1><h2 id="我们活在快餐当道的世界，身体却困在了石器时代"><a href="#我们活在快餐当道的世界，身体却困在了石器时代" class="headerlink" title="我们活在快餐当道的世界，身体却困在了石器时代"></a>我们活在快餐当道的世界，身体却困在了石器时代</h2><h3 id="疾病的本质：细胞损伤速度超过修复速度"><a href="#疾病的本质：细胞损伤速度超过修复速度" class="headerlink" title="疾病的本质：细胞损伤速度超过修复速度"></a>疾病的本质：细胞损伤速度超过修复速度</h3><p>不健康的心理或者不合理的饮食、运动、睡眠等生活方式会造成细胞损伤，影响细胞修复。</p><p>很多“慢病”，如冠心病、高血压、糖尿病、肿瘤、抑郁症、气管炎、哮喘、慢性肾病等，都是由不健康的生活方式导致的。</p><p>慢病的治疗方式是对抗治疗，血压高吃降压药，血糖高了用降糖药，肿瘤长出来了切除，哮喘用抗哮喘药。这是无法治愈的，因为慢病的根本原因是长期不健康生活导致的，你更需要改变生活方式，特别是<strong>饮食</strong>，因为在细胞损伤和修复的博弈过程中，能给细胞修复提供原料的只有饮食。</p><blockquote><p>人体细胞的自我修复能力取决于两个主要因素，一个是与生俱来的细胞生命周期，另一个是后天的营养状况，即先天因素和后天因素。先天因素（细胞固有的更新周期）决定了修复速度，后天因素（营养状态）决定了修复质量。</p></blockquote><h3 id="修复细胞损伤的唯一原料：食物中的营养素"><a href="#修复细胞损伤的唯一原料：食物中的营养素" class="headerlink" title="修复细胞损伤的唯一原料：食物中的营养素"></a>修复细胞损伤的唯一原料：食物中的营养素</h3><p>七大营养素:</p><ul><li>碳水化合物（又称为糖类，包括葡萄糖、果糖、麦芽糖、淀粉等）</li><li>蛋白质（分为必需氨基酸和非必需氨基酸）</li><li>脂类（分为脂肪和类脂，脂肪又叫甘油三酯，分为必需脂肪酸和非必需脂肪酸；类脂包括磷脂、胆固醇、胆固醇脂、糖脂）</li><li>维生素（分为脂溶性维生素和水溶性维生素）</li><li>矿物质（分为常量元素和微量元素）</li><li>膳食纤维（分为可溶性膳食纤维和不可溶性膳食纤维）</li><li>水</li></ul><p>人一天营养素消耗：</p><p>一个人如果躺着不动，室温保持在20～25℃，测出来的能量消耗称为基础代谢。一般来讲，男性为1400千卡／天左右，女性在1300千卡／天左右。</p><ul><li>运动方面：运动量大家都不一样，经常运动的人和体力劳动者消耗的碳水化合物要更多一些。</li><li>心理方面：大脑消耗的营养素与肌肉消耗的营养素不一样，用脑越多越需要多补充蛋白质、维生素、矿物质，还有脂类中的胆固醇、磷脂和大家都很关注的DHA和EPA。</li><li><strong>熬夜</strong>：消耗的营养素会更多，如维生素A、维生素B族、磷脂和蛋白质等。</li><li>吸烟：需要更多的抗氧化剂来对抗尼古丁等毒素对人体的伤害。</li><li><strong>喝酒</strong>：伤肝，需要更多的营养素来修复肝脏细胞，如维生素B族和蛋白质。</li></ul><h3 id="藏在饮食中的七大营养素如何修复细胞损伤"><a href="#藏在饮食中的七大营养素如何修复细胞损伤" class="headerlink" title="藏在饮食中的七大营养素如何修复细胞损伤"></a>藏在饮食中的七大营养素如何修复细胞损伤</h3><p>七大营养素为细胞做了什么</p><ul><li>为细胞新陈代谢提供能量——主要靠碳水化合物类，也就是粮食、水果等。</li><li>为新生细胞更新提供结构原料——主要靠蛋白质类和脂类，主要存在于肉、蛋、奶、鱼中。</li><li>为新陈代谢提供媒介——蛋白质类和胆固醇类，还有维生素、矿物质。</li><li>养肠道细菌——食物中的膳食纤维。</li></ul><h2 id="防治慢病吃什么：35-动物类食物-65-植物类食物"><a href="#防治慢病吃什么：35-动物类食物-65-植物类食物" class="headerlink" title="防治慢病吃什么：35%动物类食物+65%植物类食物"></a>防治慢病吃什么：35%动物类食物+65%植物类食物</h2><p>讲述了历史时代中，人们不同的饮食习惯和生活方式比较平衡，但从工业时代开始，人工食物出现，慢病流行。这是因为人们获得食物更容易，人的体力劳动量大大降低，摄入和消耗极大不平衡。更加重要的是，化肥、催熟剂等种植方式，几乎所有食物中的营养素都在贬值。还出现了过去不存在的食物，食品安全成为重要问题。</p><p>从数万年前茹毛饮血的旧石器时代到现在，我们的基因结构和消化系统基本上没有改变，然而我们的饮食结构却有翻天覆地的变化，特别是在最近100年间。正是由于旧基因和新饮食的矛盾，造成了今天慢病的蔓延流行。</p><h3 id="缔造最强大脑和体能的完美饮食"><a href="#缔造最强大脑和体能的完美饮食" class="headerlink" title="缔造最强大脑和体能的完美饮食"></a>缔造最强大脑和体能的完美饮食</h3><p>人类进化得最快的时期，大概在距今2万～1万年前是旧石器时代向新石器时代转化。那时人们食物结构，植物性食物占65%，主要是水果、蔬菜、坚果、豆类和蜂蜜。动物性食物占35%左右，主要是肉类、蛋类、鱼和虾贝类。</p><p>总结：</p><p>第一，我们必须意识到在餐桌食品丰富的背后，我们获得的营养其实十分匮乏，食物种类太少与营养素的含量太低并存。如果我们再挑食，或者总用精米、精面把自己喂饱，就更容易出现营养不平衡。</p><p>第二，尽量摄入天然食物，动物类、植物类食物每天都要吃，注意减少加工食品摄入量。</p><p>第三，动物类食物（肉、蛋、奶、鱼等）最好占一天食物的35%。当然如果能买到散养的畜禽类动物或者禽卵更好。植物类食物包括蔬菜、水果和粮食，占一天食物的65%。蔬菜和水果种类尽量多样化，粮食类食物种类要多，以粗粮为主，如全麦类、糙米、玉米、莜麦、薯类都很好，最不好的是精米、精面，因为精米、精面是工业化的产物。</p><h2 id="防治慢病怎么吃：注重结构型营养素和营养密度"><a href="#防治慢病怎么吃：注重结构型营养素和营养密度" class="headerlink" title="防治慢病怎么吃：注重结构型营养素和营养密度"></a>防治慢病怎么吃：注重结构型营养素和营养密度</h2><blockquote><p>食物种类多不等于营养丰富</p></blockquote><p>结构物质主要指磷脂、蛋白质、胆固醇。如果这些结构性营养缺失了，细胞无法按照DNA的指令完成增生和修复，身体发育就会受到限制。</p><h3 id="结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养"><a href="#结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养" class="headerlink" title="结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养"></a>结构型营养可以变成能量原料，而能量原料未必能转化成结构型营养</h3><p>碳水化合物能转化成脂肪，脂肪也能转化成碳水化合物。蛋白质可以转化成碳水化合物。</p><p>但不是所有的蛋白质都能由碳水化合物和脂肪直接转化而来。蛋白质是由氨基酸构成的，而碳水化合物和脂肪在体内只能转化为非必需氨基酸，必需氨基酸是必须要从外界摄取的。</p><h3 id="能量原料不足，结构原料受损"><a href="#能量原料不足，结构原料受损" class="headerlink" title="能量原料不足，结构原料受损"></a>能量原料不足，结构原料受损</h3><p>营养素在细胞中的吸收和释放都是需要排队的。</p><p>碳水化合物冲在最前面，进入细胞的线粒体，直接变为能量。蛋白质和脂肪变成细胞膜的结构或者成为某些有生物活性的物质，如酶。</p><p>人饿的时候，碳水化合物先被用光，之后才是皮下脂肪和蛋白质。</p><p>人在饥饿时，以脂肪分解为主，占80%左右，蛋白质的分解约占20%</p><h3 id="最适合现代人的食物：低能量密度，高营养密度"><a href="#最适合现代人的食物：低能量密度，高营养密度" class="headerlink" title="最适合现代人的食物：低能量密度，高营养密度"></a>最适合现代人的食物：低能量密度，高营养密度</h3><p>对运动量不大的现代人来说，最好的食物选择是：低能量密度，高营养密度。如果是体力劳动者，那就要高能量密度，高营养密度。</p><p>能量密度，指的是单位体积中所含的提供给细胞的能量营养素有多少。</p><p>营养密度，指的是单位体积中所含的营养素有多少。</p><p>最符合低能量、高营养这一标准的膳食结构，就是<strong>地中海膳食结构</strong>。</p><h1 id="不生病的奥秘——七大营养素平衡"><a href="#不生病的奥秘——七大营养素平衡" class="headerlink" title="不生病的奥秘——七大营养素平衡"></a>不生病的奥秘——七大营养素平衡</h1><h2 id="能量平衡：比例合理更重要"><a href="#能量平衡：比例合理更重要" class="headerlink" title="能量平衡：比例合理更重要"></a>能量平衡：比例合理更重要</h2><p>一个人每天的能量消耗主要有以下三个方面：基础代谢、运动和食物消化。</p><ul><li>基础代谢</li></ul><p>基础代谢率就是尽量排除其他影响因素，在非常安静的环境中，在清醒的状态下，一个人的身体不受精神紧张、肌肉活动和环境温度等影响测定的代谢率。</p><p>日常生活中，基础代谢很容易受到其他因素的影响，常见的包括环境温度、激素、年龄、性别、身高和遗传等。</p><p>环境温度在20～25℃时，人的基础代谢率最低；低温和高温环境中，代谢率都会升高。现在大家长期生活在恒温房间里，能量消耗少，很容易发胖。</p><ul><li>运动</li></ul><p>整天用电脑、不出去运动的人消耗的能量要比下地的农民低很多。即便是每天出去运动，运动项目和持续时间不同，消耗的能量也会有所不同。</p><ul><li>食物消化</li></ul><p>消化食物的过程也要消耗能量，这被称作食物的动力效应。</p><p>不同营养素的动力效应是不同的。蛋白质的动力效应最大，约为30%；而碳水化合物和脂肪的动力效应较低，基本在5%左右。</p><p>例如，如果你吃进去的蛋白质热量是100千卡，消化分解自身用掉30%，实际上吸收到机体中的是70千卡。而100千卡的碳水化合物进入人体后，消化分解自身只用掉5%，吸收到身体中的是95千卡左右，脂肪也是同量。</p><blockquote><p>能量摄入的四个来源: </p></blockquote><p>在七大营养素中，有三大营养素和能量息息相关，它们分别是碳水化合物、蛋白质和脂类，被称为“产能营养素”。</p><p><strong>碳水化合物每克产生4千卡能量，蛋白质每克产生4千卡能量，脂类每克产生9千卡能量。</strong></p><p><strong>酒精，1克酒精产生7千卡能量</strong></p><blockquote><p>容易被忽视的能量失衡表现：体重正常而体脂偏高</p></blockquote><p>缺乏蛋白质，所以肌肉无力，消化能力差，睡眠不好。缺乏必需脂肪酸，所以皮肤干燥，视力很差，记忆力减退。</p><p>注意给大脑补足营养，才能有效地治疗消化不良和预防老年痴呆。</p><h3 id="能量平衡的方法因人而异"><a href="#能量平衡的方法因人而异" class="headerlink" title="能量平衡的方法因人而异"></a>能量平衡的方法因人而异</h3><p>摄入多少是根据消耗量来计算的，主要参数有以下三个：</p><p>第一，身高体重。依据标准体重计算，标准体重&#x3D;身高（厘米）－105，不管男性还是女性基本都是这样计算。</p><p>第二，活动量。一般来讲轻体力劳动是标准体重每千克耗能30千卡，中体力劳动者35千卡，重体力劳动者40千卡，长期卧床的人标准体重每千克耗能25千卡。临床上我们也不是这么绝对，比如一个轻体力劳动者，偏胖，计算能量的时候减少5千卡，为标准体重每千克耗能25千卡。</p><p>第三，三大能量之间的比例。大多数营养书上三大能量比例是蛋白质为10%～15%，脂类为20%～30%，碳水化合物为55%～65%。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 你是吃出来的 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之函数参数</title>
      <link href="/2023/08/03/python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
      <url>/2023/08/03/python%E4%B9%8B%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h1><p>形式参数：在定义函数时，函数名后面括号中的参数为“形式参数”。</p><p>实际参数：在调用一个函数时，函数名后面括号中的参数为“实际参数”，也就是将函数的调用者提供给函数的参数称为实际参数。</p><blockquote><p>实际参数的类型不同，传递参数可分为两种情况，值传递和引用传递。</p></blockquote><p>值传递：当实际参数为不可变对象时，改变形参的值，实际参数不变</p><p>引用传递：当实际参数为可变对象时，改变形参的值，实际参数改变</p><h2 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h2><p><img src="blog/source/_posts/assets/Image%20%5B6%5D.png" alt="Image [6]"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原值：&quot;</span>,obj)</span><br><span class="line">    obj+=obj</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------值传递------&quot;</span>)</span><br><span class="line">mot = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用前：&quot;</span>,mot)<span class="comment"># hello world!</span></span><br><span class="line">demo(mot)<span class="comment"># 不可变对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用后：&quot;</span>,mot)<span class="comment"># hello world!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------引用传递------&quot;</span>)</span><br><span class="line">lst = [<span class="string">&#x27;你好&#x27;</span>, <span class="string">&#x27;世界&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用前：&quot;</span>,lst)<span class="comment"># [&#x27;你好&#x27;, &#x27;世界&#x27;]</span></span><br><span class="line">demo(lst)<span class="comment"># 可变对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数调用后：&quot;</span>,lst) <span class="comment"># [&#x27;你好&#x27;, &#x27;世界&#x27;, &#x27;你好&#x27;, &#x27;世界&#x27;]</span></span><br></pre></td></tr></table></figure><h1 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h1><p>位置参数也称必备参数，是必须按照正确的顺序传到函数中，即调用时的数量和位置必须和定义时是一样的。</p><p>TypeError异常</p><ul><li><p>实际参数的类型与形式参数的类型不一致</p></li><li><ul><li>实参数量不一致</li><li>类型位置与定义不一致</li></ul></li></ul><h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>关键字参数是指使用形式参数的名字来确定输入的参数值，位置不必完全一种</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 函数操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之字符串</title>
      <link href="/2023/08/03/python%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/08/03/python%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>lower()</td><td>全部转换为小写</td><td>仅限于A-Z</td></tr><tr><td>upper()</td><td>全部转换为大写</td><td>仅限于A-Z</td></tr><tr><td>title()</td><td>每个单词的第一个字母大写</td><td></td></tr><tr><td>capitalize()</td><td>字符串的第一个字母大写</td><td></td></tr><tr><td>swapcase()</td><td>大写小写颠倒</td><td></td></tr><tr><td>casefold()</td><td>全部转换为小写</td><td>更广泛的字符转换</td></tr></tbody></table><h2 id="检查字符"><a href="#检查字符" class="headerlink" title="检查字符"></a>检查字符</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>islower()</td><td>检查字母字符是否都是小写</td><td></td></tr><tr><td>isupper()</td><td>检查字母字符是否都是大写</td><td></td></tr><tr><td>istitle()</td><td>检查首字母是否大写</td><td></td></tr><tr><td>isdigit()</td><td>检查字符串中是否全为数字</td><td></td></tr><tr><td>isalpha()</td><td>检查字符串中是否全为字母</td><td></td></tr><tr><td>isspace()</td><td>检查字符串中是否有空格</td><td></td></tr><tr><td>isalnum()</td><td>检查字符串是否由字母和数字组成</td><td>单字母数字都可以，空字符串不行</td></tr><tr><td>isdecimal()</td><td>检查字符串是否只包含十进制字符</td><td></td></tr><tr><td>inumeric()</td><td>检查字符串是否全为数字</td><td>只适用于Unicode对象，可以判断中文数字</td></tr><tr><td>isprintable()</td><td>检查字符串中是否有打印后不可见的内容</td><td>如\n、\t</td></tr></tbody></table><h2 id="判断字符"><a href="#判断字符" class="headerlink" title="判断字符"></a>判断字符</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>startswith()</td><td>判断字符串是否以指定前缀开始</td><td>有start、end参数可在指定范围判断</td></tr><tr><td>endswith()</td><td>判断字符串是否以指定后缀结尾</td><td>有start、end参数可在指定范围判断</td></tr><tr><td>isidentifier()</td><td>判断str是否是有效的标识符</td><td></td></tr></tbody></table><h2 id="查询字符"><a href="#查询字符" class="headerlink" title="查询字符"></a>查询字符</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>count()</td><td>查询子字符串出现次数</td><td></td></tr><tr><td>find()</td><td>查询子字符串第一次出现位置，返回索引</td><td>不存在返回-1</td></tr><tr><td>rfind()</td><td>查询子字符串最后一次出现位置，返回索引</td><td>不存在返回-1</td></tr><tr><td>index()</td><td>查询子字符串第一次出现位置，返回索引</td><td>不存在引发异常</td></tr><tr><td>rindex()</td><td>查询子字符串最后一次出现位置，返回索引</td><td>不存在引发异常</td></tr></tbody></table><h2 id="格式变换"><a href="#格式变换" class="headerlink" title="格式变换"></a>格式变换</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>join()</td><td>以字符串为间隔，将可迭代对象中的元素连接</td><td></td></tr><tr><td>split()</td><td>以指定字符串为分隔符，拆分成列表</td><td></td></tr><tr><td>splitlines()</td><td>将字符串按照行(\n、\r)拆分成列表</td><td></td></tr><tr><td>partition()</td><td>指定分隔符(sep)将字符串进行分割</td><td>从左边开始</td></tr><tr><td>rpartition()</td><td>指定分隔符(sep)将字符串进行分割</td><td>从右边开始</td></tr></tbody></table><h2 id="修改替换"><a href="#修改替换" class="headerlink" title="修改替换"></a>修改替换</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>replace()</td><td>指定字符串，用另一个字符串替代</td><td>默认替换全部，也可用count参数指定次数</td></tr><tr><td>expandtabs()</td><td>将字符串中的 \t 替换为一定数量的空格</td><td></td></tr></tbody></table><h2 id="填充修减"><a href="#填充修减" class="headerlink" title="填充修减"></a>填充修减</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>strip()</td><td>去除字符串开头和结尾处指定的字符</td><td>默认为空格</td></tr><tr><td>lstirp()</td><td>去除字符串左边的空格或指定字符</td><td>默认为空格</td></tr><tr><td>rstirp()</td><td>去除字符串末尾的指定字符</td><td>默认为空格</td></tr><tr><td>center()</td><td>返回一个长度为width,两边用fillchar(单字符)填充的字符串，即字符串str居中，两边用fillchar填充。</td><td>若字符串的长度大于width,则直接返回字符串str。</td></tr><tr><td>ljust()</td><td>返回一个原字符串左对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串</td><td>若，直接返回字符串str。</td></tr><tr><td>rjust()</td><td>返回一个原字符串右对齐,并使用fillchar填充(默认为空格)至指定长度的新字符串</td><td>若，直接返回字符串str。</td></tr><tr><td>zfill()</td><td>返回指定长度的字符串，使原字符串右对齐，前面用0填充到指定字符串长度</td><td>若，直接返回字符串str。指定长度不能为空</td></tr></tbody></table><h2 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>encode()</td><td>指定的编码格式编码字符串，默认编码为 ‘utf-8’</td><td></td></tr><tr><td>decode()</td><td>以 encoding 指定的编码格式解码字符串，默认编码为字符串编码。</td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#str.encode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;)</span></span><br><span class="line"><span class="string">&quot;我爱祖国&quot;</span>.encode(encoding=<span class="string">&quot;utf8&quot;</span>,errors=<span class="string">&quot;strict&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xe6\x88\x91\xe7\x88\xb1\xe7\xa5\x96\xe5\x9b\xbd&#x27;</span></span><br><span class="line"><span class="string">&quot;I love my country&quot;</span>.encode(encoding=<span class="string">&quot;utf8&quot;</span>,errors=<span class="string">&quot;strict&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;I love my country&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#str.decode(encoding=&#x27;utf-8&#x27;, errors=&#x27;strict&#x27;)</span></span><br><span class="line">str1 = <span class="string">&quot;我爱学习&quot;</span>.encode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xe6\x88\x91\xe7\x88\xb1\xe5\xad\xa6\xe4\xb9\xa0&#x27;</span></span><br><span class="line">str1.decode(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="string">&#x27;我爱学习&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>format()</td><td>在字符串中使用{}作为占位符，占位符的内容将引用format()中的参数进行替换</td><td></td></tr><tr><td>format_map()</td><td>返回字符串的格式化版本</td><td>仅使用于字符串格式中可变数据参数来源于字典等映射关系数据</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;john&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">33</span>&#125;</span><br><span class="line"><span class="string">&quot;My name is &#123;name&#125;,iam&#123;age&#125; old&quot;</span>.format_map(People)</span><br></pre></td></tr></table></figure><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td>maketrans()</td><td>制作翻译表，删除表</td><td></td></tr><tr><td>translate()</td><td>过滤(删除)，翻译字符串</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之魔术方法</title>
      <link href="/2023/07/29/Python%E4%B9%8B%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/29/Python%E4%B9%8B%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="什么是魔术方法"><a href="#什么是魔术方法" class="headerlink" title="什么是魔术方法"></a>什么是魔术方法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>魔术方法，官方名称是special methods，因为带有双下划线，又被称为dunder methods双下划线方法。</p></blockquote><p>当我们创建一个自定义类时，往往需要控制这个类的行为和操作。通过定义和实现这些魔术方法，我们可以在自定义类中实现类似于内置类型的行为和功能，使得我们的类更加灵活和易于使用。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>__init__</code>用于在创建对象时进行初始化操作。它在对象创建之后立即被调用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">person1 = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(person1.name)  <span class="comment"># 输出：Alice</span></span><br><span class="line"><span class="built_in">print</span>(person1.age)  <span class="comment"># 输出：25</span></span><br></pre></td></tr></table></figure><p><code>__init__</code>方法的第一个参数通常被命名为self，它代表正在被创建的对象自身。接下来的参数表示我们在创建对象时传递的参数。通过这些传递的参数，我们可以在初始化方法中对对象的属性进行赋值。</p><h1 id="魔术方法类别"><a href="#魔术方法类别" class="headerlink" title="魔术方法类别"></a>魔术方法类别</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><table><thead><tr><th>符号</th><th>方法</th><th>tips</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td><code>__eq__</code></td><td>equal，无定义时，默认使用is逻辑。</td></tr><tr><td>!&#x3D;</td><td><code>__ne__</code></td><td>not equal，无定义时，把eq函数取反</td></tr><tr><td>&gt;</td><td><code>__gt__</code></td><td>greater than，无定义时，取反、报错</td></tr><tr><td>&lt;</td><td><code>__lt__</code></td><td>less than，无定义时，取反、报错</td></tr><tr><td>&gt;&#x3D;</td><td><code>__ge__</code></td><td>greater equal，无定义时，取反、报错</td></tr><tr><td>&lt;&#x3D;</td><td><code>__le__</code></td><td>less equal，无定义时，取反、报错</td></tr></tbody></table><ol><li><p>取反，当&#x3D;&#x3D;方法被定义，而!&#x3D;方法没有定义时，调用!&#x3D;方法，会使用&#x3D;&#x3D;方法，并将结果取反。其他同理。</p></li><li><p>一般情况下，当符号是&lt;时，调用<code>__lt__</code>方法，但也有例外，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, year, month, date</span>):</span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> self.year &lt; other.year:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.year == other.year:</span><br><span class="line">            <span class="keyword">if</span> self.month &lt; other.month:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> self.month == other.month:</span><br><span class="line">                <span class="keyword">return</span> self.day &lt; other.day</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewDate</span>(<span class="title class_ inherited__">Date</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">date1 = Date(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">date2 = NewDate(<span class="number">2023</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(date1 &lt; date2)</span><br><span class="line"><span class="comment"># 正常情况下，date1.__lt__(date2),调用lt函数，但这里的date2是子类，因为有可能被重写，所以实际上调用的是date2.__gt__(date1)</span></span><br><span class="line"><span class="comment"># 这里的规则是，两边是不同类且是衍生类关系，首先使用衍生类的方法。两边是不同类且无衍生关系的时候，我们首先使用左边类的方法，如果左边没有lt方法，则将date1 &lt; date2，视为date2 &gt; date1，调用date2的gt方法，如果这两者都没有，就会报错，python认为两边没有定义date1 &lt; date2的比较逻辑，不可比较。</span></span><br></pre></td></tr></table></figure></li><li><p>&lt;&#x3D;方法不等于&lt;和&#x3D;&#x3D;方法，即使写了后两者，没写前者也用不了&lt;&#x3D;方法。</p></li><li><p>hash值，当我们自定义一个数据结构时，是有默认的<code>__hash__</code>方法的，如果我们定义了<code>__eq__</code>函数，那么默认的hash方法会被删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解释一下hash函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先hash函数有关于可变对象和不可变对象</span></span><br><span class="line"><span class="comment"># 如果一个对象是不可变的，那么它的__hash__()方法应该返回一个固定的哈希值，并且__eq__()方法应该比较对象的内容来判断相等性。</span></span><br><span class="line"><span class="comment"># 如果一个对象是可变的，那么它的__hash__()方法通常不会被实现（默认返回None），并且对象的相等性比较通常会比较对象的身份（即id()）而不是内容。</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="comment"># int类型是不可变对象，所以a is b结果为true，这里不要认为a、b是两个不同的对象，因为在编程中，a和b都是引用，指向同一块内存。hash值用来标识唯一数据对象，a和b都是同一块内存，输入相同，输出的hash值也一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的数据对象例如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>():</span><br><span class="line">    ...</span><br><span class="line">date1 = Date(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">date2 = Date(<span class="number">2022</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># date1 is date2的时候就会返回False，因为两个变量指向的是两块不同的内存。得出的hash值也不同。</span></span><br><span class="line"><span class="comment"># 当定义了__eq__方法，hash方法就不存在，从常理来讲，我们认为date1和date2相等，是因为两个变量都指向2022/10/1这个日期，所以自定义的Date类型应该和int类型一样，都是不可变对象，但由于是自定义对象，date1和date2实际上是指向两块不同的内存，而hash值是确保对象的唯一标识的手段，也就是说，如果两个对象的哈希值不同，那么它们的对象肯定不相等。但如果两个对象的哈希值相同，系统会继续比较它们的值或调用 __eq__() 方法来确定它们是否相等。</span></span><br><span class="line"><span class="comment"># 这就好比两个双胞胎，明明是两个不同的肉体(内存)，却有着一样的外形(eq)，你分辨不出，所以你通过名字标识了他们(hash)，你就能知道是两个不同的个体。如果是两个名字一样的人(hash相同)，但是外形不同(eq)，那么你也知道是两个人。hash帮助了你在分别见到双胞胎的时候，叫名字不至于认错，这就是唯一标识。唯一标识的作用下面解释。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用处</span></span><br><span class="line"><span class="comment"># 在字典中，key值必须唯一，不能重复，这是为了快速索引。但Date创建的date1和date2对象是个双胞胎，如果在字典中：</span></span><br><span class="line">income = &#123;&#125;<span class="comment"># 收入</span></span><br><span class="line">income[date1] = <span class="number">100</span></span><br><span class="line">income[date2] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(income)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;&#123;2022/10/1: 100, 2022/10/1: 100&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 但我们要的是一个date</span></span><br><span class="line"><span class="comment"># 所以可以在Date类中定义hash和eq方法，系统就会知道他俩相等。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.year == other.year <span class="keyword">and</span> self.month == other.month <span class="keyword">and</span> self.day == other.day</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span><span class="comment">#例子，别学</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;&#123;2022/10/1: 100&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 这样就标识了2022/10/1这个日期是唯一的，日期就是不可变对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line"><span class="comment"># 对于不可变对象（如整数、浮点数、字符串和元组），它们的哈希值是在对象创建时计算并保存的，因为它们的值是不可变的。这使得它们的哈希值唯一性和稳定性得到了保证。</span></span><br><span class="line"><span class="comment"># 对于可变对象（如列表、集合和字典），由于其值可以进行修改，因此在对象创建后即使不同的修改操作会改变其哈希值，因此可变对象默认是不可哈希的，即不能被用作字典的键或集合的元素。</span></span><br><span class="line"><span class="comment"># 尽管可变对象默认是不可哈希的，但可以通过自定义对象的 __hash__() 方法来使可变对象变为可哈希的。但一旦对象是可哈希的，并且作为字典键或集合元素使用时，就不应该再修改该对象的值，因为修改后会破坏数据结构的一致性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hash函数要求</span></span><br><span class="line"><span class="comment"># 必须返回一个整数</span></span><br><span class="line"><span class="comment"># 两个对象相等的时候，hash值必须相等</span></span><br><span class="line"><span class="comment"># 官方推荐写法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">hash</span>((self.year,self.month,self.day))</span><br></pre></td></tr></table></figure></li></ol><h2 id="对象表示"><a href="#对象表示" class="headerlink" title="对象表示"></a>对象表示</h2><table><thead><tr><th>方法</th><th>tips</th></tr></thead><tbody><tr><td><code>__str__(self)</code></td><td>返回对象的字符串表示</td></tr><tr><td><code>__repr__(self)</code></td><td>represent，返回对象的可打印字符串表示</td></tr></tbody></table><p>区别：</p><p>str面向用户，要求可读性好。repr面向的是python的解释器，或者说开发人员，用来重新获得该对象，将对象转化为供解释器读取的形式。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制类的字符串形式，使用 str() 返回一个描述性好的字符串</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制类的字符串形式，使用 repr() 返回一个准确可重建对象的字符串</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Point 对象</span></span><br><span class="line">p1 = Point(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(p1))    <span class="comment"># 输出：Point(3, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 repr() 获取对象的字符串形式</span></span><br><span class="line">repr_str = <span class="built_in">repr</span>(p1)</span><br><span class="line"><span class="built_in">print</span>(repr_str)</span><br><span class="line"><span class="comment"># 使用 eval() 重新创建相同的对象</span></span><br><span class="line">p2 = <span class="built_in">eval</span>(repr_str)</span><br><span class="line"><span class="comment"># eval会把字符串当作代码运行</span></span><br><span class="line">p3 = <span class="built_in">eval</span>(<span class="string">&#x27;Point(3,5)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p2)<span class="comment"># 输出：Point(3, 5)</span></span><br><span class="line"><span class="built_in">print</span>(p3)<span class="comment"># 输出：Point(3, 5)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td><code>__getattr__(self,name)</code></td><td>访问对象某个属性不存在时，做的处理</td><td>不存在指getattribute方法返回值没有</td></tr><tr><td><code>__getattribute__(self,name)</code></td><td>访问对象属性存在时，返回属性值</td><td>可以加一写其他操作，注意递归</td></tr><tr><td><code>__setattr__(self,name,val)</code></td><td>设置一个对象属性</td><td>无</td></tr><tr><td><code>__delattr__(self,name)</code></td><td>del o.data对象属性时被调用</td><td>对象删除时并不会调用</td></tr><tr><td><code>__dir__(self)</code></td><td>打印可访问的属性和方法</td><td>必须返回sequence</td></tr></tbody></table><ul><li><code>__getattr__(self,name)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="comment"># 处理不存在的属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;The attribute &#x27;<span class="subst">&#123;attr&#125;</span>&#x27; does not exist.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Person 对象</span></span><br><span class="line">person = Person(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问已经存在的属性</span></span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># 输出：John</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问不存在的属性</span></span><br><span class="line"><span class="built_in">print</span>(person.age)  <span class="comment"># 输出：The attribute &#x27;age&#x27; does not exist.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>__getattribute__(self,name)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data = <span class="string">&quot;abc&quot;</span></span><br><span class="line">        self.counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;data&quot;</span>:</span><br><span class="line">            self.counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__getattribute__(name) <span class="comment">#getattr(self,name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># self.counter += 1实际上也是再访问a中的属性，所以会产生递归。</span></span><br><span class="line"><span class="comment"># return super().__getattribute__(name)是为了返回属性值，如果写成self.name又会触发递归，所以调用父类的getattribute方法，虽然A()没有表明继承，但实际上是有父类的，我们的getattribute实际上重写，父类的getattritubr方法就只是单纯返回属性调用，return属性值。</span></span><br><span class="line"><span class="comment"># getattr(self,name)，该方法不是调用的__getattr__，而是先调用__getattritube__方法，如果不存在返回值，再调用__getattr__。它是一个获取属性的方法，它还有第三个参数，用来返回当属性不存在时，需返回的默认值，如果__getattr__已经被重写，则第三个参数不起作用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 A对象ssss</span></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问已经存在的属性</span></span><br><span class="line"><span class="built_in">print</span>(a.data)</span><br><span class="line"><span class="built_in">print</span>(a.counter)</span><br></pre></td></tr></table></figure><h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><table><thead><tr><th>方法</th><th>作用</th><th>tips</th></tr></thead><tbody><tr><td><code>__get__(self, instance, owner)</code></td><td>通过实例访问属性时调用，定义属性的获取行为</td><td></td></tr><tr><td><code>__set__(self, instance, owner)</code></td><td>给属性赋值时调用，定义属性的设置行为</td><td></td></tr><tr><td><code>__delete__(self, instance, owner)</code></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 魔术方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt案例(一)计时器</title>
      <link href="/2023/07/29/Pyqt%E6%A1%88%E4%BE%8B(%E4%B8%80)%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
      <url>/2023/07/29/Pyqt%E6%A1%88%E4%BE%8B(%E4%B8%80)%E8%AE%A1%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Pyqt案例-一-计时器"><a href="#Pyqt案例-一-计时器" class="headerlink" title="Pyqt案例(一)计时器"></a>Pyqt案例(一)计时器</h1><blockquote><p>本例包含内容：自定义信号、多线程、QLCDNumber</p><p>简单，适合当范例，忘记时候回来看看</p><p>ChatGPT能帮助解读代码</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PySide6.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sec = <span class="number">0</span> <span class="comment"># 时间：s/秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时线程，发送信号给Counter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeThread</span>(<span class="title class_ inherited__">QThread</span>):</span><br><span class="line">    timer = Signal()    <span class="comment"># timer每过一秒发送信号</span></span><br><span class="line">    end = Signal()      <span class="comment"># end计时结束发送信号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(TimeThread, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计时函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> sec == <span class="number">5</span>:</span><br><span class="line">                self.end.emit()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.timer.emit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时器主界面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>(<span class="title class_ inherited__">QWidget</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Counter, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;计数器&quot;</span>)</span><br><span class="line">        self.resize(<span class="number">300</span>,<span class="number">120</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># QLCDNumber一个显示数字的框</span></span><br><span class="line">        layout = QVBoxLayout()</span><br><span class="line">        self.lcd = QLCDNumber()</span><br><span class="line">        layout.addWidget(self.lcd)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计数开始按钮</span></span><br><span class="line">        self.butten = QPushButton(<span class="string">&#x27;开始计数&#x27;</span>)</span><br><span class="line">        layout.addWidget(self.butten)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 垂直布局放到按钮中</span></span><br><span class="line">        self.setLayout(layout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计时线程</span></span><br><span class="line">        self.timeThread = TimeThread()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链接信号与槽</span></span><br><span class="line">        self.timeThread.timer.connect(self.countTime)</span><br><span class="line">        self.timeThread.end.connect(self.end)</span><br><span class="line">        self.butten.clicked.connect(self.workThread)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当开始按钮click时，运行线程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">workThread</span>(<span class="params">self</span>):</span><br><span class="line">        self.timeThread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计时，每过一秒timer发送信号，sec加1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countTime</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> sec</span><br><span class="line">        sec+=<span class="number">1</span></span><br><span class="line">        self.lcd.display(sec)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计时结束，end发送信号，弹出结束对话框</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">self</span>):</span><br><span class="line">        QMessageBox.information(self,<span class="string">&#x27;消息&#x27;</span>,<span class="string">&#x27;计时结束&#x27;</span>,QMessageBox.Ok)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line"></span><br><span class="line">    window = Counter()</span><br><span class="line"></span><br><span class="line">    window.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.<span class="built_in">exec</span>())</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timer = Signal()</span><br><span class="line">self.timeThread.timer.connect(self.countTime)</span><br><span class="line"><span class="comment"># connect方法并不是Signal对象中的方法，而是QObject中的。</span></span><br><span class="line"><span class="comment"># 我之前写在了__init__方法里</span></span><br><span class="line">self.timer = Signal()</span><br><span class="line"><span class="comment">#...timer.connect()就会在Signal()中找connect方法</span></span><br><span class="line"><span class="comment"># 结果报错，Signal里根本没有connect</span></span><br><span class="line">AttributeError: <span class="string">&#x27;PySide6.QtCore.Signal&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;connect&#x27;</span></span><br><span class="line"><span class="comment"># 查了些资料没找到解释，chatGPT给的解释是，信号对象被创建时，会自动创建一个与之关联的信号通道。这个信号通道在内部维护了一个槽函数列表和一些其他信息。当调用 signal_object.connect(slot) 时，它实际上调用了信号通道内部的 connect 方法，将指定的槽函数添加到槽函数列表中。实现这一过程似乎是重写了__getattritube__方法。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 案例 </tag>
            
            <tag> 计时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub上md文件图片加载不出问题</title>
      <link href="/2023/07/25/GitHub%E4%B8%8Amd%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%87%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/25/GitHub%E4%B8%8Amd%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%87%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="问题：GitHub上md文件图片加载不出"><a href="#问题：GitHub上md文件图片加载不出" class="headerlink" title="问题：GitHub上md文件图片加载不出"></a>问题：GitHub上md文件图片加载不出</h1><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307252304150.png" alt="image-20230725230431572"></p><p>其他人项目中的md文件中的图片都无法加载。</p><h1 id="原因：DNS被污染，无法访问存放github图片素材的站点"><a href="#原因：DNS被污染，无法访问存放github图片素材的站点" class="headerlink" title="原因：DNS被污染，无法访问存放github图片素材的站点"></a>原因：DNS被污染，无法访问存放github图片素材的站点</h1><p>存放github图片素材的站点：<code>raw.githubusercontent.com</code></p><h1 id="解决办法：修改host文件"><a href="#解决办法：修改host文件" class="headerlink" title="解决办法：修改host文件"></a>解决办法：修改host文件</h1><ol><li>找到hosts文件，system系统的这个</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307252311283.png" alt="image-20230725231059476"></p><ol start="2"><li><p>查询站点的IP地址</p><p>查询网站：<a href="https://www.ipaddress.com/">What is my IP Address?</a>，复制<code>raw.githubusercontent.com</code>名称，即可找到对应ip地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询结果</span><br><span class="line">raw  IN  A  185.199.108.133</span><br><span class="line">raw  IN  A  185.199.109.133</span><br><span class="line">raw  IN  A  185.199.110.133</span><br><span class="line">raw  IN  A  185.199.111.133</span><br><span class="line"></span><br><span class="line">添加内容</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.109.133 raw.githubusercontent.com</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><blockquote><p>hosts文件有时候无法修改，将文件复制到桌面修改，再粘贴回去。</p></blockquote></li><li><p>刷新DNS</p><p>命令行，输入<code>ipconfig /flushdns</code></p></li></ol><p>​<img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307252316863.png" alt="image-20230725231629182"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python之下划线</title>
      <link href="/2023/07/25/python%E4%B9%8B%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
      <url>/2023/07/25/python%E4%B9%8B%E4%B8%8B%E5%88%92%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="单个下划线"><a href="#单个下划线" class="headerlink" title="单个下划线"></a>单个下划线</h1><ul><li><p>在命令行里输入单个下划线表示上一次的表达式</p></li><li><p>用作数值字面量中的千位分隔符，提高可读性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">1_000_000</span></span><br></pre></td></tr></table></figure></li><li><p>用作临时变量名，常用来表示不需要使用的变量，在循环遍历中使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 情况1</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况2</span></span><br><span class="line">x, _, z = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>用作国际化（i18n）函数的翻译标记：在一些国际化库中，下划线常常用于标记需要进行翻译的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gettext <span class="keyword">import</span> gettext <span class="keyword">as</span> _</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(_(<span class="string">&quot;Hello World&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul><h2 id="前缀单下划线-name"><a href="#前缀单下划线-name" class="headerlink" title="前缀单下划线 _name"></a>前缀单下划线 _name</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#仅模块内方法调用</span></span><br><span class="line"><span class="comment">#标记类的私有属性和方法</span></span><br><span class="line"><span class="comment">#当一个方法有前缀_，则该方法在被import时也不能被调用。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line"><span class="comment">#例如设置一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name=<span class="string">&#x27;lbw&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_func</span>():</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><h2 id="后缀单下划线-name"><a href="#后缀单下划线-name" class="headerlink" title="后缀单下划线 name_"></a>后缀单下划线 name_</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果想使用python内置变量名，例如class、print，可以加一个_来区分，class_、print_</span><br></pre></td></tr></table></figure><h1 id="双下划线"><a href="#双下划线" class="headerlink" title="双下划线"></a>双下划线</h1><h2 id="前缀双下划线-name"><a href="#前缀双下划线-name" class="headerlink" title="前缀双下划线 __name"></a>前缀双下划线 __name</h2><p>重整（name mangling）：以双下划线开头的名称会被重命名为<code>_类名__名称</code>的形式，其中<code>类名</code>是包含该名称的类的名称，而<code>名称</code>是原始名称去掉双下划线开头的部分。</p><p>确保不同类中具有相同双下划线前缀的属性或方法不会发生冲突。使用双下划线开头的名称，可以有效地将其视为类的私有成员，不应该被外部代码直接访问或重写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__private_var = 10</span><br><span class="line"></span><br><span class="line">    def __private_method(self):</span><br><span class="line">        print(&quot;This is a private method.&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.__private_var = 20</span><br><span class="line"></span><br><span class="line">    def __private_method(self):</span><br><span class="line">        print(&quot;This is a private method in B.&quot;)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">print(a.__private_var)  # 无法直接访问原始的私有变量名</span><br><span class="line"># 输出：AttributeError: &#x27;A&#x27; object has no attribute &#x27;__private_var&#x27;</span><br><span class="line"></span><br><span class="line">print(a._A__private_var)</span><br><span class="line"># 输出：10</span><br><span class="line"></span><br><span class="line">print(b._B__private_var)  # 使用名称重整的方式访问私有变量</span><br><span class="line"># 输出：20</span><br><span class="line"></span><br><span class="line">a.__private_method()  # 无法直接访问原始的私有方法名</span><br><span class="line"># 输出：AttributeError: &#x27;A&#x27; object has no attribute &#x27;__private_method&#x27;</span><br><span class="line"></span><br><span class="line">a._A__private_method()</span><br><span class="line"># 输出：This is a private method.</span><br><span class="line"></span><br><span class="line">b._B__private_method()  # 使用名称重整的方式访问私有方法</span><br><span class="line"># 输出：This is a private method in B.</span><br></pre></td></tr></table></figure><h2 id="前后缀双下划线-name"><a href="#前后缀双下划线-name" class="headerlink" title="前后缀双下划线_name_"></a>前后缀双下划线_<em>name</em>_</h2><blockquote><p>魔术方法，这些方法在类定义中具有特殊的含义，并通过特定的调用方式进行调用。</p></blockquote><p>例如，<code>__init__</code>是用于初始化实例的构造函数，<code>__str__</code>用于自定义对象的字符串表示，<code>__add__</code>用于自定义对象的加法操作等等。</p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 下划线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo教程(三)博客美化</title>
      <link href="/2023/07/24/Hexo%E6%95%99%E7%A8%8B(%E4%B8%89)%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
      <url>/2023/07/24/Hexo%E6%95%99%E7%A8%8B(%E4%B8%89)%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="修改代码块主题"><a href="#修改代码块主题" class="headerlink" title="修改代码块主题"></a>修改代码块主题</h1><blockquote><p>Butterfly 支持6種代碼高亮樣式：darker、pale night、light、ocean、mac、mac light</p></blockquote><p>在<strong>主题配置文件</strong>下，找到highlight_theme字段，修改对应名称即可。</p><ul><li>mac</li></ul><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307241435818.png" alt="image-20230724143514191" style="zoom:80%;"><p>查看其他效果点击：<a href="https://butterfly.js.org/posts/4aa8abbe/#%E4%BB%A3%E7%A2%BC%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A1%8C">Butterfly官方文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span> <span class="comment">#  darker / pale night / light / ocean / mac / mac light / false</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 代码一键复制按钮</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># 显示代码语言</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># true: 代码块不展开/ false: 代码块自动展开 | none: 代码块自动展开，且无收缩按钮 | 在font-matter中可对单个文文章进行配置</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="number">200</span> <span class="comment"># 高度限制，单位px像素</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">false</span><span class="comment">#代码自动换行，一般为滚动条形式</span></span><br></pre></td></tr></table></figure><h1 id="自定义代码块"><a href="#自定义代码块" class="headerlink" title="自定义代码块"></a>自定义代码块</h1><p>除了上述6种样式，如果喜欢其他的样式，可以通过标签插件实现。</p><p>官方文档中举了两个例子：<a href="https://butterfly.js.org/posts/b37b5fe3/">自定義代碼配色</a></p><p>效果：</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307241954619.png" alt="image-20230724195407039" style="zoom:80%;"><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307241954439.png" alt="image-20230724195426216" style="zoom:80%;"><h1 id="调整字体"><a href="#调整字体" class="headerlink" title="调整字体"></a>调整字体</h1><p>找到主题配置文件中的font字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span> <span class="string">16px</span> <span class="comment"># 默认14px</span></span><br><span class="line">  <span class="attr">code-font-size:</span> <span class="string">15px</span> <span class="comment"># 默认14px</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">HYSongYunLangHeiW,AlibabaPuHuiTi-3-55-Regular,&quot;Microsoft</span> <span class="string">YaHei&quot;,</span> <span class="string">sans-serif</span></span><br><span class="line">  <span class="attr">code-font-family:</span> <span class="string">HYSongYunLangHeiW,AlibabaPuHuiTi-3-55-Regular,&quot;Microsoft</span> <span class="string">YaHei&quot;,</span> <span class="string">sans-serif</span></span><br></pre></td></tr></table></figure><h2 id="修改字体大小"><a href="#修改字体大小" class="headerlink" title="修改字体大小"></a>修改字体大小</h2><p>global-font-size是全局字体大小，code-font-size是代码大小，个人感觉有点小，所以调高了一点，需要注意的是，作者提醒了非必要不要修改，因为改动是全局字体，一些插件中的字体会出范围，如下所示：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250138305.png" alt="image-20230725013845063"></p><h2 id="修改字体样式"><a href="#修改字体样式" class="headerlink" title="修改字体样式"></a>修改字体样式</h2><p>参考文章：</p><p><a href="https://www.eacls.top/posts/286b8081/">Blog by Eacls</a></p><p><a href="https://imbhj.com/posts/25c13146">Ordis Blog</a></p><p><a href="https://www.thyuu.com/word/tips/62610">免费引入商用黑体字体系列整理及 CSS 字体引入亲妈式教程（20230606更新）</a></p><p>其中需要注意的是，修改字体两种方式中，本地引入通常会非常拖慢速度，故多使用外链引入。</p><h2 id="Blog-标题字体修改"><a href="#Blog-标题字体修改" class="headerlink" title="Blog 标题字体修改"></a>Blog 标题字体修改</h2><p>butterfly主题还单独提供了标题字体的修改。(页面加粗白色字段)</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250327379.png" alt="image-20230725032729164" style="zoom: 67%;"><p>依然还是找到主题文件中相关字段，就在font下面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Font settings for the site title and site subtitle</span></span><br><span class="line"><span class="comment"># 左上角網站名字 主頁居中網站名字</span></span><br><span class="line"><span class="attr">blog_title_font:</span></span><br><span class="line">  <span class="attr">font_link:</span> <span class="string">/css/iconfont.css</span> <span class="comment"># css路径</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">AlibabaPuHuiTi-3-55-Regular</span> <span class="comment"># 同上</span></span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>修改这个样式遇到好几个奇奇怪怪的问题，熬夜弄也没弄明白。</p><ol><li><p>font-family和code-font-family的字段，第一位接带“”双引号的字体名字时，会报错</p><p>解决办法：</p><ul><li>第一个字段随便写一个名字，第一个找不到会顺位到第二位。</li><li>修改css中引入字体的font-family，改为英文，去掉引号</li></ul></li><li><p>css外链引入时，诡异错误。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250309473.jpg" alt="(8R0Y9F)PJZIQ2RAG6XWV@Q" style="zoom: 67%;"></li></ol><p>上面是正常引入的，但只要把第一个@font-face完全注释掉，字体就不会显示该样式了。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307250312798.jpg" alt="QQ图片20230725031205" style="zoom:67%;">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python之文件操作</title>
      <link href="/2023/07/24/python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/24/python%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="python的文件操作"><a href="#python的文件操作" class="headerlink" title="python的文件操作"></a>python的文件操作</h1><blockquote><p>python中内置了文件（File）对象。通过open()方法创建。</p></blockquote><h2 id="file文件的读写操作"><a href="#file文件的读写操作" class="headerlink" title="file文件的读写操作"></a>file文件的读写操作</h2><ul><li>创建和打开文件、关闭文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(filename[,mode[,buffering]])</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"><span class="comment"># filename：要创建的文件名，或路径</span></span><br><span class="line"><span class="comment"># mode：文件的打开方式，取值见下表</span></span><br><span class="line"><span class="comment"># buffering：用于指定读写文件的缓冲模式</span></span><br><span class="line"><span class="comment"># 值为0表示不缓存，值为1表示缓存</span></span><br><span class="line"><span class="comment"># 大于1表示缓冲区的大小</span></span><br><span class="line">file.close()</span><br><span class="line"><span class="comment"># 使用close()方法时，会先刷新缓冲区中还没有写入的信息，然后再关闭文件，这样可以将没有写入文件的内容写入文件中</span></span><br></pre></td></tr></table></figure><p>写入文件后，一定要调用close()方法关闭文件，否则写入的内容不会保存到文件中。这是因为在写入文件内容时，操作系统不会立刻把数据写入磁盘，而是先缓存起来，只有调用close()方法时，操作系统才会保证把没有写入的数据全部写入磁盘。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240502274.png" alt="Image [5]"></p><ul><li>用with语句打开文件、写入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;path&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><ul><li>读取文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---读取指定字符---</span></span><br><span class="line">file.read([size])</span><br><span class="line"><span class="comment"># size: 用于指定要读取的字符个数，省略则全部读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---读取一行---</span></span><br><span class="line">file.readline()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---读取所有行---</span></span><br><span class="line">file.readlines()</span><br><span class="line"><span class="comment"># 返回每行的字符串列表</span></span><br></pre></td></tr></table></figure><ul><li>文件指针</li></ul><blockquote><p>文件指针能指定文件读写的起始位置</p></blockquote><p>python在关闭文件时，不会保存文件指针的位置，也就是说，每次打开时，文件指针都是0。而java、C和C#则会自动保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file.seek(offset[,whence])</span><br><span class="line"><span class="comment"># offset: 用于指定移动的字符个数</span></span><br><span class="line"><span class="comment">#--offset的值是按一个汉字占两个字符、英文和数字占一个字符计算的--</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whence: 指定移动的起始位置</span></span><br><span class="line"><span class="comment">#--whence值为0表示从文件头开始计算，1表示从当前位置开始计算，2表示从文件尾开始计算，默认为0--、</span></span><br><span class="line"></span><br><span class="line">file.seek(<span class="number">0</span>)<span class="comment"># 定位到开头</span></span><br><span class="line">file.seek(<span class="number">0</span>, <span class="number">2</span>)<span class="comment"># 定位到结尾</span></span><br><span class="line">file.read()<span class="comment"># 指向到读取后的位置</span></span><br></pre></td></tr></table></figure><h2 id="file文件的操作"><a href="#file文件的操作" class="headerlink" title="file文件的操作"></a>file文件的操作</h2><hr><ul><li>复制、移动</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要使用shutil模块</span></span><br><span class="line">shutil.copyfile(src, dst)</span><br><span class="line"></span><br><span class="line">shutil.move(src, dst)</span><br></pre></td></tr></table></figure><ul><li>重命名、删除、获取基本信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要用到os模块</span></span><br><span class="line">os.rename(src, dst)</span><br><span class="line"></span><br><span class="line">os.remove(path)</span><br><span class="line"></span><br><span class="line">os.stat(path)</span><br><span class="line"><span class="comment"># 返回属性见下表</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240501920.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(七)多线程</title>
      <link href="/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%83)%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%83)%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h1><hr><p><strong>进程</strong>：系统中资源分配和资源调度的基本单位，叫作进程。</p><p><strong>线程</strong>：个线程则是进程中的执行流程，一个进程中可以同时包括多个线程，每个线程也可以得到一小段程序的执行时间，这样一个进程就可以具有多个并发执行的线程。</p><h2 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h2><ul><li>通过网络与web服务器和数据库进行通信。</li><li>执行占用大量时间的操作</li><li>区分具有不同优先级的任务</li><li>使用户界面可用在将时间分配给后台任务时仍能快速做出响应</li></ul><h2 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h2><p>建议一般不要在程序中使用太多的线程，这样可以最大限度地减少操作系统资源的使用，并提高性能</p><ul><li>系统将为进程和线程所需的上下文信息使用内存。因此，可用创建的进程和线程的数目会收到可用内存的限制。</li><li>跟踪大量的线程将占用大量的处理器时间。如果线程过多，则其中大多数线程都不会产生明显的进度。如果大多数线程处于一个进程中，则其他进程中的线程的调度频率就会很低。</li><li>使用多个线程控制代码执行非常复制，并可能产生许多Bug</li><li>销毁线程需要了解可能发生的问题并进行处理</li></ul><h1 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h1><hr><p>在PyQt5中实现多线程主要有两种方法，一种是使用QTimer计时器模块；另一种是使用QThread线程模块</p><h2 id="QTimer：计时器"><a href="#QTimer：计时器" class="headerlink" title="QTimer：计时器"></a>QTimer：计时器</h2><p>如果需要周期性地执行某项操作，就可以使用QTimer类实现，QTimer类表示计时器，它可以定期发射timeout信号，时间间隔的长度在start()方法中指定，以毫秒为单位，如果要停止计时器，则需要使用stop()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> QTimer</span><br><span class="line"></span><br><span class="line">timer = QTimer(MainWindow)</span><br><span class="line">timer.start()<span class="comment">#开始计时器</span></span><br><span class="line">timer.timeout.connect(槽函数)<span class="comment"># 设置计时器要执行的槽函数</span></span><br><span class="line"><span class="comment"># 接下来，timer线程会重复执行槽函数</span></span><br><span class="line">timer.stop()<span class="comment">#停止计时器</span></span><br></pre></td></tr></table></figure><h2 id="QThread：线程类"><a href="#QThread：线程类" class="headerlink" title="QThread：线程类"></a>QThread：线程类</h2><p><strong>常用方法</strong></p><table><thead><tr><th>run()</th><th>线程的起点，在调用start()之后，新创建的线程将调用该方法</th></tr></thead><tbody><tr><td>start()</td><td>启动线程</td></tr><tr><td>wait()</td><td>阻塞线程</td></tr><tr><td>sleep()</td><td>以秒为单位休眠线程</td></tr><tr><td>msleep()</td><td>以毫秒为单位休眠线程</td></tr><tr><td>usleep()</td><td>以微秒为单位休眠线程</td></tr><tr><td>quit()</td><td>退出线程的事件循环并返回代码0(成功)，相当于exit(0)</td></tr><tr><td>exit()</td><td>退出线程的事件循环，并返回代码，如果返回0成功，其他错误</td></tr><tr><td>terminate()</td><td>强制终止线程，在terminate()之后应该使用wait()方法，以确保当线程终止时，等待线程完成的所有线程都将被唤醒，另外，不建议使用这种方法终止线程</td></tr><tr><td>setPriority()</td><td>设置线程的优先级：QThread.IdlePriority：空闲优先级QThread.LowestPriority：最低优先级QThread.LowPriority：低优先级QThread.NormalPriority：系统默认优先级QThread.HighPrioriry：高优先级QThread.HighestPriority：最高优先级QThread.TimeCriticalPriority：尽可能频繁地分配执行QThread.InheritPriority：默认，使用与创建线程相同的优先级</td></tr><tr><td>isFinished()</td><td>是否完成</td></tr><tr><td>isRunning()</td><td>是否正在运行</td></tr></tbody></table><p><strong>信号</strong></p><table><thead><tr><th>started</th><th>在调用run()方法之前，在相关线程开始执行时从该线程发射</th></tr></thead><tbody><tr><td>finished</td><td>在相关线程完成执行之前从该线程发射</td></tr></tbody></table><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><hr><p>线程也有自己的生命周期，其中包含5种状态，分别为出生状态、就绪状态、运行状态、暂停状态（包括休眠、等待和阻塞等）和死亡状态</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240457216.png" alt="Image [4]"></p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(五)信号与槽</title>
      <link href="/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%94)%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/"/>
      <url>/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%94)%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><hr><blockquote><p>所有继承Qwidget的控件都支持信号与槽机制</p></blockquote><ul><li>信号：当一个信号发生改变时，向外界发出的信息。</li></ul><p>当一个信号被发射时，与其关联的槽函数被立刻执行。其中该对象只负责发送信号，发射该信号的对象并不知道是哪个对象在接受这个信号，这样保证了对象与对象之间的低耦合。</p><p>如果存在信号和多个槽函数相关联的时候，当信号被发射时，这些槽的执行顺序将会是随机的。</p><ul><li>槽：一个执行某些操作的函数或者方法</li></ul><p>当和槽连接的信号被发射时，槽会被调用。一个槽并不知道是否有任何信号与自己相连接。</p><ul><li><p>信号与槽机制</p></li><li><p>将信号 连接 槽，当信号发出时，连接的槽函数会自动执行</p></li><li><p>信号连接</p></li></ul><p>通过调用QObject对象的connect函数来将某个对象的信号与另一个对象的槽函数相关联。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.信号.connect(槽函数)</span><br></pre></td></tr></table></figure><p>当信号与槽没有必要保持关联时，可以使用disconnect函数来断开连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(槽函数)</span><br></pre></td></tr></table></figure><h1 id="槽函数的特点"><a href="#槽函数的特点" class="headerlink" title="槽函数的特点"></a>槽函数的特点</h1><ol><li>一个信号可以连接多个槽：调用随机</li><li>多个信号可以连接到同一个槽</li><li>信号的参数可以是任何的python类型，如list等</li><li>信号和槽的连接可以被移除</li><li>信号可以和另外一个信号进行关联：第一个信号发出后，第二个信号也同时发送。比如关闭系统的信号发出后，同时会发出保存数据的信号</li></ol><h1 id="自定义信号与槽"><a href="#自定义信号与槽" class="headerlink" title="自定义信号与槽"></a>自定义信号与槽</h1><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> pyqtSignal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义信号：可以带参数</span></span><br><span class="line">signal = pyqtSignal()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义槽函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signalCall</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;signal emit&quot;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line">self.signal.connect(self.signalCall)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发射信号</span></span><br><span class="line">self.signal.emit()</span><br></pre></td></tr></table></figure><h1 id="关于连接中槽函数无法传递参数问题"><a href="#关于连接中槽函数无法传递参数问题" class="headerlink" title="关于连接中槽函数无法传递参数问题"></a>关于连接中槽函数无法传递参数问题</h1><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.btn.clicked.connect(self.onButtonClick)</span><br><span class="line"></span><br><span class="line"><span class="comment"># onButtonClick()函数无法传递参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决办法1：lamdba表达式，传递一个匿名函数</span></span><br><span class="line">self.btn.clicked.connect(lamdba: self.onButtonClick(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#解决办法2：使用functools中的partial函数</span></span><br><span class="line">self.btn.clicked.connect(partial(self.onButtonClick,<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 信号与槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(六)常用控件</title>
      <link href="/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E5%85%AD)%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/"/>
      <url>/2023/07/24/Pyqt%E6%95%99%E7%A8%8B(%E5%85%AD)%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="文本类控件"><a href="#文本类控件" class="headerlink" title="文本类控件"></a>文本类控件</h1><blockquote><p>文本类控件主要用来显示或者编辑文本信息，主要有Label、LineEdit、TextEdit、SpinBox、DoubleSpinBox、LCDNumber</p></blockquote><h2 id="Label：标签控件"><a href="#Label：标签控件" class="headerlink" title="Label：标签控件"></a>Label：标签控件</h2><blockquote><p>主要用于显示用户不能编辑的文本，标识窗体上的对象，添加描述信息，对应QLabel类</p></blockquote><p><strong>常用方法</strong></p><ul><li>设置text文本属性</li></ul><p><code>lab.setText(text)</code></p><ul><li>设置标签文本的对齐方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#alignment属性：Horizontal和Vertical，水平和垂直 </span></span><br><span class="line"><span class="comment">#Horizontal：AlignLeft左对齐、AlignHCenter居中、AlignRight右对齐、AlignJustify两端对齐</span></span><br><span class="line"><span class="comment">#Vertical：AlignTop顶部对齐、AlignVCenter居中、AlignBottom底部对齐 #方法</span></span><br><span class="line">lab.setAlignment(QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)</span><br></pre></td></tr></table></figure><ul><li>设置文本换行显示</li></ul><p>标签宽度不足情况下，系统会默认只显示部分文字。所以需要设置标签中的文本换行显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#wordWrap属性：True和False</span></span><br><span class="line"><span class="comment">#方法</span></span><br><span class="line">lab.setWordWrap(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>为标签设置超链接</li></ul><p>直接在setText()方法中使用HTML中的<a>标签设置超链接文本，然后将Label标签的setOpenExternalLinks()设置为True</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lab.setText(<span class="string">&quot;&lt;a href=&#x27;https://www.bilibili.com/&#x27;&gt;bilibili&lt;/a&gt;&quot;</span>) </span><br><span class="line">lab.setOpenExternalLinks(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>为标签设置图片</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法,需要有一个QPixmap对象</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QPixmap</span><br><span class="line">lab.setPixmap(QPixmap(<span class="string">&#x27;test.png&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>获取标签文本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab.text()</span><br></pre></td></tr></table></figure><h2 id="LineEdit：单行文本框"><a href="#LineEdit：单行文本框" class="headerlink" title="LineEdit：单行文本框"></a>LineEdit：单行文本框</h2><p><strong>常用方法</strong></p><ul><li>设置文本框内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setText(str)</span><br></pre></td></tr></table></figure><ul><li>获取文本框内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.text()</span><br></pre></td></tr></table></figure><ul><li>设置文本框浮显文字</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setPlaceholderText(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><ul><li>设置允许文本框输入字符的最大长度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setMaxLength()</span><br></pre></td></tr></table></figure><ul><li>设置文本对齐方式式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setAlignment(Horzontal,Vartical)</span><br></pre></td></tr></table></figure><ul><li>设置文本框只读</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setReadOnly()</span><br></pre></td></tr></table></figure><ul><li>使文本框得到焦点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setFocus()</span><br></pre></td></tr></table></figure><ul><li>清除文本框内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.clear()</span><br></pre></td></tr></table></figure><ul><li>设置文本框显示字符的模式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QLineEdit.Normal: 正常显示输入的字符</span></span><br><span class="line"><span class="comment"># QLineEdit.NoEcho: 不显示任何输入的字符</span></span><br><span class="line"><span class="comment"># QLineEdit.Password: 显示与平台相关的密码掩码字符</span></span><br><span class="line"><span class="comment"># QLineEdit.PasswordEchoOnEdit: 在编辑时显示字符，失去焦点后显示掩码</span></span><br><span class="line">ledit.setEchoMode()</span><br></pre></td></tr></table></figure><ul><li>设置文本框验证器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QIntValidator: 限制输入整数</span></span><br><span class="line"><span class="comment"># QDoubleValidator: 限制输入小数</span></span><br><span class="line"><span class="comment"># QRegExpValidator: 检查输入是否符合设置的正则表达式</span></span><br><span class="line">ledit.setValidator()</span><br></pre></td></tr></table></figure><ul><li>设置掩码</li></ul><p>掩码通常由掩码字符和分隔符组成，后面可以跟一个分号和空白字符，空白字符在编辑完成后会从文本框中删除</p><p>日期掩码：0000-00-00;</p><p>时间掩码：00:00:00;</p><p>序列号掩码：&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.setInputMask()</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li>当更改文本框中内容时发射该信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.textChanged.connect(槽函数)</span><br></pre></td></tr></table></figure><ul><li>当文本框中的内容编辑结束时发射该信号，以按下Enter为编辑结束标志</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ledit.editingFinished.connect(槽函数)</span><br></pre></td></tr></table></figure><h2 id="TextEdit：多行文本框"><a href="#TextEdit：多行文本框" class="headerlink" title="TextEdit：多行文本框"></a>TextEdit：多行文本框</h2><p><strong>常用方法</strong></p><ul><li>设置文本内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.setPlainText(str)</span><br></pre></td></tr></table></figure><ul><li>获取文本内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.toPlainText()</span><br></pre></td></tr></table></figure><ul><li>设置文本颜色</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tedit.setTextColor(QtGui.QColor(255,0,0))</span><br><span class="line">#需要一个QColor对象</span><br></pre></td></tr></table></figure><ul><li>设置文本背景颜色</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tedit.setTextBackgroundColor(QtGui.QColor(255,0,0))</span><br><span class="line">#需要一个QColor对象</span><br></pre></td></tr></table></figure><ul><li>设置HTML文档内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.setHtml()</span><br></pre></td></tr></table></figure><ul><li>获取HTML文档内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.toHtml()</span><br></pre></td></tr></table></figure><ul><li>设置自动换行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.wordWrapMode()</span><br></pre></td></tr></table></figure><ul><li>清除所有内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tedit.clear()</span><br></pre></td></tr></table></figure><h1 id="按钮类控件"><a href="#按钮类控件" class="headerlink" title="按钮类控件"></a>按钮类控件</h1><p>按钮类控件主要用来执行一些命令操作，主要有PushButton、ToolButton、CommandLinkButton、RadioButton和CheckBox</p><h2 id="PushButton：按钮"><a href="#PushButton：按钮" class="headerlink" title="PushButton：按钮"></a>PushButton：按钮</h2><hr><p><strong>定义</strong></p><p><code>button = QPushButton(&#39;&amp;Download&#39;, self)</code></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240443020.png" alt="img"></p><p><strong>常用方法</strong></p><ul><li>设置按钮所显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbtn.setText(str)</span><br></pre></td></tr></table></figure><ul><li>获取按钮所显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbtn.text()</span><br></pre></td></tr></table></figure><ul><li>设置按钮上的图标、设置按钮图标大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide2.QtCore <span class="keyword">import</span> Qt,QSize </span><br><span class="line"><span class="keyword">from</span> PySide2.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"></span><br><span class="line">pbtn.setIcon(QtGui.QIcon(<span class="string">&#x27;icon_path&#x27;</span>))</span><br><span class="line">pbtn.setIconSize(Qt.Core.QSize(<span class="built_in">int</span> width,<span class="built_in">int</span> height))</span><br></pre></td></tr></table></figure><ul><li>设置按钮是否可用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pbtn.setEnabled(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 不可用</span></span><br></pre></td></tr></table></figure><ul><li>设置按钮的快捷键</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pbtn.setShortcut()</span><br><span class="line"># 参数可以设置为键盘中的按键或快捷键，例如&#x27;Alt+0&#x27;</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li><strong>信号: 被点击</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbtn.clicked.connect(槽函数)</span><br></pre></td></tr></table></figure><h2 id="RadioButton：单选按钮"><a href="#RadioButton：单选按钮" class="headerlink" title="RadioButton：单选按钮"></a>RadioButton：单选按钮</h2><hr><p>对应QRadioButton类</p><p><strong>常用方法</strong></p><ul><li>设置单选按钮显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.setText(str)</span><br></pre></td></tr></table></figure><ul><li>获取单选按钮显示的文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.text()</span><br></pre></td></tr></table></figure><ul><li>设置单选按钮是否为选中状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rbtn.setChecked(True)</span><br><span class="line"># 或者</span><br><span class="line">rbtn.setCheckable(False)</span><br></pre></td></tr></table></figure><ul><li>查看单选按钮是否为选中状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.isChecked()</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li>单击单选按钮</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbtn.clicked.connect()</span><br></pre></td></tr></table></figure><ul><li>在单选按钮状态改变时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 常用</span><br><span class="line">rbtn.toggled.connect()</span><br></pre></td></tr></table></figure><h1 id="进度条：ProgressBar"><a href="#进度条：ProgressBar" class="headerlink" title="进度条：ProgressBar"></a>进度条：ProgressBar</h1><p>对应QProgressBar类</p><p><strong>常用方法</strong></p><ul><li>设置进度条的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置进度条的最小值</span></span><br><span class="line">pgbar.setMinimum(<span class="built_in">int</span> num)</span><br><span class="line"><span class="comment"># 设置进度条的最大值</span></span><br><span class="line">pgbar.setMaximum()</span><br><span class="line"><span class="comment"># 设置进度条的取值范围，相当于上两组合</span></span><br><span class="line">pgbar.setRange()</span><br><span class="line"><span class="comment"># 设置进度条的当前值</span></span><br><span class="line">pgbar.setValue()</span><br></pre></td></tr></table></figure><ul><li>设置进度条的文字填充格式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %p%：显示完成的百分比</span></span><br><span class="line"><span class="comment"># %v：显示当前的进度值</span></span><br><span class="line"><span class="comment"># %m：显示总的步长值</span></span><br><span class="line">pgbar.setFormat()</span><br></pre></td></tr></table></figure><ul><li>设置进度条的布局方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt.LeftToRight: 从左到右</span></span><br><span class="line"><span class="comment"># Qt.RightToLeft: 从右到左</span></span><br><span class="line"><span class="comment"># Qt.LayoutDirectionAuto: 跟随布局方向自动调整</span></span><br><span class="line">pgbar.setLayoutDirection()</span><br></pre></td></tr></table></figure><ul><li>设置对齐方式</li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240442816.png" alt="img"></p><ul><li>设置进度条的显示方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt.Horizontal: 水平方向</span></span><br><span class="line"><span class="comment"># Qt.Vertical: 垂直方向</span></span><br><span class="line">pgbar.setOrientation()</span><br></pre></td></tr></table></figure><ul><li>设置进度条是否以反方向显示进度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgbar.setInvertedAppearance()</span><br></pre></td></tr></table></figure><ul><li>设置进度条的文本显示方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QProgressBar.TopToBottom: 从上到下</span></span><br><span class="line"><span class="comment"># QProgressBar.BottomToTop: 从下到上</span></span><br><span class="line">pgbar.setTextDirection()</span><br></pre></td></tr></table></figure><ul><li>对进度条的属性进行设置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以是任何属性，如self.progressBar.setProperty(&quot;value&quot;,24)</span></span><br><span class="line">pgbar.setProperty()</span><br></pre></td></tr></table></figure><ul><li>获取进度条的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取最大值</span></span><br><span class="line">pgbar.minimum()</span><br><span class="line"><span class="comment"># 获取最小值</span></span><br><span class="line">pgbar.maximum()</span><br><span class="line"><span class="comment"># 获取当前值</span></span><br><span class="line">pgbar.value()</span><br></pre></td></tr></table></figure><p><strong>信号</strong></p><ul><li>在进度条的值发生改变时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgbar.valueChanged.connect()</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240442197.png" alt="Image [3]"></p><h1 id="对话框类"><a href="#对话框类" class="headerlink" title="对话框类"></a>对话框类</h1><p>常用对话框有QMessageBox、QFileDialog、QInputDialog、QFontDialog和QColorDialog</p><h2 id="QMessageBox：对话框"><a href="#QMessageBox：对话框" class="headerlink" title="QMessageBox：对话框"></a>QMessageBox：对话框</h2><hr><h3 id="对话框种类"><a href="#对话框种类" class="headerlink" title="对话框种类"></a>对话框种类</h3><table><thead><tr><th>QMessageBox.information()</th><th>消息对话框</th></tr></thead><tbody><tr><td>QMessageBox.question()</td><td>问答对话框</td></tr><tr><td>QMessageBox.warning()</td><td>警告对话框</td></tr><tr><td>QMessageBox.critical()</td><td>错误对话框</td></tr><tr><td>QMessageBox.about()</td><td>关于对话框</td></tr></tbody></table><h3 id="使用方法：以消息对话框为例"><a href="#使用方法：以消息对话框为例" class="headerlink" title="使用方法：以消息对话框为例"></a>使用方法：以消息对话框为例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox.information(QWidget, <span class="string">&#x27;Title&#x27;</span>, <span class="string">&#x27;Content&#x27;</span>, buttons, defaultbutton)</span><br><span class="line"><span class="comment"># QWidget: self或窗口对象，表示该对话框所属窗口</span></span><br><span class="line"><span class="comment"># Title: 字符串，表示对话框的标题</span></span><br><span class="line"><span class="comment"># Content: 字符串，表示对话框中的提示内容</span></span><br><span class="line"><span class="comment"># button: 对话框上要添加的按钮，多个按钮之间用“|”来连接，按钮种类见下表</span></span><br><span class="line"><span class="comment"># defaultbutton: 默认选中的按钮</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307240448440.png" alt="img"></p><blockquote><p>QMessageBox.about()关于对话框中不能指定按钮。</p><p>QMessageBox.about(QWidget, ‘Title’, ‘Content’)</p></blockquote><h2 id="QFileDialog-文件对话框"><a href="#QFileDialog-文件对话框" class="headerlink" title="QFileDialog: 文件对话框"></a>QFileDialog: 文件对话框</h2><hr><p>该类继承自QDialog类，它允许用户选择文件或者文件夹，也允许用户遍历文件系统，以便选择一个或多个文件或者文件夹。</p><p><strong>常用方法</strong></p><ul><li>获取一个、多个打开文件的文件名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> = QFileDialog()</span><br><span class="line"><span class="built_in">dir</span>.getOpenFileName()</span><br><span class="line"><span class="built_in">dir</span>.getOpenFileNames()</span><br></pre></td></tr></table></figure><ul><li>获取保存的文件名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.getSaveFileName()</span><br></pre></td></tr></table></figure><ul><li>获取一个打开的文件夹</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.getExistingDirectory()</span><br></pre></td></tr></table></figure><ul><li>设置接收模式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setAcceptMode()</span><br><span class="line"><span class="comment"># QFileDialog.AcceptOpen: 设置文件对话框为打开模式</span></span><br><span class="line"><span class="comment"># QFileDialog.AcceptSave: 设置文件对话框为保存模式</span></span><br></pre></td></tr></table></figure><ul><li>设置文件对话框中的文件名的默认后缀名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setDefaultSuffix()</span><br></pre></td></tr></table></figure><ul><li>设置可以选择的文件类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setFileMode()</span><br><span class="line"><span class="comment"># QFileDialog.AnyFile: 任意文件（无论是否存在）</span></span><br><span class="line"><span class="comment"># QFileDialog.ExistingFile: 已存在的文件</span></span><br><span class="line"><span class="comment"># QFileDialog.ExistingFiles: 已存在的多个文件</span></span><br><span class="line"><span class="comment"># QFileDialog.Directory: 文件夹</span></span><br><span class="line"><span class="comment"># QFileDialog.DirectoryOnly： 文件夹（选择时只能选中文件夹）</span></span><br></pre></td></tr></table></figure><ul><li>设置文件对话框默认打开位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setDirectory()</span><br></pre></td></tr></table></figure><ul><li>设置名称过滤器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setNameFilter()</span><br><span class="line"><span class="comment"># 多个类型的过滤器之间用两个分号分割，(*.*);;(*.py)</span></span><br><span class="line"><span class="comment"># 一个过滤器中如果有多种个数，用空格分割，(*.jpg *.png *.bmp)</span></span><br></pre></td></tr></table></figure><ul><li>设置显示模式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.setViewMode()</span><br><span class="line"><span class="comment"># QFileDialog.Detail: 显示文件详细信息，包括文件名、大小、日期</span></span><br><span class="line"><span class="comment"># QFileDialog.List: 以列表形式显示文件名</span></span><br></pre></td></tr></table></figure><ul><li>获取选择的一个、多个文件或文件夹名字</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>.selectedFile()</span><br><span class="line"><span class="built_in">dir</span>.selectedFiles()</span><br></pre></td></tr></table></figure><h1 id="else"><a href="#else" class="headerlink" title="else"></a>else</h1><p><code>QtCore</code> 模块是非 GUI 的核心库。这个模块用来处理时间、文件、目录、各种类型的数据、流（stream）、URLs，mime 类型、线程和进程。 <code>QtGui</code> 有窗口系统集成、事件处理、2D图形，基本图像、字体、文本的类。 <code>QtWidgets</code> 有创建经典风格的用户界面的类。</p><p><code>QtDBus</code> 是使用 D-Bus 处理 IPC 通讯的类。<code>QtNetwork</code> 是网络变成类，这些类使网络编程变得更容易，可移植性也更好，方便了 TCP&#x2F;IP 和 UDP 服务端和客户端编程。 <code>QtHelp</code> 包含了创建、查看和搜索文档的类。</p><p><code>QtXml</code> 包含了处理 XML 文件的类，实现了 SAX 和 DOM API。<code>QtSvg</code> 提供了显示 SVG 的类，可缩放矢量图形(SVG)是一种描述二维图像和图像应用的 XML 语言。<code>QtSql</code> 模块提供了数据库的类，<code>QtTest</code> 提供了可以对 PyQt6 应用进行单元测试的工具。</p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 常用控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之sys模块</title>
      <link href="/2023/07/20/Python%E4%B9%8Bsys%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/20/Python%E4%B9%8Bsys%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="sys模块介绍"><a href="#sys模块介绍" class="headerlink" title="sys模块介绍"></a>sys模块介绍</h1><blockquote><p>sys全称system系统，该模块提供了系统相关的参数和函数，这些变量和方法可供<strong>Python解释器</strong>交互，用于操控运行时的环境。</p></blockquote><h2 id="什么是Python解释器"><a href="#什么是Python解释器" class="headerlink" title="什么是Python解释器"></a>什么是Python解释器</h2><p>python是一种语言，而这种语言是对程序员来说的，计算机系统并不能理解，所以有了python解释器。</p><blockquote><p>python解释器是一个软件，用于解析和执行Python程序。</p></blockquote><p>Python解释器有多种实现：</p><ul><li><p>CPython是Python的官方解释器，它是基于C语言开发的，将Python代码解释成C语言的中间代码，然后再通过编译器将C代码转换为机器码执行。</p></li><li><p>IPython 是基于 CPython 之上的一个交互式解释器，旨在提供更快的执行速度。它通过即时编译（JIT）技术将Python代码直接转换为机器码，而不需要中间过程。</p></li><li><p>PyPy ：PyPy 解释器的目标是执行速度，它采用 JIT 技术，对 Python 代码进行动态编译，所以可以显著提高 Python 代码的执行速度。</p></li><li><p>Jython：运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。</p></li></ul><h1 id="具体功能和方法介绍"><a href="#具体功能和方法介绍" class="headerlink" title="具体功能和方法介绍"></a>具体功能和方法介绍</h1><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.python.org/zh-cn/3/library/sys.html">python官中文档</a></p><p><a href="https://blog.csdn.net/qq_53568983/article/details/127252303">python之sys模块详解</a></p><p><a href="https://blog.csdn.net/xw1680/article/details/125594820">Python 常用基础模块（四）：sys模块</a></p><h2 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sys.version<span class="comment">#还有sys.version_info</span></span><br><span class="line"><span class="comment">#一个字符串，包含Python解释器版本号加编译版本号以及所用编译器等额外信息。</span></span><br><span class="line"><span class="comment">#&#x27;3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]&#x27;</span></span><br><span class="line"></span><br><span class="line">sys.platform<span class="comment">#sys.getwindowsversion获取windows版本</span></span><br><span class="line"><span class="comment">#一个字符串，获取当前运行平台</span></span><br><span class="line"><span class="comment">#&#x27;win32&#x27;</span></span><br><span class="line">sys.executable</span><br><span class="line"><span class="comment">#字符串，当前Python解释器的可执行文件路径。在需要时执行与Python解释器相关的操作，例如调用另一个Python脚本、创建子进程等。</span></span><br><span class="line"><span class="comment">#&#x27;D:\\python\\python.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">sys.copyright<span class="comment">#版权相关的东西</span></span><br><span class="line">sys.api_version <span class="comment">#解释器的C的API版本</span></span><br><span class="line">sys.executable <span class="comment">#Python解释程序路径</span></span><br><span class="line">sys.builtin_module_names <span class="comment">#Python解释器导入的模块列表</span></span><br></pre></td></tr></table></figure><h2 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h2><p>一个列表，包含了被传递给python脚本的命令行参数。</p><ul><li>argv[0]：程序本身的路径</li><li>argv[1]：程序的第一个参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;python helloworld.py -b</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sys.argv打印结果：[<span class="string">&#x27;E:/pythoncode/helloworld.py&#x27;</span>, <span class="string">&#x27;-b&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sys.arg[0]打印结果：E:/pythoncode/helloworld.py</span></span><br></pre></td></tr></table></figure><h2 id="sys-exit"><a href="#sys-exit" class="headerlink" title="sys.exit()"></a>sys.exit()</h2><p>此方法用于退出python解释器，即退出运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正常退出程序</span></span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#非正常，参数不为0时，如下。</span></span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#作用：控制程序中途退出</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307210040585.png" alt="image-20230721004033333"></p><h2 id="sys-modules"><a href="#sys-modules" class="headerlink" title="sys.modules"></a>sys.modules</h2><p>一个字典，获取本机所有已安装的模块及所在模块文件</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307210148654.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sys.modules[<span class="string">&#x27;os&#x27;</span>]</span><br><span class="line"><span class="comment">#获取os模块列表</span></span><br><span class="line"></span><br><span class="line">sys.modules.keys()</span><br><span class="line"><span class="comment">#可遍历打印所有模块</span></span><br></pre></td></tr></table></figure><h2 id="sys-path"><a href="#sys-path" class="headerlink" title="sys.path"></a>sys.path</h2><p>一个列表，包含python相关的路径，这些是模块的搜索路径。第一项path[0]为该.py脚本所在目录。下面图片中是在控制台中，所以第一项为空字符串。</p><p><img src="blog/source/_posts/assets/image-20230721204248378.png" alt="image-20230721204248378"></p><p>作用：有时候程序运行的环境不同，模块的路径会出现问题，可以通过sys.path.append(root_path)添加到里面。</p><h2 id="sys-stdin-amp-sys-stdout-amp-sys-stderr"><a href="#sys-stdin-amp-sys-stdout-amp-sys-stderr" class="headerlink" title="sys.stdin&amp;sys.stdout&amp;sys.stderr"></a>sys.stdin&amp;sys.stdout&amp;sys.stderr</h2><p><strong>文件对象</strong>，标准输入，标准输出，错误输出</p><ul><li><code>stdin</code> 用于所有交互式输入（包括对 <a href="https://docs.python.org/zh-cn/3/library/functions.html#input"><code>input()</code></a> 的调用）；</li><li><code>stdout</code> 用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print"><code>print()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-expression">expression</a> 语句的输出，以及用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#input"><code>input()</code></a> 的提示符；</li><li>解释器自身的提示符和它的错误消息都发往 <code>stderr</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys.stdin.readline()<span class="comment">#等价于input()</span></span><br><span class="line"><span class="comment">#在交互式终端正常使用没问题，但在集成开发环境，可能无法正常工作</span></span><br><span class="line"></span><br><span class="line">sys.stdout.write()<span class="comment">#等价于print()</span></span><br><span class="line"><span class="comment">#print()函数实际上是通过sys.stdout实现的，由于print()函数在builtins.py中实现为一个内建函数，其具体实现通常由编译器或解释器负责。因此，我们不能直接查看print()函数的源代码。</span></span><br><span class="line"></span><br><span class="line">sys.stderr.write()<span class="comment">#可以在错误流中输入信息</span></span><br><span class="line"><span class="comment">#用于将错误信息输出到控制台或其他错误日志文件中。默认情况下，sys.stderr连接到控制台。</span></span><br></pre></td></tr></table></figure><h2 id="sys-getdefaultencoding"><a href="#sys-getdefaultencoding" class="headerlink" title="sys.getdefaultencoding()"></a>sys.getdefaultencoding()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sys.getdefaultencoding()</span><br><span class="line"><span class="comment">#字符串，返回当前默认字符串编码的名称</span></span><br><span class="line"><span class="comment">#&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#设置当前默认字符编码</span></span><br><span class="line"></span><br><span class="line">sys.getfilesystemencoding()</span><br><span class="line"><span class="comment">#字符串，返回当前系统中文件系统编码的名称。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>文件系统编码</strong>是指用于在操作系统文件系统中表示和存储文件名和路径的字符编码。不同的操作系统和文件系统可能使用不同的字符编码来处理文件名和路径。</p></blockquote><h2 id="sys-exc-info"><a href="#sys-exc-info" class="headerlink" title="sys.exc_info()"></a>sys.exc_info()</h2><p>元组，包含当前异常类型、异常对象和跟踪栈信息：</p><ul><li>异常类型：表示引发异常的类型。</li><li>异常对象：表示当前异常的实例对象。</li><li>跟踪栈信息：表示导致异常的函数调用栈信息</li></ul><p>举例，10&#x2F;0的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Some code that may raise an exception</span></span><br><span class="line">    result = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># Get the exception information using sys.exc_info()</span></span><br><span class="line">    exc_type, exc_value, exc_traceback = sys.exc_info()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Print the exception information</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exception type:&quot;</span>, exc_type)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Exception value:&quot;</span>, exc_value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Traceback:&quot;</span>, exc_traceback)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;输出</span></span><br><span class="line"><span class="string">Exception type: &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span></span><br><span class="line"><span class="string">Exception value: division by zero</span></span><br><span class="line"><span class="string">Traceback: &lt;traceback object at 0x7f53a472d388&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220103799.png" alt="image-20230722010328387"></p><h2 id="help-sys"><a href="#help-sys" class="headerlink" title="help(sys)"></a>help(sys)</h2><p>该文章第三节有详细翻译：<a href="https://blog.csdn.net/qq_53568983/article/details/127252303">python之sys模块详解</a></p>]]></content>
      
      
      <categories>
          
          <category> python学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> sys模块 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> python解释器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(四)控件初识</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E5%9B%9B)%E6%8E%A7%E4%BB%B6%E5%88%9D%E8%AF%86/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E5%9B%9B)%E6%8E%A7%E4%BB%B6%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="控件初识"><a href="#控件初识" class="headerlink" title="控件初识"></a>控件初识</h1><p><a href="https://doc.qt.io/qtforpython-6/modules.html">Qt for Python官方文档</a></p><p>本章对名字作简单介绍，后续解释其中重要控件的用法。</p><h2 id="所有控件"><a href="#所有控件" class="headerlink" title="所有控件"></a>所有控件</h2><p>根据Qt Designer左侧边栏顺序</p><h3 id="布局管理——Layouts"><a href="#布局管理——Layouts" class="headerlink" title="布局管理——Layouts"></a>布局管理——Layouts</h3><ul><li>VerticalLayout：垂直布局</li><li>HorizontalLayout：水平布局</li><li>GridLayout：网格布局</li><li>FormLayout：表单布局</li></ul><h3 id="弹簧——Spacers"><a href="#弹簧——Spacers" class="headerlink" title="弹簧——Spacers"></a>弹簧——Spacers</h3><ul><li>HorizontalSpacer：水平弹簧</li><li>VerticalSpacer：垂直弹簧</li></ul><h3 id="按钮类——Buttons"><a href="#按钮类——Buttons" class="headerlink" title="按钮类——Buttons"></a>按钮类——Buttons</h3><ul><li>PushButton：按钮</li><li>ToolButton：工具按钮</li><li>RadioButton：单选按钮</li><li>CheckBox：复选框</li><li>CommandLinkButton：命令链接按钮</li><li>DialogButtonBox：对话框按钮盒</li></ul><h3 id="项目视图——Item-Views-Model-Based"><a href="#项目视图——Item-Views-Model-Based" class="headerlink" title="项目视图——Item Views(Model-Based)"></a>项目视图——Item Views(Model-Based)</h3><ul><li>ListView：列表视图</li><li>TreeView：树视图</li><li>TableView：表格视图</li><li>ColumnView：列视图</li><li>UndoView：撤销命令显示视图</li></ul><h3 id="项目控件——Item-Widget-item-Based"><a href="#项目控件——Item-Widget-item-Based" class="headerlink" title="项目控件——Item Widget(item-Based)"></a>项目控件——Item Widget(item-Based)</h3><ul><li><p>ListWidget：列表控件</p></li><li><p>TreeWidget：树控件</p></li><li><p>TableWidget：表格控件</p></li></ul><h3 id="容器——Containers"><a href="#容器——Containers" class="headerlink" title="容器——Containers"></a>容器——Containers</h3><ul><li>GroupBox：分组框</li><li>ScrollArea：滚动区域</li><li>ToolBox：工具箱</li><li>TabWidget：选项卡</li><li>StackedWidget：堆栈窗口</li><li>Frame：帧</li><li>Widget：小部件</li><li>MDIArea：MDI区域</li><li>Dock Widget：停靠窗口</li></ul><h3 id="输入控件——Input-Widgets"><a href="#输入控件——Input-Widgets" class="headerlink" title="输入控件——Input Widgets"></a>输入控件——Input Widgets</h3><ul><li>ComboBox：下拉组合框</li><li>FontComboBox：字体组合框</li><li>LineEdit：单行文本框</li><li>TextEdit：多行文本框</li><li>PlainTextEdit：纯文本编辑框</li><li>SpinBow：数字选择控件</li><li>DoubleSpinBox：小数选择控件</li><li>TimeEdit：时间编辑框</li><li>DateEdit：日期编辑框</li><li>DateTimeEdit：日期时间编辑框</li><li>Dial：旋钮</li><li>HorizontalScrollBar：横向滚动条</li><li>VerticalScrollBar：垂直滚动条</li><li>HorizontalSlider：横向滑块</li><li>VerticalSlider：垂直滑块</li><li>KeySequenceEdit：按键编辑框</li></ul><h3 id="显示控件——Display-Widgets"><a href="#显示控件——Display-Widgets" class="headerlink" title="显示控件——Display Widgets"></a>显示控件——Display Widgets</h3><ul><li>Label：标签控件</li><li>TextBrowser：文本浏览器</li><li>GraphicsView：图形视图</li><li>CalendarWidget：日期控件</li><li>LCDNumber：液晶数字显示</li><li>ProgressBar：进度条</li><li>HorizontalLine：水平线</li><li>VerticalLine：垂直线</li><li>OpenGLWidget：开放式图形库工具</li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><table><thead><tr><th>Label</th><th>lab</th></tr></thead><tbody><tr><td>LineEdit</td><td>ledit</td></tr><tr><td>TextEdit</td><td>tedit</td></tr><tr><td>PlainTextEdit</td><td>pedit</td></tr><tr><td>TextBrowser</td><td>txt</td></tr><tr><td>PushButton</td><td>pbtn</td></tr><tr><td>ToolButton</td><td>tbtn</td></tr><tr><td>CommandLinkButton</td><td>linbtn</td></tr><tr><td>RadioButton</td><td>rbtn</td></tr><tr><td>CheckBox</td><td>ckbox</td></tr><tr><td>ComboBox</td><td>cbox</td></tr><tr><td>ListView</td><td>lv</td></tr><tr><td>ListWidget</td><td>lw</td></tr><tr><td>TreeView</td><td>tv</td></tr><tr><td>TreeWidget</td><td>tw</td></tr><tr><td>TableView</td><td>tbw</td></tr><tr><td>GroupBox</td><td>gbox</td></tr><tr><td>SpinBox</td><td>sbox</td></tr><tr><td>TabWidget</td><td>tab</td></tr><tr><td>TimeEdit</td><td>time</td></tr><tr><td>DateEdit</td><td>date</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 控件初识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(三)Helloworld界面</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%89)Helloworld%E7%95%8C%E9%9D%A2/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%89)Helloworld%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手写界面"><a href="#手写界面" class="headerlink" title="手写界面"></a>手写界面</h1><p><a href="https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QApplication.html#more">官方文档</a></p><ol><li>导入PySide6</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QWidget, QApplication</span><br></pre></td></tr></table></figure><p>PySide6有三个重要的模块，QtWidgets, QtGui和QtCore</p><p>QtWidgets模块就是组件类，我们用到的组件基本都在这里。</p><ol start="2"><li>实例化QApplication类</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = QApplication(sys.argv)</span><br><span class="line"><span class="comment">#sys.argv里面保存了命令行参数，这样做的目的是允许在命令行中传递一些参数给应用程序，以便进行自定义设置或功能。</span></span><br><span class="line"><span class="comment">#也可以用空列表代替</span></span><br></pre></td></tr></table></figure><p>QApplication用于管理应用程序的整个生命周期和事件循环。作用是处理小部件特定的初始化、完成、执行事件处理等。</p><ol start="3"><li>设计hello world界面</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window = QWidget()<span class="comment">#创建窗口</span></span><br><span class="line">label = QLabel(window)<span class="comment">#在窗口创建一个Label标签</span></span><br><span class="line">label.setText(<span class="string">&#x27;Hello World!&#x27;</span>)<span class="comment">#将标签内容设置为&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>显示界面并启动循环</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.show()<span class="comment">#显示window</span></span><br><span class="line">sys.exit(app.<span class="built_in">exec</span>())<span class="comment">#启动事件循环，sys.exit方法确保一个干净的退出。环境将被告知应用程序如何结束。</span></span><br></pre></td></tr></table></figure><h1 id="QtDesigner导入ui文件"><a href="#QtDesigner导入ui文件" class="headerlink" title="QtDesigner导入ui文件"></a>QtDesigner导入ui文件</h1><ol><li>Qt Designer中设计界面</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220224991.png" alt="image-20230722022429855"></p><ol start="2"><li>保存.ui文件</li></ol><p>和其他软件一样，左上角保存，保存路径最好和程序在一个地方。</p><ol start="3"><li>代码</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QWidget, QApplication</span><br><span class="line"><span class="keyword">from</span> PySide6.QtUiTools <span class="keyword">import</span> QUiLoader</span><br><span class="line"></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line"></span><br><span class="line">ui = QUiLoader().load(<span class="string">&#x27;../ui/helloworld.ui&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ui.show()</span><br><span class="line"></span><br><span class="line">sys.exit(app.<span class="built_in">exec</span>())</span><br></pre></td></tr></table></figure><ol start="4"><li><em>导入.ui文件</em></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ui = QUiLoader().load(<span class="string">&#x27;../ui/helloworld.ui&#x27;</span>)</span><br><span class="line"><span class="comment">#ui就是之前的window，只不过含义区别，之后的ui.show()说明一样。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> Helloworld界面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt教程(二)初识Qt Designer</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%88%9D%E8%AF%86Qt%20Designer/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%88%9D%E8%AF%86Qt%20Designer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><p>更新日志</p><ul><li>2023&#x2F;7&#x2F;18创建，介绍QtDesigner开发界面的使用</li></ul><h1 id="Pyqt教程-二-初识Qt-Designer"><a href="#Pyqt教程-二-初识Qt-Designer" class="headerlink" title="Pyqt教程(二)初识Qt Designer"></a>Pyqt教程(二)初识Qt Designer</h1><h2 id="新建窗体"><a href="#新建窗体" class="headerlink" title="新建窗体"></a>新建窗体</h2><p>第一次进入Qt Designer，都会要求你新建一个窗体，这和编程中的新建项目一样。界面如下：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182213027.png" alt="image-20230718221311272"></p><ul><li><p>templates\forms：模板\窗体</p><p>窗体模板主要分为三类：Main Window、Widget、Dialog。</p><p>其中Main Window提供了一个有菜单栏的工具窗口，Widget是所有界面的基类，QDialog派生自QWidget，是顶级窗口，功能也最基础。Main Window功能最全。详细进阶内容：<a href="https://blog.csdn.net/fuyuyf/article/details/126050729">widget，dialog和mainwindow</a></p></li></ul><p>Main Window：主窗口，有个菜单栏，可以显示菜单，工具栏，状态栏，托盘等功能</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182225983.png" alt="Main Window" style="zoom:50%;"><p>Widget：小部件，单独一个窗体</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182226470.png" alt="Widget" style="zoom:75%;"><p>Dialog：对话框，顾名思义，就是弹窗，提醒你确定&#x2F;取消。</p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182230237.png" alt="image-20230718223031237" style="zoom:80%;"><h2 id="Qt-Designer设计界面"><a href="#Qt-Designer设计界面" class="headerlink" title="Qt Designer设计界面"></a>Qt Designer设计界面</h2><p>新建Main window窗体后如图，左侧边栏Widget Box是部件，例如使用button按钮，只需要单击拖拽到MainWindow窗体中。中间就是你设计的窗体模样。右侧边栏是对象查看器，你在里边选用的所有部件，包括窗体，都是对象，点击对应对象，就能在下面的属性查看器中，查看该对象的属性，在这里你可以随意修改，例如调整大小、改变颜色等等，甚至还有该对象的继承内容，例如QMainWindow继承了QWidget，QWidget又继承了QObject。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182217739.png" alt="image-20230718221728649"></p><p>顶部菜单栏就不做多介绍，与其他软件类似，需要注意的是，信号与槽的相关内容在之后的章节。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182246233.png" alt="image-20230718224647031"></p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><ul><li><strong>保存为 .ui文件</strong></li></ul><p>Ctrl+S就能保存为 .ui 文件，保存路径最好为Project—&gt;ui目录下，方便调用。设置为 .ui 文件的好处是前后端分离，不会有很多重复性代码，而且界面方便、直观。</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><ul><li><strong>通过 .ui 文件初始化导入(动态加载ui文件)</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from PySide2.QtWidgets</span><br><span class="line">import * from PySide2.QtUiTools</span><br><span class="line">import QUiLoader</span><br><span class="line"></span><br><span class="line">app = QApplication([])</span><br><span class="line"></span><br><span class="line">ui = QUiLoader().load(&#x27;ui/untitled.ui&#x27;)</span><br><span class="line">ui.show()</span><br><span class="line"></span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h2 id="将-ui转化为-py代码"><a href="#将-ui转化为-py代码" class="headerlink" title="将.ui转化为.py代码"></a>将.ui转化为.py代码</h2><ol><li>设置pyuic</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220304080.png" alt="image-20230722030431636"></p><ul><li>Program：<code>E:\python\python\python.exe （你的python文件路径）</code></li><li>Arguments：<code>-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py</code></li><li>Working directory：<code>$FileDir$</code></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220305740.png" alt="image-20230722030509739"></p><ol start="2"><li>右键External Tools，选择PyUIC</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307220307706.png" alt="image-20230722030736816"></p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 初识Qt Designer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyqt5教程(一)学习路线</title>
      <link href="/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%80)%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2023/07/18/Pyqt%E6%95%99%E7%A8%8B(%E4%B8%80)%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><blockquote><p>更新日志</p><ul><li>2023&#x2F;7&#x2F;18创建，介绍Pyside2和Pyqt5的相关内容</li><li></li></ul></blockquote><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307181944356.png" alt="image-20230718194443789"></p><h2 id="章节内容"><a href="#章节内容" class="headerlink" title="章节内容"></a>章节内容</h2><ul><li><p><input disabled type="checkbox"> 第一章 学习路线</p><p>本节中包括的内容有，Python图形界面几种方案，Pyqt、Pyside2介绍以及安装，Qt Designer的安装和配置</p></li><li><p><input disabled type="checkbox"> 第二章 初识Qt Designer</p><p>Qt Designer是通过UI进行界面设计的工具，该节会介绍基本使用方法</p></li></ul><h2 id="Python图形界面开发的几种方案"><a href="#Python图形界面开发的几种方案" class="headerlink" title="Python图形界面开发的几种方案"></a>Python图形界面开发的几种方案</h2><p>如果用python语音开发跨平台的图形界面的程序，主要有三种：</p><p><strong>1、</strong>Tkinter</p><p>基于Tk的python库，优点是作为python标准库、稳定、发布程序较小，缺点是控件相对较少</p><p><strong>2、</strong>wxPython</p><p>基于wxWidgets的python库，优点是控件比较丰富，缺点是稳定性相对差、文档少、用户少</p><p><strong>3、</strong>PySide2、PyQt5</p><p>基于Qt的python库，优点是控件比较丰富、跨平台体验好、文档完善、用户多缺点是库比较大</p><h2 id="Pyside2、PyQt简介"><a href="#Pyside2、PyQt简介" class="headerlink" title="Pyside2、PyQt简介"></a>Pyside2、PyQt简介</h2><blockquote><p>PySide2、PyQt5 都是基于著名的 Qt 库。</p><p>Qt库里面有非常强大的图形界面开发库，但是Qt库是C++语言开发的，PySide2、PyQt5可以让我们通过Python语言使用Qt。</p></blockquote><ul><li><p>PySide2、PyQt5 这两者有什么区别？</p><p>Pyside2是Qt5开发而来，Pyqt5同样也是由Qt5，但Pyqt5曾经由其他公司开发，之后才被收购为义子，不过在协议上，Pyqt使用了商业和GPL许可证。商业许可可以购买，用于闭源应用程序。GPL许可证允许免费使用，但要求在应用程序中开放源代码。PySide由Qt公司开发，使用了LGPL许可证，允许用于商业闭源应用程序。所以Pyside2和Pyqt5的使用上几乎没有区别。</p><p>PyQt拥有全面的文档和丰富的社区支持。由于其商业许可证的存在，提供更深入的技术支持和示例代码。相比之下，PySide的文档相对较少，并且社区支持相对较少。</p></li></ul><p>在代码风格、导入方式、类和模块名称等方面，PyQt与PySide存在一些不同。PyQt采用类似于C++的风格，而PySide更贴近Pythonic风格。这些差异对于一些特定的用法和迁移代码可能会产生一些影响。已经在使用 PyQt5 的朋友不要皱眉， 两个库的使用对程序员来说，差别很小：它们的调用接口几乎一模一样。如果你的程序是PyQt5开发的，通常只要略作修改，比如把导入的名字从 PyQt5 换成 PySide2 就行了。反之亦然。</p><h2 id="Pyside6介绍"><a href="#Pyside6介绍" class="headerlink" title="Pyside6介绍"></a>Pyside6介绍</h2><p>Pyside6是由C++的Qt6开发而来，同样的，也存在Pyqt6。该公司从Pyside2直接跳到了Pyside6，也就是说从PySide6开始，PySide的命名也会与Qt的大版本号保持一致。</p><p>只需要注意一点，使用PySide6开发的程序在默认情况下不兼容Windows7系统，这也是Qt6所决定的（即使是C++的QT6也不支持windows7）。</p><p>内容取自<a href="https://blog.csdn.net/qianbin3200896/article/details/126947934">PySide6精简教程</a></p><h2 id="Pyside安装"><a href="#Pyside安装" class="headerlink" title="Pyside安装"></a>Pyside安装</h2><p>直接执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install pyside2</span><br><span class="line"></span><br><span class="line">可以指定安装源</span><br><span class="line">pip install pyside2 -i https://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line">#PySide6安装</span><br><span class="line">pip install pyside6 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="PyQt5和Qt-Designer安装"><a href="#PyQt5和Qt-Designer安装" class="headerlink" title="PyQt5和Qt Designer安装"></a>PyQt5和Qt Designer安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br><span class="line">#可同时安装 PyQt5 和 一些重要的工具，比如 Qt designer</span><br><span class="line"></span><br><span class="line">可以指定安装源</span><br><span class="line">pip install PyQt5-tools -i https://pypi.douban.com/simple</span><br><span class="line"></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt6</span><br></pre></td></tr></table></figure><h2 id="Qt-Designer配置使用"><a href="#Qt-Designer配置使用" class="headerlink" title="Qt Designer配置使用"></a>Qt Designer配置使用</h2><ul><li><strong>将QtDesinger集成到Pycharm</strong></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182020782.png"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182021219.png"></p><ul><li><strong>通过安装路径手动打开QtDesinger</strong></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307182021828.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pyqt教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Pyqt </tag>
            
            <tag> Pyside </tag>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用qq昵称给消息加后缀</title>
      <link href="/2023/07/15/%E5%88%A9%E7%94%A8qq%E6%98%B5%E7%A7%B0%E7%BB%99%E6%B6%88%E6%81%AF%E5%8A%A0%E5%90%8E%E7%BC%80/"/>
      <url>/2023/07/15/%E5%88%A9%E7%94%A8qq%E6%98%B5%E7%A7%B0%E7%BB%99%E6%B6%88%E6%81%AF%E5%8A%A0%E5%90%8E%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="利用qq昵称给消息加后缀"><a href="#利用qq昵称给消息加后缀" class="headerlink" title="利用qq昵称给消息加后缀"></a>利用qq昵称给消息加后缀</h1><blockquote><p>日志</p><ul><li>初次发布：2020-04-02</li></ul><p>利用RLO和LRO修改qq昵称，达到给消息加后缀的效果。</p><ul><li>方法失效：2023年左右</li></ul><p>qq昵称不在支持上面的方法，无法保存修改后的昵称</p><ul><li>更新方法：2023-07-15</li></ul><p>利用RLI和LRI，但仅支持符号，文字不在支持，可以用颜文字做后缀</p></blockquote><blockquote><p>只有手机端显示有特殊效果，电脑没有</p></blockquote><h2 id="利用RLO和LRO修改qq昵称"><a href="#利用RLO和LRO修改qq昵称" class="headerlink" title="利用RLO和LRO修改qq昵称"></a>利用RLO和LRO修改qq昵称</h2><p>视频链接: <a href="https://www.bilibili.com/video/BV1Qc41187jM">利用qq昵称给你的消息加特效</a></p><p><strong>该方法已经失效</strong></p><h2 id="利用RLE和LRE修改qq昵称"><a href="#利用RLE和LRE修改qq昵称" class="headerlink" title="利用RLE和LRE修改qq昵称"></a>利用RLE和LRE修改qq昵称</h2><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><ol><li>打开记事本，输入昵称</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150141899.png" alt="image-20230715014114413"></p><ol start="2"><li>右键RLE，反向输入颜文字，例如?_?（显示Unicode控制字符可以打开）</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150145756.png" alt="image-20230715014555162"></p><p>效果如图：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150150982.png" alt="image-20230715015011075"></p><ol start="3"><li>确保光标位置正确，右键LRE，粘贴即可</li></ol><p>上一个步骤完成后，我们可以粘贴到我的群昵称看一下，出现下面效果说明成功（手机接收）</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150157127.jpg"></p><blockquote><p>PS：asd是我发的消息</p></blockquote><p>看似成功了，但“：”在发的消息“asd”后，所以要进行第三步，<strong>易错！！！</strong></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150201441.png" alt="image-20230715020133572"></p><p>单击箭头处，确保光标在这个位置，<strong>轻轻按一下右方向键</strong>，光标没有向右一格，证明位置是对的，这时候右键插入LRE或LRO，如果光标移动到末尾，说明成功，粘贴复制即可完成。(可以再按一下方向键，这时候如果右移一格，则再按左方向键退回去，不要问为什么，我也不知道，试出来的)</p><p>结果如下：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150211762.jpg"></p><blockquote><p>“你在干神魔”是我发的消息</p></blockquote><h2 id="复杂非对称后缀"><a href="#复杂非对称后缀" class="headerlink" title="复杂非对称后缀"></a>复杂非对称后缀</h2><blockquote><p>以该表情为例＼(&#96;Δ’)／</p></blockquote><p>按以上步骤结果为：(演示有点小瑕疵，不太影响结果)</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150238503.png" alt="image-20230715023807954"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150223404.jpg"></p><p>可以看到表情反向了，所以在输入的时候要反着来</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150233317.png" alt="image-20230715023346531"></p><p>这样结果就是完美的。</p><h2 id="消息反转"><a href="#消息反转" class="headerlink" title="消息反转"></a>消息反转</h2><p>以前是可以的，现在不行</p><p>反转就是发一句“你好”，就会变成“好你”，这就是消息反转</p><p>原理是通过仅右键插入RLO字符，不做其他操作，但由于qq不再能粘贴带有RLO控制字符的文字，所以已经失效。</p><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol><li>自问：有的颜文字为什么不行？</li></ol><p>目前颜文字中，带有汉字、字母和一些特别的符号都是不适用的，需要注意。但好在常见中文符号和英文符号是没问题的，足以支撑大部分颜文字。</p><p>其他问题评论区可以提问</p>]]></content>
      
      
      <categories>
          
          <category> 有趣的发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qq消息 </tag>
            
            <tag> 后缀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github使用技巧</title>
      <link href="/2023/07/10/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/07/10/GitHub%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、在项目地址前加上gitpod.io&#x2F;#&#x2F;前缀</p><ul><li>会在一个网页板vs中加载，并且自动识别项目类型、使用技术，自动安装依赖包，直接可以在上面操作。</li></ul><p>2、高级搜索</p><p>3、查找文件</p><ul><li><ul><li>在主页按“t”：查找文件</li></ul></li><li><ul><li>点进源代码后，按“l”：跳转到某一行</li></ul></li><li><ul><li>点击行号：</li></ul></li><li><ul><li><ul><li>复制这行代码</li></ul></li><li><ul><li>生成永久链接</li></ul></li></ul></li></ul><p>源代码中按“b”：查看文件的改动记录</p><p>键盘快捷键：<a href="https://blog.csdn.net/ONLYSRY/article/details/124753220">https://blog.csdn.net/ONLYSRY/article/details/124753220</a></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 使用技巧 </tag>
            
            <tag> 使用教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问网站背后过程</title>
      <link href="/2023/07/09/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E8%83%8C%E5%90%8E%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/07/09/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E8%83%8C%E5%90%8E%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="访问网站背后过程"><a href="#访问网站背后过程" class="headerlink" title="访问网站背后过程"></a>访问网站背后过程</h1><blockquote><p>解释访问过程之前，首先要了解<strong>计算机网络的基础知识</strong>和<strong>网站部署过程</strong></p></blockquote><h2 id="计算机网络基础知识"><a href="#计算机网络基础知识" class="headerlink" title="计算机网络基础知识"></a>计算机网络基础知识</h2><p>主要了解TCP五层模型：<a href="/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="计算机网络基础知识">相关文章链接，点击这里</a></p><h2 id="网站是如何部署的？"><a href="#网站是如何部署的？" class="headerlink" title="网站是如何部署的？"></a>网站是如何部署的？</h2><ol><li>准备服务器：首先，需要选择一个安全可靠的服务器，购买服务器的空间，包括服务器类型、带宽、存储空间和机房等。</li><li>配置环境：安装服务器所需的操作系统、Web 服务器（如Apache、Nginx等）和数据库（如MySQL、PostgreSQL、MongoDB等）等必要组件，配置相关的服务。</li><li>部署代码：将编写好的网站代码上传至服务器，通过Web服务器将代码部署到服务器上。此时，通常需要将网站的<strong>域名</strong>和<strong>IP地址</strong>绑定，使访问该域名的用户能够正确访问该网站。</li><li>域名购买和解析：在国内购买域名，并在 DNS 解析商处将域名解析到服务器的 IP 地址上。</li><li>网站备案：在国内部署网站，需要进行备案手续，主要包括备案材料的准备以及在当地官方网站进行系统备案。</li><li>数据库配置：如果网站使用了数据库，将需要创建网站对应的数据库、配置数据库连接和数据表等基础操作。</li><li>调试：部署完成后，需要进行测试和调试，包括测试网站在不同浏览器下的兼容性、测试代码的漏洞和安全性、测试服务器的稳定性和性能等等。</li></ol><h2 id="网站的访问过程经历哪些步骤"><a href="#网站的访问过程经历哪些步骤" class="headerlink" title="网站的访问过程经历哪些步骤"></a>网站的访问过程经历哪些步骤</h2><h3 id="DNS域名解析协议"><a href="#DNS域名解析协议" class="headerlink" title="DNS域名解析协议"></a>DNS域名解析协议</h3><blockquote><p>将域名解析为ip地址。</p></blockquote><ul><li><input disabled type="checkbox"> 什么是DNS？<ul><li>一个由分层的DNS服务器实现的分布式数据库</li><li>一个使得主机能够查询分布式数据库的应用层协议</li></ul></li></ul><p>DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP和FTP，</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="Users\神殒魔灭\AppData\Roaming\Typora\typora-user-images\image-20230624000722342.png" alt="image-20230624000722342"></p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><blockquote><p>这个请求中包含了请求的方式（GET或POST）、请求头（告诉服务器浏览器的类型、支持的压缩格式等信息）和请求体（如果是POST请求，将提交数据）。</p></blockquote><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><blockquote><p>一旦服务器收到请求，它会进行处理并返回响应。响应也包含了HTTP状态码（如200表示成功，404表示未找到页面等）和响应头（如服务器类型、响应时间和数据类型等信息）。</p></blockquote><h3 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h3><blockquote><p> 一旦浏览器收到响应，它会对响应进行处理和解析，并将结果渲染在用户界面中。</p></blockquote><h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><blockquote><p>一旦所有数据都传输完毕，浏览器会关闭TCP连接，释放资源，此时用户与服务器的通信就结束了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识</title>
      <link href="/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络基础知识"><a href="#计算机网络基础知识" class="headerlink" title="计算机网络基础知识"></a>计算机网络基础知识</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><p><input checked disabled type="checkbox"> 什么是因特网？</p><ul><li>从因特网构成角度：它是一个互联了全世界数十亿计算机设备的网络。这些设备被称为<strong>主机</strong>或<strong>端系统</strong>。<ul><li>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起</li><li>分组交换机中最著名的两种类型是<strong>路由器</strong>和<strong>链路交换机</strong></li><li>端系统通过<strong>因特网服务提供商</strong>接入因特网</li><li><strong>协议</strong>控制因特网信息的接收和发送</li></ul></li><li>从为应用程序提供基础设施服务角度：<ul><li>套接字接口(socket interface)是一种端系统之间交付数据的方式，类似邮件要写清地址。</li></ul></li></ul></li><li><p><input checked disabled type="checkbox"> 什么是协议？</p><p>协议定义了两个通信实体之间交换的报文的格式和顺序，以及报文发送或接收一条报文或其他事件所采取的动作。</p></li></ul><h2 id="计算机网络的部件"><a href="#计算机网络的部件" class="headerlink" title="计算机网络的部件"></a>计算机网络的部件</h2><ul><li><p>端系统包括桌面计算机、服务器和移动计算机等。</p></li><li><p>主机被划分为客户(client)和服务器(server)</p></li><li><p><input checked disabled type="checkbox"> 什么是接入网？</p><p>将端系统物理连接到<strong>边缘路由器</strong>的网络称为接入网。边缘路由器是通信路径上的第一台路由器。</p></li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="TCP五层模型"><a href="#TCP五层模型" class="headerlink" title="TCP五层模型"></a>TCP五层模型</h3><ol><li><p>应用层</p><ul><li>HTTP：Web文档请求和传送</li><li>SMTP：电子邮件报文的传输</li><li>FTP：两个端系统间的文件传送</li><li>DNS：用于域名解析，将域名转换为IP地址</li></ul></li><li><p>运输层</p><blockquote><p>提供端到端的数据传输服务。</p><p>它为应用程序提供了可靠、流畅的数据传输服务，并在网络传输过程中保证数据的正确性和可靠性。</p></blockquote><ul><li>TCP：传输控制协议，可靠的、面向连接的数据传输服务。它将数据分割成报文段，并提供流量控制、拥塞控制、序号管理和重传机制等功能。</li><li>UDP：用户数据报协议，无连接的数据传输服务，它不保证数据传输的正确性和可靠性，但具有快速、轻量的优点，常用于实现音频、视频和网络游戏等实时应用。</li></ul></li><li><p>网络层</p><blockquote><p>负责将称为<strong>数据报</strong>的网络层分组从一台主机移动到另一台主机。</p></blockquote><ul><li>IP：互联网协议，定义数据报中各字段的作用</li><li>ARP：地址解析协议</li><li>RARP：逆地址解析协议</li></ul></li><li><p>链路层</p><blockquote><p>负责在相邻节点间传送数据帧，并提供一些错误监测和矫正功能。</p></blockquote><ul><li>Ethernet：以太网协议</li><li>Wi-Fi：无线协议</li></ul></li><li><p>物理层</p><blockquote><p>负责在物理媒介上传输比特流。</p></blockquote></li></ol><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><blockquote><p>应用层、表示层、会话层、运输层、网络层、数据链路层、物理层</p></blockquote><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307091857461.png" alt="image-20230622212604893"></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307091857774.png" alt="image-20230622212652909"></p>]]></content>
      
      
      <categories>
          
          <category> web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云OSS+PicGO图床教程</title>
      <link href="/2023/07/07/%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/07/07/%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><h2 id="什么是图床？"><a href="#什么是图床？" class="headerlink" title="什么是图床？"></a>什么是图床？</h2><blockquote><p>图床简单来说就是在云端用来储存图片的空间。实际上图床是个服务器，它能把你的图片存储进去，提供url供人访问。</p></blockquote><p>国内图床也分为单线空间、多线空间和cdn加速三种。</p><h2 id="为什么需要图床？"><a href="#为什么需要图床？" class="headerlink" title="为什么需要图床？"></a>为什么需要图床？</h2><p>从写博客的角度：markdown文章中的图片一般存放在本地的文件夹中，在本地访问可以根据绝对路径和相对路径找到图片，但如果上传到网络上，本地路径就无法被直接识别，需要将其打包放到服务器中，但是图片太多不仅会占用空间，还会增加图片访问的压力。而图床等采用<strong>分布式存储</strong>和<strong>CDN加速</strong>，能提供稳定和快速的图片访问体验。</p><p>从其他角度：存储在云端比本地安全性更高(只要服务提供商不倒闭)，能随时随地供任何人访问，节省本地空间。</p><h2 id="如何使用图床？"><a href="#如何使用图床？" class="headerlink" title="如何使用图床？"></a>如何使用图床？</h2><ul><li>阿里云OSS(对象存储服务)</li></ul><blockquote><p>阿里云对象存储服务相当于数据库，用来存放图片的服务器，也就是图床</p></blockquote><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071210488.png" alt="image-20230707121030448"></p><ul><li>PicGO</li></ul><p>picgo是个图形化界面程度，方便上传和查看图片</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071208899.png" alt="image-20230707120802360"></p><ul><li>Typora</li></ul><p>markdown编辑器，可以调整配置，使其自动上传到图床</p><p>具体教程：<a href="https://zhuanlan.zhihu.com/p/573215104">知乎图床教程</a></p><h2 id="主要出现的Bug"><a href="#主要出现的Bug" class="headerlink" title="主要出现的Bug"></a>主要出现的Bug</h2><h3 id="PicGo报错"><a href="#PicGo报错" class="headerlink" title="PicGo报错"></a>PicGo报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2023-07-02 01:10:14 [PicGo ERROR] &#123;</span><br><span class="line">  &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https://sm.ms/api/v2/upload&quot;,</span><br><span class="line">  &quot;statusCode&quot;: 0,</span><br><span class="line">  &quot;message&quot;: &quot;connect ETIMEDOUT 46.82.174.69:443&quot;,</span><br><span class="line">  &quot;stack&quot;: &quot;Error: connect ETIMEDOUT 46.82.174.69:443\n    at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1146:16)&quot;,</span><br><span class="line">  &quot;response&quot;: &#123;</span><br><span class="line">    &quot;status&quot;: 0,</span><br><span class="line">    &quot;statusCode&quot;: 0,</span><br><span class="line">    &quot;body&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>不知道什么问题，在PicGo设置默认图床就好了</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307020140230.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云OSS </tag>
            
            <tag> 图床 </tag>
            
            <tag> PicGO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电子坟墓 赛博墓碑</title>
      <link href="/2023/07/06/%E8%B5%9B%E5%8D%9A%E5%9D%9F%E5%A2%93%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/07/06/%E8%B5%9B%E5%8D%9A%E5%9D%9F%E5%A2%93%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="电子坟墓-赛博墓碑"><a href="#电子坟墓-赛博墓碑" class="headerlink" title="电子坟墓-赛博墓碑"></a>电子坟墓-赛博墓碑</h1><h2 id="想法起源"><a href="#想法起源" class="headerlink" title="想法起源"></a>想法起源</h2><p>此想法起源于b站弹幕，经常有人在精彩视频里面发送弹幕，“做成二维码刻在墓碑上”，就像有趣的墓志铭一样。当然这是一句玩笑话，并不现实，因为墓碑主要用来总结一生，或者这一生的高光经历。</p><p>人的一生很长，墓碑能记录的东西很少，在人生的不同阶段会发生很多有纪念意义的事情。事实上，对于我个人来说，我非常渴望能把我这一生的大小事情都记录下来，而且目前使用网络来记录也比较方便，例如vlog、文章和照片，这也是我写博客的原因。</p><p>墓文和博客却又不一样，博客记录大大小小的事情，而墓文总结人生的一个阶段。在我的认为中，人们都希望有或者说需要有总结一段人生的需求，就像大多数人喜欢做年末总结一样。此外，人们也渴望在死后能有更丰富更清晰的人生结语，而不是墓碑上简简单单的几句话。</p><p>现实中的墓碑显然不能满足这个需求，甚至土葬也在渐渐消失。但网络能满足这种需求，甚至还能网上扫墓（XD），唯一缺失的，可能是在祖祠祭拜先人的仪式感，这确实少了很多文化韵味。但仔细想想，两者也不冲突，祠堂是给后辈祭拜的，电子坟墓是给他人观看并丰富生平，两者可以认为是互补的关系。而且电子坟墓活人也在用，祠堂可不能祭拜活人(dog)。</p><h3 id="对比印证"><a href="#对比印证" class="headerlink" title="对比印证"></a>对比印证</h3><h4 id="数字墓碑"><a href="#数字墓碑" class="headerlink" title="数字墓碑"></a>数字墓碑</h4><blockquote><p>虽然国内外都存在数字墓碑，但完全是两个不同的东西。</p></blockquote><p>国外存在类似的数字墓碑，就是将墓碑上放一个电子大屏，并且提供链接，通过网站得到更详细的内容，目的是为了展示更多生平经历。</p><p><a href="https://www.kankanews.com/detail/7my5RMjz0Q9">新闻：斯洛文尼亚出现世界首座数字化墓碑 未来殡葬业的趋势？</a></p><p>缺点：</p><ul><li>贵：电费、维护费都不是一般人能承受</li><li>电子屏无太大意义：和博物馆一样的模式，但博物馆展览面向游客，游客群体本就是带有观看目的，个人墓碑对于他人来说，看不看都无所谓，不如改成二维码，直接让想观看的人通过网站浏览</li><li>没有社群：如果观看的人只有路过的行人，实在没必要做这些。所以为了让更多人看，最好有社群，哪怕是弄个公墓将所有墓碑数字化，都能吸引人观看。当然最好还是建立网上社群，这样会有更多人观看。（这点说的不清楚，看完全文或许你会懂）</li></ul><p>国内的数字墓碑出现比较靠后，因为土葬、海葬之类的，要么有政府的政策，要么太贵，所以有些公司提供了数字墓碑服务(也挺贵)，具体如下链接，吐槽太多了。</p><p><a href="https://baijiahao.baidu.com/s?id=1762310709894768361&wfr=spider&for=pc">北京首推数字科技殡葬：占地小，祭扫不用到现场，有人提前为自己做电子墓碑</a></p><p>缺点(太多槽点了)：</p><ul><li>给你做个电子屏，然后整个生平视频放上，里面存骨灰，没什么太大意义</li><li>一块小电子屏展示东西也没多少，视频天天播放也不智能，还费电，如果做个巨长的视频，说不定自己的后人都懒得看完，这点还要看国外，弄个网站用文字记录会更好，还能被其他人观看。</li><li>看完介绍我只想说冤大头 XD</li></ul><h2 id="后续设想"><a href="#后续设想" class="headerlink" title="后续设想"></a>后续设想</h2><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>首先要用到地图，坟墓通常和家乡位置关系密切，电子坟墓必须也和现实一样，有一个“下葬点”。点击就能跳转到个人坟墓中。</p><p>坟墓包含的因素：</p><ul><li>周边环境：图片、3D、背景图</li><li>坟包：坟头草、冒青烟之类的，XD</li><li>墓碑：允许个人创作<ul><li>个人信息：姓名、出生及死亡年月（隐藏：照片、性别、身份证号）</li><li>墓志铭&amp;生平简介：墓志铭是个有趣的东西，保留。活人可以把生平改成自我介绍，死后变为生平简介。</li><li>二维码&amp;链接：存放视频、图片、网站，用于更详细的人生经历。</li><li>其他阶段：墓碑可以有多个阶段，按时间例如0-12岁、12-18岁等，埋葬过去，也可以描述不同的自己，例如工作、家庭、情感。</li></ul></li><li>评论区：浏览交互是构建这个墓群社区的重点</li></ul><h2 id="盈利"><a href="#盈利" class="headerlink" title="盈利"></a>盈利</h2><p>做服务还得盈利，不然网站倒闭啥都没</p><ul><li><p>坟墓可以买出价格，必须便宜，如果不能有足够的用户，根本活不了，而且不能做位置限制，出现炒地皮那种，因为哪块地理位置好，被人全包然后倒卖，与身份证绑定最好</p></li><li><p>其他在其他服务我们可以提供一些进阶内容，比如坟墓样式的定制，买断等等</p></li><li><p>提供交易，收取手续费</p></li></ul><p>盈利方式选择很多，我就少说点我的智障想法吧，评论区可以留言说说想法。</p><h2 id="难点痛点"><a href="#难点痛点" class="headerlink" title="难点痛点"></a>难点痛点</h2><p>本质上，该想法有一部分原因，是用来解决现实中坟墓太贵和土地紧张的问题，重点在于人们愿不愿意接受这种形式。让人们彻底抛弃实体坟墓，拥抱虚拟坟墓，这非常困难，原因很简单，谁也不想来这世间一趟，什么痕迹都没留下，而人死后，最能留下、而且最能代表自身的东西就是坟墓了，所以不让大家下葬立坟，这点根本是无法接受。</p><p>所以本质上，人只是想留下自己存在过的证明，留下被后人或他人铭记的东西，电子坟墓当然不能完全满足这一点，但它满足了墓碑，满足了墓碑记录自己生平的需求。对比火葬和土葬，如果不是有限制，多数人更希望土葬，谁不想死后有片大点的地方供后人祭拜，有块墓碑记录自己的生平，相比在小小的骨灰盒，那多气派。</p><p>而赛博墓碑，首先生平记录能更多，其次在社群中，他人也能看到自己的坟墓，留下留言，坟墓上即使是虚拟的，我们也可以弄得很华丽，留言得到很多人的关注，同样是一种气派。代替了这么多内容，最后也就剩一个后人祭拜的意义了，这点对于人来说，棺材还是骨灰盒都一样了。</p>]]></content>
      
      
      <categories>
          
          <category> 想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
            <tag> 想法 </tag>
            
            <tag> 电子坟墓 </tag>
            
            <tag> 赛博墓碑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo教程(一)搭建初始博客</title>
      <link href="/2023/07/01/Hexo%E6%95%99%E7%A8%8B(%E4%B8%80)%E6%90%AD%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/07/01/Hexo%E6%95%99%E7%A8%8B(%E4%B8%80)%E6%90%AD%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo教程–搭建初始博客"><a href="#Hexo教程–搭建初始博客" class="headerlink" title="Hexo教程–搭建初始博客"></a>Hexo教程–搭建初始博客</h1><h2 id="什么是Hexo？"><a href="#什么是Hexo？" class="headerlink" title="什么是Hexo？"></a>什么是Hexo？</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><h2 id="搭建blog步骤"><a href="#搭建blog步骤" class="headerlink" title="搭建blog步骤"></a>搭建blog步骤</h2><h3 id="安装node-js-npm-hexo"><a href="#安装node-js-npm-hexo" class="headerlink" title="安装node.js\npm\hexo"></a>安装node.js\npm\hexo</h3><h3 id="用hexo创建初始页面"><a href="#用hexo创建初始页面" class="headerlink" title="用hexo创建初始页面"></a>用hexo创建初始页面</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一个博客文件夹</span><br><span class="line">mkdir D:/blog</span><br><span class="line">键入初始化命令</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>输入命令后blog文件夹中会生成以下内容</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071239600.png" alt="image-20230626083925791"></p><p>键入命令<code>hexo generate</code> ，生成静态页面文件</p><p>本地启动Hexo服务器，进行预览调试，键入命令：<code>hexo server</code></p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071239480.png" alt="image-20230626103840220"></p><h3 id="在GitHub上部署"><a href="#在GitHub上部署" class="headerlink" title="在GitHub上部署"></a>在GitHub上部署</h3><ul><li><p>在github上创建一个新项目，命名必须规范shenyunmomie.github.io</p></li><li><p>在博客文件夹安装hexo-deployer-git自动部署发布工具</p><p><code>npm install hexo-deployer-git  --save</code></p></li><li><p>修改_config.yml文件</p></li></ul><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071239351.png" alt="image-20230626185859658"></p><ul><li><p>部署到远端GitHub</p><p><code>hexo d</code></p><blockquote><p>部署到远端时候，有时候会被墙，显示超时连接，就连科学上网也不总是管用，可以等一会多试几次</p></blockquote></li><li><p>访问博客网站</p><p><code>https://shenyunmomie.github.io/</code></p></li></ul><h2 id="theme更换主题"><a href="#theme更换主题" class="headerlink" title="theme更换主题"></a>theme更换主题</h2><p><strong>以butterfly主题为例</strong></p><ul><li><p>首先去官网查看教程</p><p><code>https://butterfly.js.org/</code></p></li><li><p>clone主题butterfly到theme目录</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240662.png" alt="image-20230628092154279"></p><p><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p></li><li><p>修改配置文件，更换应用主题</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240846.png" alt="image-20230628092302611"></p></li><li><p>安装渲染插件，如果没有界面只有文字显示</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240620.png" alt="image-20230628092350862"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也可以单独安装</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure></li><li><p>PS：建议</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240560.png" alt="image-20230628092518530"></p></li><li><p>将博客重新部署到远端，访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071240839.png" alt="image-20230628092652068"></p></li></ul><h2 id="Hexo使用命令"><a href="#Hexo使用命令" class="headerlink" title="Hexo使用命令"></a>Hexo使用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新建文章</span><br><span class="line">hexo n &quot;第一篇文章&quot;</span><br><span class="line"></span><br><span class="line">新建后需要hexo g重新生成</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>部署的时候如果报错</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307071241682.png" alt="image-20230707124141060"></p><p>先登录GitHub(二选一)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global      user.email &quot;18731548870@163.com&quot;</span><br><span class="line"></span><br><span class="line">git config --global      user.name &quot;shenyunmomie&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>RLI我也没找到，待验证</li></ol><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307150322376.png" alt="image-20230715032217193"></p>]]></content>
      
      
      <categories>
          
          <category> 学习教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo教程(二)博客写作</title>
      <link href="/2023/06/28/Hexo%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/"/>
      <url>/2023/06/28/Hexo%E6%95%99%E7%A8%8B(%E4%BA%8C)%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[TOC]</p><h1 id="Hexo-Butterfly主题界面"><a href="#Hexo-Butterfly主题界面" class="headerlink" title="Hexo|Butterfly主题界面"></a>Hexo|Butterfly主题界面</h1><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><blockquote><p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个別文档的变量。</p></blockquote><h3 id="Page-Front-matter-用于页面配置"><a href="#Page-Front-matter-用于页面配置" class="headerlink" title="Page Front-matter 用于页面配置"></a>Page Front-matter 用于页面配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">*title:</span> <span class="string">页面标题</span></span><br><span class="line"><span class="string">*date:</span> <span class="string">页面创建日期</span></span><br><span class="line"><span class="attr">updated:</span> <span class="string">页面更新日期</span></span><br><span class="line"><span class="string">*type:</span> <span class="string">标签、分类和友情连接三个页面需要配置</span></span><br><span class="line"><span class="attr">comments:</span> <span class="string">显示页面评论模块</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">页面描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">页面关键字</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">页面顶部图片</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="string">显示mathjax</span></span><br><span class="line"><span class="attr">katex:</span> <span class="string">显示katex</span></span><br><span class="line"><span class="attr">aside:</span> <span class="string">显示侧边栏</span></span><br><span class="line"><span class="attr">aplayer:</span> <span class="string">在需要的页面加载aplayer的js和css</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="string">配置代码框是否展开</span></span><br><span class="line"><span class="attr">random:</span> <span class="string">配置友情连接是否随机排序</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="Post-Front-matter用于文章页配置"><a href="#Post-Front-matter用于文章页配置" class="headerlink" title="Post Front-matter用于文章页配置"></a>Post Front-matter用于文章页配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">abcjs:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="写作技巧"><a href="#写作技巧" class="headerlink" title="写作技巧"></a>写作技巧</h2><h3 id="标签插件的原理"><a href="#标签插件的原理" class="headerlink" title="标签插件的原理"></a>标签插件的原理</h3><blockquote><p>本文写作技巧是指，在编写文章时，我们有时候需要引用其他文章，或是使用md文件中未提供的语法。</p></blockquote><p>你所记录的markdown文章，在网页端是以html格式呈现的，这点可以在网站中右键–&gt;检查，进入开发者窗口验证。</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307092023198.png" alt="image-20230709202301577"></p><p>所以在md文件–&gt;html网页过程中，我们可以通过添加代码，来实现markdown语法中不提供的功能，例如hexo提供了**标签插件(Tag Plugins)**，举例说明此服务的原理：</p><p>我们知道，markdown语法是不支持插入视频的，最多通过网页链接实现，而通过标签插件，我们可以在md文件中添加</p><p><code>&#123;% youtube video_id [type] [cookie] %&#125;</code></p><ul><li>youtube：表示从YouTube网站拿取视频</li><li>video_id：youtube网站的视频号</li><li>type：‘playlist’，播放列表，video_id有多个视频号时(猜的)</li><li>cookie：boolean值，表禁用YouTube的cookie(不知道干嘛的)</li></ul><p>hexo看到md文件中的<code>&#123;%%&#125;</code>，就知道要做什么，会自动插入相关前端代码，在浏览器中展示到用户面前，效果类似下图：</p><p><img src="https://shenyunmomie.oss-cn-beijing.aliyuncs.com/imags/202307092046315.png" alt="image-20230709204630898"></p><blockquote><p>markdown语法是允许直接添加html代码的，不过hexo为避免其他因素的影响，也提供了raw语法。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"><span class="code">&lt;html代码&gt;</span></span><br><span class="line"><span class="code">&#123;% endraw %&#125;</span></span><br></pre></td></tr></table></figure><p>所以标签插件本质上可以理解为，就是添加了些前端代码，用来实现某些功能。</p><h3 id="官方文档内容一览"><a href="#官方文档内容一览" class="headerlink" title="官方文档内容一览"></a>官方文档内容一览</h3><p><a href="https://hexo.io/zh-cn/docs/writing">hexo官方文档</a></p><p>主要内容大纲：</p><ul><li><p>写作</p><ul><li>布局(Layout)：标明是哪种页面，例如post(文章页)、draft(草稿页)、page(导航标签页)和tag(标签页)等等，hexo g时候会渲染成对应页面。theme主题会提供更多Layout。详细文章：<a href="https://www.jianshu.com/p/5a1e6d8c83af">初步了解Hexo站点的布局</a></li><li>模板(Scaffold)：文章需要预设置Front-matter，模板就是提前设置好，新建时直接拿用。</li></ul></li><li><p>Front-matter</p><ul><li><p>官方文档和主题文档都有介绍</p></li><li><p>分类和标签</p><p><strong>分类方法的误区</strong>：分类具有顺序性和层次性，Hexo 不支持指定多个同级分类。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Life</span></span><br><span class="line"><span class="comment"># 分类Life是Diary的子分类，而不是并列分类。</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">PlayStation</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">Games</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Life</span>]</span><br><span class="line"><span class="comment"># PlayStation和Games分别都是父分类Diary的子分类，同时Life是一个没有子分类的分类。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>标签插件</p><ul><li>大概浏览一遍，记下有需要的即可</li><li>插入图片，能调整大小<code>&#123;% asset_img [class类名] 路径 [width] [height] %&#125;</code></li></ul></li><li><p>资源文件夹</p><ul><li>用处不大，说的是创建文章时，可以自动创建一个新文件夹用来储存&amp;调用。我图片一般用图床，很少存储到本地，这会出现一些不方便的问题。</li></ul></li><li><p>数据文件夹</p><ul><li><p>在写md文章时，假设我有一份人员名单文件(数据文件,YAML 或 JSON 格式)，我想在md文章中打印出来，除了复制粘贴，我们可以用脚本片段代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">for</span> (<span class="keyword">var</span> link <span class="keyword">in</span> site.<span class="property">data</span>.文件名) &#123; %&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= site.data.文件名[link] %&gt;&quot;</span>&gt;</span> &lt;%= link %&gt; <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line"># data为数据文件夹</span><br></pre></td></tr></table></figure></li></ul></li><li><p>服务器</p><ul><li>hexo server相关内容，过一遍即可</li></ul></li><li><p>生成器</p><ul><li>hexo generate相关命令，看看即可</li></ul></li><li><p>辅助函数</p><ul><li>和前端知识相关性较大，属于进阶知识</li></ul></li><li><p>插件</p><ul><li>需要自己写一些插件时，可以仔细看看。详细教程：<a href="https://www.ngui.cc/el/558918.html?action=onClick">Hexo高级教程之插件开发</a></li></ul></li><li><p>主题、模板、变量都需要了解</p><ul><li>更多相关教程：<a href="https://www.bilibili.com/read/cv5778979/">hexo主题开发</a></li></ul></li></ul><p><a href="https://butterfly.js.org/posts/21cfbf15/">butterfly主题官方文档</a>，内容较多，需一步步按照自己喜欢的样式修改，这里提几个关键内容：</p><ul><li>Butterfly 安裝文檔(二) 主題頁面<ul><li>标签页</li><li>分类页</li><li>友情链接</li></ul></li><li>Butterfly 安裝文檔(三) 主題配置-1<ul><li>标签外挂的用法</li></ul></li><li>Butterfly 安裝文檔(四) 主題配置-2<ul><li>搜索</li><li>评论</li><li>inject</li></ul></li><li>Butterfly 安裝文檔(六) 進階教程<ul><li>Icon</li></ul></li></ul><h3 id="在文章中引用另一篇文章"><a href="#在文章中引用另一篇文章" class="headerlink" title="在文章中引用另一篇文章"></a>在文章中引用另一篇文章</h3><h4 id="markdown语法引用链接"><a href="#markdown语法引用链接" class="headerlink" title="markdown语法引用链接"></a>markdown语法引用链接</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">文字标题</span>](<span class="link">url链接</span>)</span><br></pre></td></tr></table></figure><p>该方法优点是方便，缺点是url链接容易改变，因为博客中文章的链接通常是http:&#x2F;&#x2F;***&#x2F;2023&#x2F;06&#x2F;28&#x2F;Hexo教程(二)博客写作，如果更改date和title，该链接就失效了，所以用下面的方法会更好。</p><h4 id="标签插件方法"><a href="#标签插件方法" class="headerlink" title="标签插件方法"></a>标签插件方法</h4><blockquote><p>虽然可以直接写入文章最终<strong>链接</strong>的方法引用，但是如果原本的文章链接变化了，就不能使用了，所以最好的方法就是在生成系统之内直接引用。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_path filename %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% post_</span>link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Front-matter </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
